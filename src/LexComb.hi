__interface "Main" LexComb 1 500 where
__export  LexComb Context Indent P closeP0 closeP1 convertFloating convertIntegral convertSignedFloating convertSignedIntegral failP parse parseError popContext pushContext returnP thenP thenPzu;
import Monad;
import Position :: 1 1 1 Position 1 first 1 zdfEqPosition 1 zdfOrdPosition 1 zdfShowPosition 1;
import Error :: 1 1 1 Error 1 zdfEqError 1 zdfMonadError 1 zdfOrdError 1 zdfShowError 1;
import PrelBase ! :: 1;
import PrelFloat :: 1;
import PrelNum :: 1;
import PrelTup :: 1;
import PrelIOBase :: 1;
import PrelReal :: 1;
import PrelEnum :: 1;
import PrelShow :: 1;
import PrelList :: 1;
import Char :: 1;
infixl 1 thenPzu infixl 1 thenP;
convertSignedFloating :: __forall a (PrelReal.Fractional a) => PrelBase.String -> PrelBase.String -> PrelBase.Int -> a;
convertFloating :: __forall a (PrelReal.Fractional a) => PrelBase.String -> PrelBase.String -> PrelBase.Int -> a;
convertIntegral :: __forall a (PrelNum.Num a) => a -> PrelBase.String -> a;
convertSignedIntegral :: __forall a (PrelNum.Num a) => a -> PrelBase.String -> a;
popContext :: __forall a => P a -> P a;
pushContext :: __forall a => PrelBase.Int -> P a -> P a;
parseError :: Position.Position -> PrelBase.String -> PrelBase.String;
closeP1 :: __forall a b => (a -> P b) -> P (a -> P b);
closeP0 :: __forall a => P a -> P (P a);
failP :: __forall a => Position.Position -> PrelBase.String -> P a;
thenPzu :: __forall a b => P a -> P b -> P b;
thenP :: __forall a b => P a -> (a -> P b) -> P b;
returnP :: __forall a => a -> P a;
parse :: __forall a => P a -> PrelIOBase.FilePath -> PrelBase.String -> Error.Error a;
type Indent = PrelBase.Int;
type Context = [Indent];
type P a = Position.Position -> PrelBase.String -> PrelBase.Bool -> Context -> Error.Error a;
