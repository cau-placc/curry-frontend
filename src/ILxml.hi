__interface "Main" ILxml 2 500 where
__export  ILxml level splitDecls xmlAppArgs xmlApply xmlApplyFunctor xmlBeginFunction xmlBinding xmlBody xmlBranch xmlBuildDicc xmlCase xmlCombApply xmlCombHeading xmlConsPattern xmlConstructor xmlConstructorBegin xmlElement xmlEndFunction xmlExpr xmlExprVar xmlFixity xmlFloat xmlFormat xmlFree xmlFunctionArity xmlFunctionDecl xmlHeadingWithArity xmlIdent xmlImportDecl xmlInt xmlLet xmlLetrec xmlLhs xmlLines xmlLit xmlLitPattern xmlLiteral xmlLookUp xmlMapDicc xmlModule xmlModuleDecl xmlModuleIdent xmlNewVar xmlOperatorDecl xmlOr xmlPattern xmlQualIdent xmlRhs xmlRule xmlSingleApp xmlTranslationDecl xmlType xmlTypeConsBegin xmlTypeDecl xmlTypeFun xmlTypeParams xmlTypeVar xmlVar;
__export  Pretty Doc;
import PrelReal;
import Monad;
import PrelConc;
import Maybe;
import Env;
import Base;
import List;
import Ratio;
import CurryPP;
import Utils;
import Set;
import TopEnv;
import Types;
import Map;
import Ident :: 1 1 1 Ident 1 ModuleIdent 1 QualIdent 1 mkIdent 1 moduleName 1 name 1 qualName 1 qualifyWith 1 unqualify 1 zdfEqIdent 1 zdfEqModuleIdent 1 zdfEqQualIdent 1 zdfOrdIdent 1 zdfOrdModuleIdent 1 zdfOrdQualIdent 1 zdfShowIdent 1 zdfShowModuleIdent 1 zdfShowQualIdent 1;
import PrelBase ! :: 1;
import PrelFloat :: 1;
import PrelNum :: 1;
import PrelTup :: 1;
import PrelIOBase :: 1;
import PrelEnum :: 1;
import PrelShow :: 1;
import PrelList :: 1;
import Pretty :: 1 1 1 Doc 1 TextDetails 1 empty 1 nest 1 text 1 vcat 1 zdfShowDoc 1 zdzd 1 zlzg 1;
import IL :: 1 1 1 Alt 1 Binding 1 CallConv 1 ConstrDecl 1 ConstrTerm 1 Decl 1 Eval 1 Expression 1 Literal 1 Module 1 Type 1 zdfEqAlt 1 zdfEqBinding 1 zdfEqCallConv 1 zdfEqConstrDecl 1 zdfEqConstrTerm 1 zdfEqDecl 1 zdfEqEval 1 zdfEqExpression 1 zdfEqLiteral 1 zdfEqModule 1 zdfEqType 1 zdfShowAlt 1 zdfShowBinding 1 zdfShowCallConv 1 zdfShowConstrDecl 1 zdfShowConstrTerm 1 zdfShowDecl 1 zdfShowEval 1 zdfShowExpression 1 zdfShowLiteral 1 zdfShowModule 1 zdfShowType 1;
import CurrySyntax :: 1 1 1 ConstrDecl 1 IDecl 1 Infix 1 NewConstrDecl 1 TypeExpr 1 zdfEqIDecl 1 zdfEqInfix 1 zdfShowIDecl 1 zdfShowInfix 1;
import ILTrans ! :: 1 1 1;
import CurryInfo :: 1 1 1 CurryInfo 1 getExports 1 getOpFixity 1;
import PrelMaybe :: 1;
import Position :: 1 1 Position 1 zdfEqPosition 1 zdfOrdPosition 1 zdfShowPosition 1;
;
xmlModuleIdent :: Ident.ModuleIdent -> Pretty.Doc;
xmlFormat :: PrelBase.String -> PrelBase.String;
xmlQualIdent :: Ident.QualIdent -> Pretty.Doc;
xmlFloat :: PrelFloat.Double -> Pretty.Doc;
xmlInt :: PrelBase.Int -> Pretty.Doc;
xmlIdent :: Ident.Ident -> Pretty.Doc;
xmlTranslationDecl :: Ident.QualIdent -> Pretty.Doc;
2 xmlFixity :: CurrySyntax.Infix -> Pretty.Doc;
2 xmlOperatorDecl :: CurrySyntax.IDecl -> Pretty.Doc;
xmlLit :: IL.Literal -> Pretty.Doc;
xmlLitPattern :: Pretty.Doc -> Pretty.Doc;
xmlLiteral :: Pretty.Doc -> Pretty.Doc;
xmlVar :: PrelBase.Int -> Pretty.Doc;
xmlNewVar :: [(PrelBase.Int, Ident.Ident)] -> PrelBase.Int;
xmlLookUp :: Ident.Ident -> [(PrelBase.Int, Ident.Ident)] -> PrelBase.Int;
xmlBuildDicc :: [Ident.Ident] -> [(PrelBase.Int, Ident.Ident)];
xmlMapDicc :: __forall a => [(PrelBase.Int, Ident.Ident)] -> ([(PrelBase.Int, Ident.Ident)] -> a -> (Pretty.Doc, [(PrelBase.Int, Ident.Ident)])) -> [a] -> ([Pretty.Doc], [(PrelBase.Int, Ident.Ident)]);
xmlLines :: __forall a => (a -> Pretty.Doc) -> [a] -> Pretty.Doc;
xmlElement :: __forall a (PrelBase.Eq a) => PrelBase.String -> (a -> Pretty.Doc) -> [a] -> Pretty.Doc;
splitDecls :: [IL.Decl] -> ([IL.Decl], [IL.Decl]);
xmlLetrec :: [(PrelBase.Int, Ident.Ident)] -> [IL.Binding] -> IL.Expression -> (Pretty.Doc, [(PrelBase.Int, Ident.Ident)]);
xmlBinding :: [(PrelBase.Int, Ident.Ident)] -> IL.Binding -> (Pretty.Doc, [(PrelBase.Int, Ident.Ident)]);
xmlLet :: [(PrelBase.Int, Ident.Ident)] -> IL.Binding -> IL.Expression -> (Pretty.Doc, [(PrelBase.Int, Ident.Ident)]);
xmlFree :: [(PrelBase.Int, Ident.Ident)] -> Ident.Ident -> IL.Expression -> (Pretty.Doc, [(PrelBase.Int, Ident.Ident)]);
xmlConsPattern :: [(PrelBase.Int, Ident.Ident)] -> Ident.QualIdent -> [Ident.Ident] -> (Pretty.Doc, [(PrelBase.Int, Ident.Ident)]);
xmlPattern :: [(PrelBase.Int, Ident.Ident)] -> IL.ConstrTerm -> (Pretty.Doc, [(PrelBase.Int, Ident.Ident)]);
xmlBranch :: [(PrelBase.Int, Ident.Ident)] -> IL.Alt -> (Pretty.Doc, [(PrelBase.Int, Ident.Ident)]);
xmlOr :: [(PrelBase.Int, Ident.Ident)] -> IL.Expression -> IL.Expression -> (Pretty.Doc, [(PrelBase.Int, Ident.Ident)]);
xmlCase :: [(PrelBase.Int, Ident.Ident)] -> IL.Eval -> IL.Expression -> [IL.Alt] -> (Pretty.Doc, [(PrelBase.Int, Ident.Ident)]);
xmlAppArgs :: IL.Expression -> (IL.Expression, [IL.Expression]);
xmlCombApply :: [(PrelBase.Int, Ident.Ident)] -> Pretty.Doc -> Pretty.Doc -> PrelBase.Int -> [IL.Expression] -> (Pretty.Doc, [(PrelBase.Int, Ident.Ident)]);
xmlApplyFunctor :: [(PrelBase.Int, Ident.Ident)] -> Ident.QualIdent -> PrelBase.Int -> [IL.Expression] -> PrelBase.Bool -> (Pretty.Doc, [(PrelBase.Int, Ident.Ident)]);
xmlApply :: [(PrelBase.Int, Ident.Ident)] -> IL.Expression -> (IL.Expression, [IL.Expression]) -> (Pretty.Doc, [(PrelBase.Int, Ident.Ident)]);
xmlExprVar :: [(PrelBase.Int, Ident.Ident)] -> Ident.Ident -> (Pretty.Doc, [(PrelBase.Int, Ident.Ident)]);
xmlCombHeading :: Pretty.Doc -> Pretty.Doc -> PrelBase.Bool -> Pretty.Doc;
xmlSingleApp :: Ident.QualIdent -> PrelBase.Int -> PrelBase.Bool -> Pretty.Doc;
xmlExpr :: [(PrelBase.Int, Ident.Ident)] -> IL.Expression -> (Pretty.Doc, [(PrelBase.Int, Ident.Ident)]);
xmlRhs :: [Ident.Ident] -> IL.Expression -> Pretty.Doc;
xmlLhs :: [Ident.Ident] -> Pretty.Doc;
xmlRule :: [Ident.Ident] -> IL.Expression -> Pretty.Doc;
xmlFunctionArity :: IL.Type -> PrelBase.Int;
xmlEndFunction :: Pretty.Doc;
xmlBeginFunction :: Ident.QualIdent -> PrelBase.Int -> IL.Type -> Pretty.Doc;
xmlFunctionDecl :: IL.Decl -> Pretty.Doc;
xmlTypeFun :: IL.Type -> IL.Type -> Pretty.Doc;
xmlTypeVar :: PrelBase.Int -> Pretty.Doc;
xmlTypeConsBegin :: Ident.QualIdent -> PrelBase.Bool -> Pretty.Doc;
xmlType :: IL.Type -> Pretty.Doc;
xmlHeadingWithArity :: PrelBase.String -> Ident.QualIdent -> PrelBase.Int -> PrelBase.Bool -> Pretty.Doc;
xmlConstructorBegin :: Ident.QualIdent -> PrelBase.Int -> Pretty.Doc;
xmlConstructor :: IL.ConstrDecl [IL.Type] -> Pretty.Doc;
xmlTypeParams :: PrelBase.Int -> Pretty.Doc;
xmlTypeDecl :: IL.Decl -> Pretty.Doc;
xmlImportDecl :: Ident.ModuleIdent -> Pretty.Doc;
xmlModuleDecl :: Ident.ModuleIdent -> Pretty.Doc;
2 xmlBody :: CurryInfo.CurryInfo -> IL.Module -> Pretty.Doc;
2 xmlModule :: CurryInfo.CurryInfo -> IL.Module -> Pretty.Doc;
level :: PrelBase.Int;
