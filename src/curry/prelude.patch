--- /Users/Shared/pakcs/lib/prelude.curry	Fri Feb 20 09:36:53 2004
+++ prelude.curry	Tue Oct 19 13:21:48 2004
@@ -80,7 +80,8 @@
 
 -- Boolean values
 -- already defined as builtin, since it is required for if-then-else
---++ data Bool = True | False
+-- (no longer true for the MCC front-end)
+data Bool = True | False
 
 --- Sequential conjunction on Booleans.
 (&&)            :: Bool -> Bool -> Bool
@@ -390,6 +391,9 @@
                                    | otherwise = (x >= m)
 
 
+data Char
+type String = [Char]
+
 --- Converts a character into its ASCII value.
 ord :: Char -> Int
 ord external
@@ -400,6 +404,8 @@
 
 
 -- Types of primitive arithmetic functions and predicates
+data Int
+
 
 --- Adds two integers.
 (+)   :: Int -> Int -> Int
@@ -448,8 +454,12 @@
 (>=) external
 
 
+data Float
+
+
 -- Constraints
 --++ data Success = Success
+data Success
 
 --- The equational constraint.
 --- (e1 =:= e2) is satisfiable if both sides e1 and e2 can be
@@ -496,6 +506,7 @@
 -- Monadic IO
 
 --++ data IO a  -- conceptually: World -> (a,World)
+data IO a
 
 --- Sequential composition of actions.
 --- @param a - An action
@@ -670,13 +681,13 @@
 --- To control failure and to return the solution in a lambda abstraction,
 --- we encapsulate the search with "solveAll".
 one     :: (a->Success) -> [a->Success]
-one g   = solveAll \x -> x =:= tryone g
+one g   = solveAll (\x -> x =:= tryone g)
 
 
 --- Searches the first solution that meets a specified condition.
 --- "pred" must be a unary Boolean function.
 condSearch        :: (a->Success) -> (a->Bool) -> [a->Success]
-condSearch g pred = one \x -> g x & pred x =:= True
+condSearch g pred = one (\x -> g x & pred x =:= True)
 
 
 --- Gets the best solution via left-to-right strategy according to

