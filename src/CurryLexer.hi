__interface "Main" CurryLexer 1 500 where
__export  CurryLexer Attributes{CharAttributes FloatAttributes IdentAttributes IntAttributes NoAttributes StringAttributes cval fval ival modul sval} Category{At Backquote Backslash Bar CharTok Colon Comma DotDot DoubleColon EOF Equals FloatTok Id Idzuas Idzuccall Idzuforall Idzuhiding Idzuinterface Idzuprimitive Idzuqualified IntTok KWzucase KWzuchoice KWzudata KWzudo KWzuelse KWzueval KWzuexternal KWzufree KWzuif KWzuimport KWzuin KWzuinfix KWzuinfixl KWzuinfixr KWzulet KWzumodule KWzunewtype KWzuof KWzurigid KWzuthen KWzutype KWzuwhere LeftArrow LeftBrace LeftBracket LeftParen QId QSym RightArrow RightBrace RightBracket RightParen Semicolon StringTok Sym SymzuDot SymzuMinus SymzuMinusDot Tilde Underscore VRightBrace VSemicolon} FailP SuccessP Token{Token} asciiEscape charTok floatTok idTok intTok isHexit isIdent isOctit isSym lexBOL lexChar lexCharEnd lexEscape lexExponent lexFile lexHexadecimal lexIdent lexNumber lexOctal lexOptExponent lexOptFraction lexOptQual lexQualIdent lexQualSym lexSignedExponent lexString lexStringEscape lexStringGap lexStringRest lexSym lexToken lexer nestedComment numEscape reservedzuandzuspecialzuids reservedzuandzuspecialzuops reservedzuids reservedzuops stringTok tok;
import Monad;
import Position :: 1 1 1 Position 1 incr 1 next 1 nl 1 tab 1 zdfEqPosition 1 zdfOrdPosition 1 zdfShowPosition 1;
import Char :: 1;
import PrelBase ! :: 1;
import PrelFloat :: 1;
import PrelNum :: 1;
import PrelTup :: 1;
import PrelIOBase :: 1;
import PrelReal :: 1;
import PrelEnum :: 1;
import PrelShow :: 1;
import PrelList :: 1;
import LexComb :: 1 1 1 Context 1 Indent 1 P 1 convertFloating 1 convertIntegral 1 failP 1 returnP 1 thenP 1;
import Map :: 1 1 1 FM 1 addToFM 1 fromListFM 1 lookupFM 1 zdfEqFM 1 zdfShowFM 1;
import Error :: 1 1 Error 1 zdfEqError 1 zdfOrdError 1 zdfShowError 1;
import Prelude :: 1;
import List :: 1;
import PrelMaybe :: 1;
;
instance {PrelBase.Eq Category} = zdfEqCategory ;
instance {PrelBase.Ord Category} = zdfOrdCategory ;
instance {PrelShow.Show Token} = zdfShowToken ;
instance {PrelShow.Show Attributes} = zdfShowAttributes ;
instance {PrelBase.Ord Token} = zdfOrdToken ;
instance {PrelBase.Eq Token} = zdfEqToken ;
asciiEscape :: __forall a => Position.Position -> (PrelBase.Char -> LexComb.P a) -> FailP a -> LexComb.P a;
numEscape :: __forall a => Position.Position -> (PrelBase.Char -> LexComb.P a) -> FailP a -> PrelBase.Int -> (PrelBase.Char -> PrelBase.Bool) -> LexComb.P a;
lexEscape :: __forall a => Position.Position -> (PrelBase.Char -> LexComb.P a) -> FailP a -> LexComb.P a;
lexStringGap :: __forall a => LexComb.P a -> FailP a -> LexComb.P a;
lexStringEscape :: __forall a => Position.Position -> (PrelBase.String -> LexComb.P a) -> FailP a -> PrelBase.String -> LexComb.P a;
lexStringRest :: __forall a => Position.Position -> SuccessP a -> FailP a -> PrelBase.String -> LexComb.P a;
lexString :: __forall a => Position.Position -> SuccessP a -> FailP a -> LexComb.P a;
lexCharEnd :: __forall a => Position.Position -> SuccessP a -> FailP a -> PrelBase.Char -> LexComb.P a;
lexChar :: __forall a => Position.Position -> SuccessP a -> FailP a -> LexComb.P a;
lexExponent :: __forall a => (Token -> LexComb.P a) -> PrelBase.String -> PrelBase.String -> (PrelBase.Int -> PrelBase.Int) -> LexComb.P a;
lexSignedExponent :: __forall a => (Token -> LexComb.P a) -> LexComb.P a -> PrelBase.String -> PrelBase.String -> LexComb.P a;
lexOptExponent :: __forall a => (Token -> LexComb.P a) -> Token -> PrelBase.String -> PrelBase.String -> LexComb.P a;
lexOptFraction :: __forall a => (Token -> LexComb.P a) -> Token -> PrelBase.String -> LexComb.P a;
lexHexadecimal :: __forall a => (Token -> LexComb.P a) -> LexComb.P a -> LexComb.P a;
lexOctal :: __forall a => (Token -> LexComb.P a) -> LexComb.P a -> LexComb.P a;
lexNumber :: __forall a => (Token -> LexComb.P a) -> LexComb.P a;
lexQualSym :: __forall a => (Token -> LexComb.P a) -> LexComb.P a -> [PrelBase.String] -> LexComb.P a;
lexQualIdent :: __forall a => (Token -> LexComb.P a) -> LexComb.P a -> [PrelBase.String] -> LexComb.P a;
lexOptQual :: __forall a => (Token -> LexComb.P a) -> Token -> [PrelBase.String] -> LexComb.P a;
lexSym :: __forall a => (Token -> LexComb.P a) -> LexComb.P a;
lexIdent :: __forall a => (Token -> LexComb.P a) -> LexComb.P a;
lexToken :: __forall a => SuccessP a -> FailP a -> LexComb.P a;
lexBOL :: __forall a => SuccessP a -> FailP a -> LexComb.P a;
nestedComment :: __forall a => Position.Position -> LexComb.P a -> FailP a -> LexComb.P a;
lexer :: __forall a => SuccessP a -> FailP a -> LexComb.P a;
lexFile :: LexComb.P [(Position.Position, Token)];
isHexit :: PrelBase.Char -> PrelBase.Bool;
isOctit :: PrelBase.Char -> PrelBase.Bool;
isSym :: PrelBase.Char -> PrelBase.Bool;
isIdent :: PrelBase.Char -> PrelBase.Bool;
reservedzuandzuspecialzuids :: Map.FM PrelBase.String Category;
reservedzuids :: Map.FM PrelBase.String Category;
reservedzuandzuspecialzuops :: Map.FM PrelBase.String Category;
reservedzuops :: Map.FM PrelBase.String Category;
stringTok :: PrelBase.String -> Token;
floatTok :: PrelBase.String -> PrelBase.String -> PrelBase.Int -> Token;
intTok :: PrelBase.Int -> PrelBase.String -> Token;
charTok :: PrelBase.Char -> Token;
idTok :: Category -> [PrelBase.String] -> PrelBase.String -> Token;
tok :: Category -> Token;
data Token = Token Category Attributes;
data Category = CharTok | IntTok | FloatTok | StringTok | Id | QId | Sym | QSym | LeftParen | RightParen | Semicolon | LeftBrace | RightBrace | LeftBracket | RightBracket | Comma | Underscore | Backquote | VSemicolon | VRightBrace | KWzucase | KWzuchoice | KWzudata | KWzudo | KWzuelse | KWzueval | KWzuexternal | KWzufree | KWzuif | KWzuimport | KWzuin | KWzuinfix | KWzuinfixl | KWzuinfixr | KWzulet | KWzumodule | KWzunewtype | KWzuof | KWzurigid | KWzuthen | KWzutype | KWzuwhere | At | Colon | DotDot | DoubleColon | Equals | Backslash | Bar | LeftArrow | RightArrow | Tilde | Idzuas | Idzuccall | Idzuforall | Idzuhiding | Idzuinterface | Idzuprimitive | Idzuqualified | SymzuDot | SymzuMinus | SymzuMinusDot | EOF;
data Attributes = NoAttributes | CharAttributes {cval :: PrelBase.Char} | IntAttributes {ival :: PrelBase.Int} | FloatAttributes {fval :: PrelFloat.Double} | StringAttributes {sval :: PrelBase.String} | IdentAttributes {modul :: [PrelBase.String], sval :: PrelBase.String};
type SuccessP a = Position.Position -> Token -> LexComb.P a;
type FailP a = Position.Position -> PrelBase.String -> LexComb.P a;
zdfEqCategory :: {PrelBase.Eq Category};
zdfOrdCategory :: {PrelBase.Ord Category};
zdfShowAttributes :: {PrelShow.Show Attributes};
zdfShowToken :: {PrelShow.Show Token};
zdfEqToken :: {PrelBase.Eq Token};
zdfOrdToken :: {PrelBase.Ord Token};
