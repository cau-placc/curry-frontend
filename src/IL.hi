__interface "Main" IL 1 500 where
__export  IL Alt{Alt} Binding{Binding} CallConv{CCall Primitive} ConstrDecl{ConstrDecl} ConstrTerm{ConstructorPattern LiteralPattern VariablePattern} Decl{DataDecl ExternalDecl FunctionDecl NewtypeDecl} Eval{Flex Rigid} Expression{Apply Case Constructor Exist Function Let Letrec Literal Or Variable} Literal{Char Float Int} Module{Module} Type{TypeArrow TypeConstructor TypeVariable};
import PrelList;
import Char;
import PrelMaybe;
import List;
import PrelBase ! :: 1;
import PrelFloat :: 1;
import PrelNum :: 1;
import PrelTup :: 1;
import PrelShow :: 1;
import Ident :: 1 1 1 Ident 1 ModuleIdent 1 QualIdent 1 zdfEqIdent 1 zdfEqModuleIdent 1 zdfEqQualIdent 1 zdfOrdIdent 1 zdfOrdModuleIdent 1 zdfOrdQualIdent 1 zdfShowIdent 1 zdfShowModuleIdent 1 zdfShowQualIdent 1;
;
instance {PrelBase.Eq Binding} = zdfEqBinding ;
instance {PrelShow.Show Binding} = zdfShowBinding ;
instance {PrelBase.Eq Alt} = zdfEqAlt ;
instance {PrelShow.Show Alt} = zdfShowAlt ;
instance {PrelBase.Eq Eval} = zdfEqEval ;
instance {PrelShow.Show Eval} = zdfShowEval ;
instance {PrelBase.Eq Expression} = zdfEqExpression ;
instance {PrelShow.Show Expression} = zdfShowExpression ;
instance {PrelBase.Eq ConstrTerm} = zdfEqConstrTerm ;
instance {PrelShow.Show ConstrTerm} = zdfShowConstrTerm ;
instance {PrelBase.Eq Literal} = zdfEqLiteral ;
instance {PrelShow.Show Literal} = zdfShowLiteral ;
instance {PrelBase.Eq Type} = zdfEqType ;
instance {PrelShow.Show Type} = zdfShowType ;
instance {PrelBase.Eq CallConv} = zdfEqCallConv ;
instance {PrelShow.Show CallConv} = zdfShowCallConv ;
instance __forall a (PrelBase.Eq a) => {PrelBase.Eq (ConstrDecl a)} = zdfEqConstrDecl ;
instance __forall a (PrelShow.Show a) => {PrelShow.Show (ConstrDecl a)} = zdfShowConstrDecl ;
instance {PrelBase.Eq Decl} = zdfEqDecl ;
instance {PrelShow.Show Decl} = zdfShowDecl ;
instance {PrelBase.Eq Module} = zdfEqModule ;
instance {PrelShow.Show Module} = zdfShowModule ;
data Module = Module Ident.ModuleIdent [Ident.ModuleIdent] [Decl];
data Decl = DataDecl Ident.QualIdent PrelBase.Int [ConstrDecl [Type]] | NewtypeDecl Ident.QualIdent PrelBase.Int (ConstrDecl Type) | FunctionDecl Ident.QualIdent [Ident.Ident] Type Expression | ExternalDecl Ident.QualIdent CallConv PrelBase.String Type;
data ConstrDecl a = ConstrDecl Ident.QualIdent a;
data CallConv = Primitive | CCall;
data Type = TypeConstructor Ident.QualIdent [Type] | TypeVariable PrelBase.Int | TypeArrow Type Type;
data Literal = Char PrelBase.Char | Int PrelBase.Int | Float PrelFloat.Double;
data ConstrTerm = LiteralPattern Literal | ConstructorPattern Ident.QualIdent [Ident.Ident] | VariablePattern Ident.Ident;
data Expression = Literal Literal | Variable Ident.Ident | Function Ident.QualIdent PrelBase.Int | Constructor Ident.QualIdent PrelBase.Int | Apply Expression Expression | Case Eval Expression [Alt] | Or Expression Expression | Exist Ident.Ident Expression | Let Binding Expression | Letrec [Binding] Expression;
data Eval = Rigid | Flex;
data Alt = Alt ConstrTerm Expression;
data Binding = Binding Ident.Ident Expression;
zdfShowConstrDecl :: __forall a (PrelShow.Show a) => {PrelShow.Show (ConstrDecl a)};
zdfEqConstrDecl :: __forall a (PrelBase.Eq a) => {PrelBase.Eq (ConstrDecl a)};
zdfShowCallConv :: {PrelShow.Show CallConv};
zdfEqCallConv :: {PrelBase.Eq CallConv};
zdfShowType :: {PrelShow.Show Type};
zdfEqType :: {PrelBase.Eq Type};
zdfShowLiteral :: {PrelShow.Show Literal};
zdfEqLiteral :: {PrelBase.Eq Literal};
zdfShowConstrTerm :: {PrelShow.Show ConstrTerm};
zdfEqConstrTerm :: {PrelBase.Eq ConstrTerm};
zdfShowEval :: {PrelShow.Show Eval};
zdfEqEval :: {PrelBase.Eq Eval};
zdfShowBinding :: {PrelShow.Show Binding};
zdfShowAlt :: {PrelShow.Show Alt};
zdfShowExpression :: {PrelShow.Show Expression};
zdfShowDecl :: {PrelShow.Show Decl};
zdfShowModule :: {PrelShow.Show Module};
zdfEqBinding :: {PrelBase.Eq Binding};
zdfEqAlt :: {PrelBase.Eq Alt};
zdfEqExpression :: {PrelBase.Eq Expression};
zdfEqDecl :: {PrelBase.Eq Decl};
zdfEqModule :: {PrelBase.Eq Module};
