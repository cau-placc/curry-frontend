__interface "Main" CurryParser 1 ! 500 where
__export  CurryParser alt alts anonPattern anonType backquote backquotes bar braces brackets caseExpr char checkBackquote checkFloat checkInt colon comma con conId conSym condExpr conop constant constrDecl constrTerm0 constrTerm1 constrTerm2 curriedLhs dataDecl declRhs decls doExpr dot equals existVars export exportSpec expr expr0 expr1 expr2 expr3 exprOrBindStmt externalDecl float fminus fun funDecl funId funLhs funListDecl funSym functionDecl funop gConSym gconId gconop globalDecls goal iDataDecl iFunctionDecl iHidingDecl iImportDecl iInfixDecl iNewtypeDecl iTypeDecl iTypeDeclLhs ident identPattern identType ifExpr importDecl importSpec infixDecl infixDeclLhs infixOp int intfDecl intfDecls lambdaExpr layout lazzyPattern leftArrow leftBrace leftBracket leftParen letExpr letStmt listExpr listPattern listType literal literalPattern localDefs mIdent minus moduleHeader negFloat negNum newConstrDecl newtypeDecl optAsPattern optInfixPattern optStmts optTuplePattern parenExpr parenMinusPattern parenPattern parenTuplePattern parenType parens parseGoal parseHeader parseIface parseInterface parseModule parseSource patDecl qConId qConSym qFunId qFunSym qIdent qSym qcon qconop qfun qfunop qtycon quals reqStmts rhs rightBrace rightBracket rightParen semicolon stmt stmts string sym token tokenOps tokens topDecl tupleCommas tupleType tycon type0 type1 type2 typeDecl typeDeclLhs tyvar valListDecl valueDecl valueDecls var varId variable;
import Char;
import Monad;
import Maybe;
import List;
import Set;
import Ident :: 1 1 1 Ident 1 ModuleIdent 1 QualIdent 1 anonId 1 fminusId 1 isQTupleId 1 isQualified 1 mainMIdent 1 minusId 1 mkIdent 1 mkMIdent 1 qConsId 1 qTupleId 1 qualify 1 qualifyWith 1 unqualify 1 zdfEqIdent 1 zdfEqModuleIdent 1 zdfEqQualIdent 1 zdfOrdIdent 1 zdfOrdModuleIdent 1 zdfOrdQualIdent 1 zdfShowIdent 1 zdfShowModuleIdent 1 zdfShowQualIdent 1;
import Position :: 1 1 1 Position 1 zdfEqPosition 1 zdfOrdPosition 1 zdfShowPosition 1;
import Error :: 1 1 1 Error 1 zdfEqError 1 zdfMonadError 1 zdfOrdError 1 zdfShowError 1;
import PrelBase ! :: 1;
import PrelFloat :: 1;
import PrelNum :: 1;
import PrelTup :: 1;
import PrelIOBase :: 1;
import PrelReal :: 1;
import PrelEnum :: 1;
import PrelShow :: 1;
import PrelList :: 1;
import LLParseComb :: 1 1 1 FailureCont 1 Lexer 1 ParseFun 1 Parser 1 SuccessCont 1 Symbol 1 applyParser 1 bracket 1 chainr1 1 layoutEnd 1 layoutOff 1 layoutOn 1 many 1 many1 1 ops 1 opt 1 position 1 prefixParser 1 sepBy 1 sepBy1 1 succeed 1 symbol 1 zdfShowParser 1 zlz63Uz63Uzg 1 zlz63Uzg 1 zlzbz63Uzg 1 zlzbzg 1 zlzdzg 1 zlzdzmzg 1 zlzizg 1 zlzmztzg 1 zlzrzg 1 zlztzg 1 zlztzmzg 1 zlztztzg 1;
import CurryLexer :: 1 1 1 Attributes 1 Category 1 FailP 1 SuccessP 1 Token 1 lexer 1 zdfEqCategory 1 zdfEqToken 1 zdfOrdCategory 1 zdfOrdToken 1 zdfShowAttributes 1 zdfShowToken 1;
import CurrySyntax :: 1 1 1 Alt 1 CallConv 1 CondExpr 1 ConstrDecl 1 ConstrTerm 1 Decl 1 Equation 1 EvalAnnotation 1 Export 1 ExportSpec 1 Expression 1 Goal 1 IDecl 1 Import 1 ImportSpec 1 Infix 1 InfixOp 1 Interface 1 Lhs 1 Literal 1 Module 1 NewConstrDecl 1 Qualified 1 Rhs 1 Statement 1 TypeExpr 1 zdfEqAlt 1 zdfEqCallConv 1 zdfEqCondExpr 1 zdfEqConstrDecl 1 zdfEqConstrTerm 1 zdfEqDecl 1 zdfEqEquation 1 zdfEqEvalAnnotation 1 zdfEqExport 1 zdfEqExportSpec 1 zdfEqExpression 1 zdfEqGoal 1 zdfEqIDecl 1 zdfEqImport 1 zdfEqImportSpec 1 zdfEqInfix 1 zdfEqInfixOp 1 zdfEqInterface 1 zdfEqLhs 1 zdfEqLiteral 1 zdfEqModule 1 zdfEqNewConstrDecl 1 zdfEqRhs 1 zdfEqStatement 1 zdfEqTypeExpr 1 zdfShowAlt 1 zdfShowCallConv 1 zdfShowCondExpr 1 zdfShowConstrDecl 1 zdfShowConstrTerm 1 zdfShowDecl 1 zdfShowEquation 1 zdfShowEvalAnnotation 1 zdfShowExport 1 zdfShowExportSpec 1 zdfShowExpression 1 zdfShowGoal 1 zdfShowIDecl 1 zdfShowImport 1 zdfShowImportSpec 1 zdfShowInfix 1 zdfShowInfixOp 1 zdfShowInterface 1 zdfShowLhs 1 zdfShowLiteral 1 zdfShowModule 1 zdfShowNewConstrDecl 1 zdfShowRhs 1 zdfShowStatement 1 zdfShowTypeExpr 1;
import LexComb :: 1 1 1 Context 1 Indent 1 P 1;
import Map :: 1 1 FM 1;
import Prelude :: 1;
import PrelMaybe :: 1;
;
instance {LLParseComb.Symbol CurryLexer.Token} = zdfSymbolToken ;
rightBrace :: __forall a => LLParseComb.Parser CurryLexer.Token CurryLexer.Attributes a;
leftArrow :: __forall a => LLParseComb.Parser CurryLexer.Token CurryLexer.Attributes a;
leftBrace :: __forall a => LLParseComb.Parser CurryLexer.Token CurryLexer.Attributes a;
rightBracket :: __forall a => LLParseComb.Parser CurryLexer.Token CurryLexer.Attributes a;
leftBracket :: __forall a => LLParseComb.Parser CurryLexer.Token CurryLexer.Attributes a;
rightParen :: __forall a => LLParseComb.Parser CurryLexer.Token CurryLexer.Attributes a;
leftParen :: __forall a => LLParseComb.Parser CurryLexer.Token CurryLexer.Attributes a;
checkBackquote :: __forall a => LLParseComb.Parser CurryLexer.Token CurryLexer.Attributes a;
backquote :: __forall a => LLParseComb.Parser CurryLexer.Token CurryLexer.Attributes a;
equals :: __forall a => LLParseComb.Parser CurryLexer.Token CurryLexer.Attributes a;
bar :: __forall a => LLParseComb.Parser CurryLexer.Token CurryLexer.Attributes a;
semicolon :: __forall a => LLParseComb.Parser CurryLexer.Token CurryLexer.Attributes a;
comma :: __forall a => LLParseComb.Parser CurryLexer.Token CurryLexer.Attributes a;
dot :: __forall a => LLParseComb.Parser CurryLexer.Token CurryLexer.Attributes a;
tokenOps :: __forall a b => [(CurryLexer.Category, a)] -> LLParseComb.Parser CurryLexer.Token a b;
tokens :: __forall a => [CurryLexer.Category] -> LLParseComb.Parser CurryLexer.Token CurryLexer.Attributes a;
token :: __forall a => CurryLexer.Category -> LLParseComb.Parser CurryLexer.Token CurryLexer.Attributes a;
backquotes :: __forall a b => LLParseComb.Parser CurryLexer.Token a b -> LLParseComb.Parser CurryLexer.Token a b;
parens :: __forall a b => LLParseComb.Parser CurryLexer.Token a b -> LLParseComb.Parser CurryLexer.Token a b;
brackets :: __forall a b => LLParseComb.Parser CurryLexer.Token a b -> LLParseComb.Parser CurryLexer.Token a b;
braces :: __forall a b => LLParseComb.Parser CurryLexer.Token a b -> LLParseComb.Parser CurryLexer.Token a b;
layout :: __forall a b => LLParseComb.Parser CurryLexer.Token a b -> LLParseComb.Parser CurryLexer.Token a b;
tupleCommas :: __forall a => LLParseComb.Parser CurryLexer.Token Ident.QualIdent a;
fminus :: __forall a => LLParseComb.Parser CurryLexer.Token Ident.Ident a;
minus :: __forall a => LLParseComb.Parser CurryLexer.Token Ident.Ident a;
colon :: __forall a => LLParseComb.Parser CurryLexer.Token Ident.QualIdent a;
qSym :: __forall a => LLParseComb.Parser CurryLexer.Token Ident.QualIdent a;
sym :: __forall a => LLParseComb.Parser CurryLexer.Token Ident.Ident a;
mIdent :: __forall a => LLParseComb.Parser CurryLexer.Token Ident.ModuleIdent a;
qIdent :: __forall a => LLParseComb.Parser CurryLexer.Token Ident.QualIdent a;
ident :: __forall a => LLParseComb.Parser CurryLexer.Token Ident.Ident a;
gconop :: __forall a => LLParseComb.Parser CurryLexer.Token Ident.QualIdent a;
qconop :: __forall a => LLParseComb.Parser CurryLexer.Token Ident.QualIdent a;
qfunop :: __forall a => LLParseComb.Parser CurryLexer.Token Ident.QualIdent a;
qcon :: __forall a => LLParseComb.Parser CurryLexer.Token Ident.QualIdent a;
qfun :: __forall a => LLParseComb.Parser CurryLexer.Token Ident.QualIdent a;
gConSym :: __forall a => LLParseComb.Parser CurryLexer.Token Ident.QualIdent a;
qConSym :: __forall a => LLParseComb.Parser CurryLexer.Token Ident.QualIdent a;
qFunSym :: __forall a => LLParseComb.Parser CurryLexer.Token Ident.QualIdent a;
qConId :: __forall a => LLParseComb.Parser CurryLexer.Token Ident.QualIdent a;
qFunId :: __forall a => LLParseComb.Parser CurryLexer.Token Ident.QualIdent a;
conop :: __forall a => LLParseComb.Parser CurryLexer.Token Ident.Ident a;
funop :: __forall a => LLParseComb.Parser CurryLexer.Token Ident.Ident a;
con :: __forall a => LLParseComb.Parser CurryLexer.Token Ident.Ident a;
fun :: __forall a => LLParseComb.Parser CurryLexer.Token Ident.Ident a;
var :: __forall a => LLParseComb.Parser CurryLexer.Token Ident.Ident a;
conSym :: __forall a => LLParseComb.Parser CurryLexer.Token Ident.Ident a;
funSym :: __forall a => LLParseComb.Parser CurryLexer.Token Ident.Ident a;
conId :: __forall a => LLParseComb.Parser CurryLexer.Token Ident.Ident a;
funId :: __forall a => LLParseComb.Parser CurryLexer.Token Ident.Ident a;
varId :: __forall a => LLParseComb.Parser CurryLexer.Token Ident.Ident a;
qtycon :: __forall a => LLParseComb.Parser CurryLexer.Token Ident.QualIdent a;
tyvar :: __forall a => LLParseComb.Parser CurryLexer.Token Ident.Ident a;
tycon :: __forall a => LLParseComb.Parser CurryLexer.Token Ident.Ident a;
string :: __forall a => LLParseComb.Parser CurryLexer.Token PrelBase.String a;
checkFloat :: __forall a => LLParseComb.Parser CurryLexer.Token PrelFloat.Double a;
float :: __forall a => LLParseComb.Parser CurryLexer.Token PrelFloat.Double a;
checkInt :: __forall a => LLParseComb.Parser CurryLexer.Token PrelBase.Int a;
int :: __forall a => LLParseComb.Parser CurryLexer.Token PrelBase.Int a;
char :: __forall a => LLParseComb.Parser CurryLexer.Token PrelBase.Char a;
exprOrBindStmt :: __forall a b => PrelBase.Bool -> LLParseComb.Parser CurryLexer.Token (CurrySyntax.Statement -> a) b -> LLParseComb.Parser CurryLexer.Token (CurrySyntax.Expression -> a) b -> LLParseComb.Parser CurryLexer.Token a b;
letStmt :: __forall a b => PrelBase.Bool -> LLParseComb.Parser CurryLexer.Token (CurrySyntax.Statement -> a) b -> LLParseComb.Parser CurryLexer.Token (CurrySyntax.Expression -> a) b -> LLParseComb.Parser CurryLexer.Token a b;
stmt :: __forall a b => PrelBase.Bool -> LLParseComb.Parser CurryLexer.Token (CurrySyntax.Statement -> a) b -> LLParseComb.Parser CurryLexer.Token (CurrySyntax.Expression -> a) b -> LLParseComb.Parser CurryLexer.Token a b;
quals :: __forall a => PrelBase.Bool -> LLParseComb.Parser CurryLexer.Token [CurrySyntax.Statement] a;
optStmts :: __forall a => PrelBase.Bool -> LLParseComb.Parser CurryLexer.Token (CurrySyntax.Expression -> ([CurrySyntax.Statement], CurrySyntax.Expression)) a;
reqStmts :: __forall a => PrelBase.Bool -> LLParseComb.Parser CurryLexer.Token (CurrySyntax.Statement -> ([CurrySyntax.Statement], CurrySyntax.Expression)) a;
stmts :: __forall a => PrelBase.Bool -> LLParseComb.Parser CurryLexer.Token ([CurrySyntax.Statement], CurrySyntax.Expression) a;
alt :: __forall a => PrelBase.Bool -> LLParseComb.Parser CurryLexer.Token CurrySyntax.Alt a;
alts :: __forall a => PrelBase.Bool -> LLParseComb.Parser CurryLexer.Token [CurrySyntax.Alt] a;
caseExpr :: __forall a => PrelBase.Bool -> LLParseComb.Parser CurryLexer.Token CurrySyntax.Expression a;
ifExpr :: __forall a => PrelBase.Bool -> LLParseComb.Parser CurryLexer.Token CurrySyntax.Expression a;
doExpr :: __forall a => PrelBase.Bool -> LLParseComb.Parser CurryLexer.Token CurrySyntax.Expression a;
letExpr :: __forall a => PrelBase.Bool -> LLParseComb.Parser CurryLexer.Token CurrySyntax.Expression a;
lambdaExpr :: __forall a => PrelBase.Bool -> LLParseComb.Parser CurryLexer.Token CurrySyntax.Expression a;
listExpr :: __forall a => PrelBase.Bool -> LLParseComb.Parser CurryLexer.Token CurrySyntax.Expression a;
infixOp :: __forall a => LLParseComb.Parser CurryLexer.Token CurrySyntax.InfixOp a;
parenExpr :: __forall a => PrelBase.Bool -> LLParseComb.Parser CurryLexer.Token CurrySyntax.Expression a;
variable :: __forall a => LLParseComb.Parser CurryLexer.Token CurrySyntax.Expression a;
constant :: __forall a => LLParseComb.Parser CurryLexer.Token CurrySyntax.Expression a;
expr3 :: __forall a => PrelBase.Bool -> LLParseComb.Parser CurryLexer.Token CurrySyntax.Expression a;
expr2 :: __forall a => PrelBase.Bool -> LLParseComb.Parser CurryLexer.Token CurrySyntax.Expression a;
expr1 :: __forall a => PrelBase.Bool -> LLParseComb.Parser CurryLexer.Token CurrySyntax.Expression a;
expr0 :: __forall a => PrelBase.Bool -> LLParseComb.Parser CurryLexer.Token CurrySyntax.Expression a;
expr :: __forall a => PrelBase.Bool -> LLParseComb.Parser CurryLexer.Token CurrySyntax.Expression a;
condExpr :: __forall a b => PrelBase.Bool -> LLParseComb.Parser CurryLexer.Token a b -> LLParseComb.Parser CurryLexer.Token CurrySyntax.CondExpr b;
parenTuplePattern :: __forall a => LLParseComb.Parser CurryLexer.Token CurrySyntax.ConstrTerm a;
parenMinusPattern :: __forall a => LLParseComb.Parser CurryLexer.Token (Ident.Ident -> CurrySyntax.ConstrTerm) a -> LLParseComb.Parser CurryLexer.Token (Ident.Ident -> CurrySyntax.ConstrTerm) a;
optTuplePattern :: __forall a => LLParseComb.Parser CurryLexer.Token (CurrySyntax.ConstrTerm -> CurrySyntax.ConstrTerm) a;
optInfixPattern :: __forall a => LLParseComb.Parser CurryLexer.Token (CurrySyntax.ConstrTerm -> CurrySyntax.ConstrTerm) a;
optAsPattern :: __forall a => LLParseComb.Parser CurryLexer.Token (Ident.Ident -> CurrySyntax.ConstrTerm) a;
negFloat :: __forall a => LLParseComb.Parser CurryLexer.Token (Ident.Ident -> CurrySyntax.ConstrTerm) a;
negNum :: __forall a => LLParseComb.Parser CurryLexer.Token (Ident.Ident -> CurrySyntax.ConstrTerm) a;
gconId :: __forall a => LLParseComb.Parser CurryLexer.Token Ident.QualIdent a;
lazzyPattern :: __forall a => LLParseComb.Parser CurryLexer.Token CurrySyntax.ConstrTerm a;
listPattern :: __forall a => LLParseComb.Parser CurryLexer.Token CurrySyntax.ConstrTerm a;
parenPattern :: __forall a => LLParseComb.Parser CurryLexer.Token CurrySyntax.ConstrTerm a;
identPattern :: __forall a => LLParseComb.Parser CurryLexer.Token CurrySyntax.ConstrTerm a;
anonPattern :: __forall a => LLParseComb.Parser CurryLexer.Token CurrySyntax.ConstrTerm a;
literalPattern :: __forall a => LLParseComb.Parser CurryLexer.Token CurrySyntax.ConstrTerm a;
constrTerm2 :: __forall a => LLParseComb.Parser CurryLexer.Token CurrySyntax.ConstrTerm a;
constrTerm1 :: __forall a => LLParseComb.Parser CurryLexer.Token CurrySyntax.ConstrTerm a;
constrTerm0 :: __forall a => LLParseComb.Parser CurryLexer.Token CurrySyntax.ConstrTerm a;
literal :: __forall a => LLParseComb.Parser CurryLexer.Token CurrySyntax.Literal a;
listType :: __forall a => LLParseComb.Parser CurryLexer.Token CurrySyntax.TypeExpr a;
tupleType :: __forall a => LLParseComb.Parser CurryLexer.Token CurrySyntax.TypeExpr a;
parenType :: __forall a => LLParseComb.Parser CurryLexer.Token CurrySyntax.TypeExpr a;
identType :: __forall a => LLParseComb.Parser CurryLexer.Token CurrySyntax.TypeExpr a;
anonType :: __forall a => LLParseComb.Parser CurryLexer.Token CurrySyntax.TypeExpr a;
type2 :: __forall a => LLParseComb.Parser CurryLexer.Token CurrySyntax.TypeExpr a;
type1 :: __forall a => LLParseComb.Parser CurryLexer.Token CurrySyntax.TypeExpr a;
type0 :: __forall a => LLParseComb.Parser CurryLexer.Token CurrySyntax.TypeExpr a;
iFunctionDecl :: __forall a => LLParseComb.Parser CurryLexer.Token CurrySyntax.IDecl a;
iTypeDeclLhs :: __forall a b => (Position.Position -> Ident.QualIdent -> [Ident.Ident] -> a) -> CurryLexer.Category -> LLParseComb.Parser CurryLexer.Token a b;
iTypeDecl :: __forall a => LLParseComb.Parser CurryLexer.Token CurrySyntax.IDecl a;
iNewtypeDecl :: __forall a => LLParseComb.Parser CurryLexer.Token CurrySyntax.IDecl a;
iDataDecl :: __forall a => LLParseComb.Parser CurryLexer.Token CurrySyntax.IDecl a;
iHidingDecl :: __forall a => LLParseComb.Parser CurryLexer.Token CurrySyntax.IDecl a;
iInfixDecl :: __forall a => LLParseComb.Parser CurryLexer.Token CurrySyntax.IDecl a;
iImportDecl :: __forall a => LLParseComb.Parser CurryLexer.Token CurrySyntax.IDecl a;
intfDecl :: __forall a => LLParseComb.Parser CurryLexer.Token CurrySyntax.IDecl a;
intfDecls :: __forall a => LLParseComb.Parser CurryLexer.Token [CurrySyntax.IDecl] a;
externalDecl :: __forall a => LLParseComb.Parser CurryLexer.Token CurrySyntax.Decl a;
rhs :: __forall a b => PrelBase.Bool -> LLParseComb.Parser CurryLexer.Token a b -> LLParseComb.Parser CurryLexer.Token CurrySyntax.Rhs b;
declRhs :: __forall a => PrelBase.Bool -> LLParseComb.Parser CurryLexer.Token CurrySyntax.Rhs a;
curriedLhs :: __forall a => LLParseComb.Parser CurryLexer.Token (Ident.Ident, CurrySyntax.Lhs) a;
funLhs :: __forall a => LLParseComb.Parser CurryLexer.Token (Ident.Ident, CurrySyntax.Lhs) a;
valListDecl :: __forall a => PrelBase.Bool -> LLParseComb.Parser CurryLexer.Token ([Ident.Ident] -> Position.Position -> CurrySyntax.Decl) a;
funListDecl :: __forall a => PrelBase.Bool -> LLParseComb.Parser CurryLexer.Token ([Ident.Ident] -> Position.Position -> CurrySyntax.Decl) a;
patDecl :: CurrySyntax.ConstrTerm -> CurrySyntax.Rhs -> Position.Position -> CurrySyntax.Decl;
funDecl :: (Ident.Ident, CurrySyntax.Lhs) -> CurrySyntax.Rhs -> Position.Position -> CurrySyntax.Decl;
valueDecl :: __forall a => PrelBase.Bool -> LLParseComb.Parser CurryLexer.Token CurrySyntax.Decl a;
functionDecl :: __forall a => PrelBase.Bool -> LLParseComb.Parser CurryLexer.Token CurrySyntax.Decl a;
existVars :: __forall a => PrelBase.Bool -> LLParseComb.Parser CurryLexer.Token [Ident.Ident] a;
newConstrDecl :: __forall a => LLParseComb.Parser CurryLexer.Token CurrySyntax.NewConstrDecl a;
constrDecl :: __forall a => PrelBase.Bool -> LLParseComb.Parser CurryLexer.Token CurrySyntax.ConstrDecl a;
typeDeclLhs :: __forall a b => (Position.Position -> Ident.Ident -> [Ident.Ident] -> a) -> CurryLexer.Category -> LLParseComb.Parser CurryLexer.Token a b;
typeDecl :: __forall a => LLParseComb.Parser CurryLexer.Token CurrySyntax.Decl a;
newtypeDecl :: __forall a => LLParseComb.Parser CurryLexer.Token CurrySyntax.Decl a;
dataDecl :: __forall a => PrelBase.Bool -> LLParseComb.Parser CurryLexer.Token CurrySyntax.Decl a;
infixDeclLhs :: __forall a b => (Position.Position -> CurrySyntax.Infix -> PrelBase.Int -> a) -> LLParseComb.Parser CurryLexer.Token a b;
infixDecl :: __forall a => LLParseComb.Parser CurryLexer.Token CurrySyntax.Decl a;
importSpec :: __forall a => LLParseComb.Parser CurryLexer.Token CurrySyntax.ImportSpec a;
importDecl :: __forall a => LLParseComb.Parser CurryLexer.Token CurrySyntax.Decl a;
valueDecls :: __forall a => PrelBase.Bool -> LLParseComb.Parser CurryLexer.Token [CurrySyntax.Decl] a;
localDefs :: __forall a => PrelBase.Bool -> LLParseComb.Parser CurryLexer.Token [CurrySyntax.Decl] a;
topDecl :: __forall a => PrelBase.Bool -> LLParseComb.Parser CurryLexer.Token CurrySyntax.Decl a;
globalDecls :: __forall a => PrelBase.Bool -> LLParseComb.Parser CurryLexer.Token [CurrySyntax.Decl] a;
decls :: __forall a => PrelBase.Bool -> LLParseComb.Parser CurryLexer.Token [CurrySyntax.Decl] a;
goal :: __forall a => LLParseComb.Parser CurryLexer.Token CurrySyntax.Goal a;
parseGoal :: PrelBase.String -> Error.Error CurrySyntax.Goal;
parseIface :: __forall a => LLParseComb.Parser CurryLexer.Token CurrySyntax.Interface a;
parseInterface :: PrelIOBase.FilePath -> PrelBase.String -> Error.Error CurrySyntax.Interface;
export :: __forall a => LLParseComb.Parser CurryLexer.Token CurrySyntax.Export a;
exportSpec :: __forall a => LLParseComb.Parser CurryLexer.Token CurrySyntax.ExportSpec a;
moduleHeader :: __forall a => LLParseComb.Parser CurryLexer.Token ([CurrySyntax.Decl] -> CurrySyntax.Module) a;
parseModule :: __forall a => PrelBase.Bool -> LLParseComb.Parser CurryLexer.Token CurrySyntax.Module a;
parseHeader :: PrelIOBase.FilePath -> PrelBase.String -> Error.Error CurrySyntax.Module;
parseSource :: PrelBase.Bool -> PrelIOBase.FilePath -> PrelBase.String -> Error.Error CurrySyntax.Module;
zdfSymbolToken :: {LLParseComb.Symbol CurryLexer.Token};
