\nwfilename{stack.nw}\nwbegindocs{0}% -*- noweb-code-mode: c-mode -*-% ===> this file was generated automatically by noweave --- better not edit it
% $Id: stack.nw,v 2.4 2003/04/23 09:43:54 wlux Exp $
%
% Copyright (c) 2001-2003, Wolfgang Lux
% See ../LICENSE for the full license.
%
\subsection{The stack}
The stack of the abstract machine is used to pass arguments to a
function and return results. In addition, temporary variables and
return addresses are saved on the stack. Finally, the abstract machine
creates choicepoints and search contexts on the stack which are used
for the implementation of non-deterministic evaluation.

The stack is allocated in an array starting at {\Tt{}stack{\_}base\nwendquote} and
ending at {\Tt{}stack{\_}end\nwendquote}. The stack grows from top to bottom and
overflow when the stack pointer {\Tt{}sp\nwendquote} drops below {\Tt{}stack{\_}base\nwendquote}.
Note that {\Tt{}sp\nwendquote} always points to the node that was pushed last onto
the stack.

\nwenddocs{}\nwbegincode{1}\sublabel{NW2SamAc-3EiWCy-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2SamAc-3EiWCy-1}}}\moddef{stack.h~{\nwtagstyle{}\subpageref{NW2SamAc-3EiWCy-1}}}\endmoddef\nwstartdeflinemarkup\nwprevnextdefs{\relax}{NW2SamAc-3EiWCy-2}\nwenddeflinemarkup
extern Node **stack_base, **stack_end;
extern Node **sp;

\nwalsodefined{\\{NW2SamAc-3EiWCy-2}\\{NW2SamAc-3EiWCy-3}\\{NW2SamAc-3EiWCy-4}\\{NW2SamAc-3EiWCy-5}\\{NW2SamAc-3EiWCy-6}\\{NW2SamAc-3EiWCy-7}}\nwnotused{stack.h}\nwendcode{}\nwbegindocs{2}\nwdocspar
\nwenddocs{}\nwbegincode{3}\sublabel{NW2SamAc-cUlN6-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2SamAc-cUlN6-1}}}\moddef{stack.c~{\nwtagstyle{}\subpageref{NW2SamAc-cUlN6-1}}}\endmoddef\nwstartdeflinemarkup\nwprevnextdefs{\relax}{NW2SamAc-cUlN6-2}\nwenddeflinemarkup
#include "config.h"
#include <stdio.h>
#include <stdlib.h>
#include "run.h"
#include "heap.h"
#include "stack.h"
#include "main.h"

Node **stack_base;
Node **stack_end;
Node **sp;

\nwalsodefined{\\{NW2SamAc-cUlN6-2}\\{NW2SamAc-cUlN6-3}\\{NW2SamAc-cUlN6-4}\\{NW2SamAc-cUlN6-5}\\{NW2SamAc-cUlN6-6}}\nwnotused{stack.c}\nwendcode{}\nwbegindocs{4}\nwdocspar
The initialization function allocates a stack array with the specified
size and initializes the stack pointer.

\nwenddocs{}\nwbegincode{5}\sublabel{NW2SamAc-3EiWCy-2}\nwmargintag{{\nwtagstyle{}\subpageref{NW2SamAc-3EiWCy-2}}}\moddef{stack.h~{\nwtagstyle{}\subpageref{NW2SamAc-3EiWCy-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW2SamAc-3EiWCy-1}{NW2SamAc-3EiWCy-3}\nwenddeflinemarkup
extern void init_stack(unsigned int stack_size);

\nwendcode{}\nwbegindocs{6}\nwdocspar
\nwenddocs{}\nwbegincode{7}\sublabel{NW2SamAc-cUlN6-2}\nwmargintag{{\nwtagstyle{}\subpageref{NW2SamAc-cUlN6-2}}}\moddef{stack.c~{\nwtagstyle{}\subpageref{NW2SamAc-cUlN6-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW2SamAc-cUlN6-1}{NW2SamAc-cUlN6-3}\nwenddeflinemarkup
void
init_stack(unsigned int stack_size)
\{
    stack_size = (stack_size + pagemask) & ~pagemask;
    stack_base = (Node **)malloc(stack_size + pagemask);
    if ( stack_base == (Node **)0 )
    \{
        fprintf(stderr, "not enough memory to allocate stack\\n");
        exit(1);
    \}

    stack_base = (Node **)(((long)stack_base + pagemask) & ~pagemask); 
    stack_end  = stack_base + stack_size / word_size;
    sp         = stack_end;
\}

\nwendcode{}\nwbegindocs{8}\nwdocspar
Before allocating items on either stack it should be checked that
enough space is available. The macros {\Tt{}CHECK{\_}STACK\nwendquote} and
{\Tt{}CHECK{\_}STACK1\nwendquote} can be used for that purpose. If a stack overflow
occurs, the program is aborted with a fatal error by calling the
function {\Tt{}stack{\_}overflow\nwendquote}.

\nwenddocs{}\nwbegincode{9}\sublabel{NW2SamAc-3EiWCy-3}\nwmargintag{{\nwtagstyle{}\subpageref{NW2SamAc-3EiWCy-3}}}\moddef{stack.h~{\nwtagstyle{}\subpageref{NW2SamAc-3EiWCy-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW2SamAc-3EiWCy-2}{NW2SamAc-3EiWCy-4}\nwenddeflinemarkup
extern void stack_overflow(void) __attribute__ ((noreturn));

#define CHECK_STACK1()   if ( sp == stack_base ) stack_overflow();
#define CHECK_STACK(n)   if ( sp - (n) < stack_base ) stack_overflow();

\nwendcode{}\nwbegindocs{10}\nwdocspar
\nwenddocs{}\nwbegincode{11}\sublabel{NW2SamAc-cUlN6-3}\nwmargintag{{\nwtagstyle{}\subpageref{NW2SamAc-cUlN6-3}}}\moddef{stack.c~{\nwtagstyle{}\subpageref{NW2SamAc-cUlN6-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW2SamAc-cUlN6-2}{NW2SamAc-cUlN6-4}\nwenddeflinemarkup
void
stack_overflow()
\{
    fprintf(stderr, "stack overflow, re-run program with a larger stack\\n");
    exit(1);
\}

\nwendcode{}\nwbegindocs{12}\nwdocspar
\subsubsection{Choicepoints}
Choicepoints are used for the implementation of non-deterministic
computations. If the computation must proceed non-deterministically,
the current state of the computation is saved in a choicepoint and can
be restored from there in case of backtracking. The information saved
includes a pointer to a null-terminated array of alternative
continuations, the ready queue, the previous choicepoint, and the
current top of the trail. In addition, the heap pointer is saved in
the choicepoint so that all memory allocated since the choicepoint was
created can be released immediately upon backtracking.

A pointer to the current choicepoint is saved in the {\Tt{}bp\nwendquote}
variable.

\nwenddocs{}\nwbegincode{13}\sublabel{NW2SamAc-3EiWCy-4}\nwmargintag{{\nwtagstyle{}\subpageref{NW2SamAc-3EiWCy-4}}}\moddef{stack.h~{\nwtagstyle{}\subpageref{NW2SamAc-3EiWCy-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW2SamAc-3EiWCy-3}{NW2SamAc-3EiWCy-5}\nwenddeflinemarkup
typedef struct choicepoint \{
    Label              *btAlts;         /* remaining alternatives */
    unsigned int       btCid;           /* id of current thread */
    Node               **btDsBase;      /* saved thread stack base */
    struct choicepoint *btBp;           /* previous choicepoint */
    union thread_node  *btRq;           /* saved run queue */
    struct save_rec    *btTp;           /* saved trail pointer */
    struct dict_node   *btDict;         /* saved dictionary tail pointer */
    word               *btHp;           /* saved heap pointer */
\} Choicepoint;

extern Choicepoint *bp;

\nwendcode{}\nwbegindocs{14}\nwdocspar
\nwenddocs{}\nwbegincode{15}\sublabel{NW2SamAc-cUlN6-4}\nwmargintag{{\nwtagstyle{}\subpageref{NW2SamAc-cUlN6-4}}}\moddef{stack.c~{\nwtagstyle{}\subpageref{NW2SamAc-cUlN6-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW2SamAc-cUlN6-3}{NW2SamAc-cUlN6-5}\nwenddeflinemarkup
Choicepoint *bp;

\nwendcode{}\nwbegindocs{16}\nwdocspar
Choicepoints are also used to set up search contexts. A search context
saves the current state of the computation when an encapsulated search
is invoked. The information saved in a search context is similar to
that of a choicepoint, except that no alternative continuations have
to be saved and the field {\Tt{}btAlts\nwendquote} is therefore always set to
{\Tt{}0\nwendquote}.

\nwenddocs{}\nwbegincode{17}\sublabel{NW2SamAc-3EiWCy-5}\nwmargintag{{\nwtagstyle{}\subpageref{NW2SamAc-3EiWCy-5}}}\moddef{stack.h~{\nwtagstyle{}\subpageref{NW2SamAc-3EiWCy-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW2SamAc-3EiWCy-4}{NW2SamAc-3EiWCy-6}\nwenddeflinemarkup
#define is_search_context(cp)   ((cp)->btAlts == (Label *)0)

\nwendcode{}\nwbegindocs{18}\nwdocspar
\subsubsection{Non-deterministic evaluation}
The abstract machine uses the instruction \texttt{Choices} in order
to handle different non-deterministic solutions to a goal. Depending
on the context this instruction has to be handled differently. In
global search mode it will create a choicepoint like for the WAM
(except in monadic code where non-deterministic code is not allowed at
all). However, in a local search space the search is stopped and a
list of search continuations is returned to the caller. The
implementation uses a set of labels to handle these instructions. This
set, which also includes entrypoints to handle deadlocks and failures,
is updated whenever the abstract machine enters or leaves an
encapsulated search. The old pointers are saved as data stack
arguments in a search context frame. The {\Tt{}choices\nwendquote} entry expects a
pointer to a null-terminated array containing all the continuation
addresses in the global variable {\Tt{}choice{\_}conts\nwendquote}.

\nwenddocs{}\nwbegincode{19}\sublabel{NW2SamAc-3EiWCy-6}\nwmargintag{{\nwtagstyle{}\subpageref{NW2SamAc-3EiWCy-6}}}\moddef{stack.h~{\nwtagstyle{}\subpageref{NW2SamAc-3EiWCy-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW2SamAc-3EiWCy-5}{NW2SamAc-3EiWCy-7}\nwenddeflinemarkup
extern Label *choice_conts;

extern struct nondet_handlers \{
    Label choices;
    Label deadlock;
    Label fail;
\} nondet_handlers;

\nwendcode{}\nwbegindocs{20}\nwdocspar
\nwenddocs{}\nwbegincode{21}\sublabel{NW2SamAc-cUlN6-5}\nwmargintag{{\nwtagstyle{}\subpageref{NW2SamAc-cUlN6-5}}}\moddef{stack.c~{\nwtagstyle{}\subpageref{NW2SamAc-cUlN6-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW2SamAc-cUlN6-4}{NW2SamAc-cUlN6-6}\nwenddeflinemarkup
Label *choice_conts;

struct nondet_handlers nondet_handlers;

\nwendcode{}\nwbegindocs{22}\nwdocspar
\subsubsection{Exceptions}
In order to handle I/O exceptions efficiently, the abstract machine
creates an exception frame on the stack when a new exception handler
is installed by the \texttt{catch} function. Each frame saves a
pointer to the current exception handler, which must be a function of
type \texttt{IOError -> IO a}, and the address of the previous
exception frame. The pointer to the current exception frame is saved
in the global variable {\Tt{}efp\nwendquote}.

In general, only the main thread of a program executes an I/O
computation and therefore there will be only one dedicated exception
handler. However, it is possible to run an I/O computation on any
thread -- even within an encapsulated search -- with the help of
\texttt{unsafePerformIO}. Therefore each thread will have its own
exception handler chain. The runtime system will initialize the
variable {\Tt{}efp\nwendquote} to {\Tt{}0\nwendquote} when a new thread is created.

\nwenddocs{}\nwbegincode{23}\sublabel{NW2SamAc-3EiWCy-7}\nwmargintag{{\nwtagstyle{}\subpageref{NW2SamAc-3EiWCy-7}}}\moddef{stack.h~{\nwtagstyle{}\subpageref{NW2SamAc-3EiWCy-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW2SamAc-3EiWCy-6}{\relax}\nwenddeflinemarkup
typedef struct exception_frame
\{
    Node                   *handler;
    struct exception_frame *frame;
\} ExceptionFrame;

extern ExceptionFrame *efp;

\nwendcode{}\nwbegindocs{24}\nwdocspar
\nwenddocs{}\nwbegincode{25}\sublabel{NW2SamAc-cUlN6-6}\nwmargintag{{\nwtagstyle{}\subpageref{NW2SamAc-cUlN6-6}}}\moddef{stack.c~{\nwtagstyle{}\subpageref{NW2SamAc-cUlN6-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW2SamAc-cUlN6-5}{\relax}\nwenddeflinemarkup
ExceptionFrame *efp;
\nwendcode{}

\nwixlogsorted{c}{{stack.c}{NW2SamAc-cUlN6-1}{\nwixd{NW2SamAc-cUlN6-1}\nwixd{NW2SamAc-cUlN6-2}\nwixd{NW2SamAc-cUlN6-3}\nwixd{NW2SamAc-cUlN6-4}\nwixd{NW2SamAc-cUlN6-5}\nwixd{NW2SamAc-cUlN6-6}}}%
\nwixlogsorted{c}{{stack.h}{NW2SamAc-3EiWCy-1}{\nwixd{NW2SamAc-3EiWCy-1}\nwixd{NW2SamAc-3EiWCy-2}\nwixd{NW2SamAc-3EiWCy-3}\nwixd{NW2SamAc-3EiWCy-4}\nwixd{NW2SamAc-3EiWCy-5}\nwixd{NW2SamAc-3EiWCy-6}\nwixd{NW2SamAc-3EiWCy-7}}}%

