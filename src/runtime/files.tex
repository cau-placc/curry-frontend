\nwfilename{files.nw}\nwbegindocs{0}% -*- noweb-code-mode: c-mode -*-% ===> this file was generated automatically by noweave --- better not edit it
% $Id: files.nw,v 2.18 2004/05/01 13:18:15 wlux Exp $
%
% Copyright (c) 2001-2004, Wolfgang Lux
% See ../LICENSE for the full license.
%
\subsection{Files}
The functions in this file implement the primitive monadic actions
that read from and write to files and streams. This module has an
initialization function that initializes the standard channels and
optionally changes the buffer mode for standard input and standard
output. Pass {\Tt{}-1\nwendquote} as first argument to {\Tt{}init{\_}files\nwendquote} in order to
use the default buffer mode.

\nwenddocs{}\nwbegincode{1}\sublabel{NW3MnbPe-4TFljM-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3MnbPe-4TFljM-1}}}\moddef{files.h~{\nwtagstyle{}\subpageref{NW3MnbPe-4TFljM-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
extern void init_files(int, long);

\nwnotused{files.h}\nwendcode{}\nwbegindocs{2}\nwdocspar
\nwenddocs{}\nwbegincode{3}\sublabel{NW3MnbPe-1qkPlQ-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3MnbPe-1qkPlQ-1}}}\moddef{files.c~{\nwtagstyle{}\subpageref{NW3MnbPe-1qkPlQ-1}}}\endmoddef\nwstartdeflinemarkup\nwprevnextdefs{\relax}{NW3MnbPe-1qkPlQ-2}\nwenddeflinemarkup
#include "config.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include "debug.h"
#include "run.h"
#include "heap.h"
#include "stack.h"
#include "threads.h"
#include "spaces.h"
#include "trail.h"
#include "eval.h"
#include "cstring.h"
#include "cam.h"
#include "io_monad.h"
#include "trace.h"

\nwalsodefined{\\{NW3MnbPe-1qkPlQ-2}\\{NW3MnbPe-1qkPlQ-3}\\{NW3MnbPe-1qkPlQ-4}\\{NW3MnbPe-1qkPlQ-5}\\{NW3MnbPe-1qkPlQ-6}\\{NW3MnbPe-1qkPlQ-7}\\{NW3MnbPe-1qkPlQ-8}\\{NW3MnbPe-1qkPlQ-9}\\{NW3MnbPe-1qkPlQ-A}\\{NW3MnbPe-1qkPlQ-B}\\{NW3MnbPe-1qkPlQ-C}\\{NW3MnbPe-1qkPlQ-D}\\{NW3MnbPe-1qkPlQ-E}\\{NW3MnbPe-1qkPlQ-F}\\{NW3MnbPe-1qkPlQ-G}\\{NW3MnbPe-1qkPlQ-H}\\{NW3MnbPe-1qkPlQ-I}\\{NW3MnbPe-1qkPlQ-J}\\{NW3MnbPe-1qkPlQ-K}\\{NW3MnbPe-1qkPlQ-L}\\{NW3MnbPe-1qkPlQ-M}}\nwnotused{files.c}\nwendcode{}\nwbegindocs{4}\nwdocspar
Files are implemented as finalized objects so that a file is
automatically closed when it becomes garbage. A file node comprises
its (C) file pointer, a set of flags, and an optional buffer. At
present, two flag bits are used which are set when the file is
readable and writable, respectively. When a file is closed, both bits
are cleared and the file pointer is set to {\Tt{}0\nwendquote}. The file is in a
semi-closed state when the readable and writable bits are cleared, but
the file pointer is not {\Tt{}0\nwendquote}. This is used for file handles to which
{\Tt{}hGetContents\nwendquote} has been applied. Note that a file can be opened
independently for reading and writing. If the read or write access is
closed, the file can still be used in the other access mode.

\nwenddocs{}\nwbegincode{5}\sublabel{NW3MnbPe-1qkPlQ-2}\nwmargintag{{\nwtagstyle{}\subpageref{NW3MnbPe-1qkPlQ-2}}}\moddef{files.c~{\nwtagstyle{}\subpageref{NW3MnbPe-1qkPlQ-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW3MnbPe-1qkPlQ-1}{NW3MnbPe-1qkPlQ-3}\nwenddeflinemarkup
#define FILE_TAG  ABSTRACT_TAG

enum file_flags \{
    readable,
    writable
\};

#define mask(flag)                      (1<<(flag))
#define set_flag(flags,flag)            (flags |= mask(flag))
#define clear_flag(flags,flag)          (flags &= ~mask(flag))
#define test_flag(flags,flag)           (flags & mask(flag))

#define file_node_size wordsof(struct file_node)
struct file_node \{
    NodeInfo *info;
    FILE     *fp;
    short    flags;
    short    bmode;
    long     bsize;
    char     *buffer;
\};

static void finalize_file(Node *node);
static void close_handle(struct file_node *file);
static void close_readHandle(struct file_node *file);
static void close_writeHandle(struct file_node *file);

static NodeInfo file_info = \{
    FILE_TAG, file_node_size, ot_binary, (Label)eval_whnf, "<<IO.Handle>>",
    finalize_file
\};

static void
finalize_file(Node *file)
\{
    close_handle((struct file_node *)file);
\}

static void
close_handle(struct file_node *file)
\{
    if ( file->fp != (FILE *)0 )
    \{
        fclose(file->fp);
        file->fp    = (FILE *)0;
        file->flags = 0;
        if ( file->buffer != (char *)0 )
            free(file->buffer);
    \}
\}

static void
close_readHandle(struct file_node *file)
\{
    if ( file->flags & mask(writable) )
        file->flags &= ~mask(readable);
    else
        close_handle(file);
\}

static void
close_writeHandle(struct file_node *file)
\{
    if ( file->flags & mask(readable) )
        file->flags &= ~mask(writable);
    else
        close_handle(file);
\}

\nwendcode{}\nwbegindocs{6}\nwdocspar
The functions {\Tt{}stdin\nwendquote}, {\Tt{}stdout\nwendquote}, and {\Tt{}stderr\nwendquote} return predefined
handles for the standard file channels. The nodes are allocated
statically in the runtime system. However, the file pointers of these
nodes cannot be initialized statically because under Linux -- in
constrast to most other operating systems -- the standard file
pointers are not declared as pointers into a static array of file
descriptors, but as global variables.

Note that we assume that the standard error channel is always
unbuffered, whereas the setting of the standard input and output
channels is not known -- unless it is changed in {\Tt{}init{\_}files\nwendquote}.

\nwenddocs{}\nwbegincode{7}\sublabel{NW3MnbPe-1qkPlQ-3}\nwmargintag{{\nwtagstyle{}\subpageref{NW3MnbPe-1qkPlQ-3}}}\moddef{files.c~{\nwtagstyle{}\subpageref{NW3MnbPe-1qkPlQ-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW3MnbPe-1qkPlQ-2}{NW3MnbPe-1qkPlQ-4}\nwenddeflinemarkup
static struct file_node stdin_node = \{
    &file_info, (FILE *)0, mask(readable), -1, 0, (char *)0
\};
static struct file_node stdout_node = \{
    &file_info, (FILE *)0, mask(writable), -1, 0, (char *)0
\};
static struct file_node stderr_node = \{
    &file_info, (FILE *)0, mask(writable), _IONBF, 0, (char *)0
\};


DECLARE_ENTRYPOINT(__stdin);
DECLARE_ENTRYPOINT(__stdout);
DECLARE_ENTRYPOINT(__stderr);

FUNCTION(__stdin)
\{
    EXPORT_LABEL(__stdin)
 ENTRY_LABEL(__stdin)
    RETURN((Node *)&stdin_node);
\}

FUNCTION(__stdout)
\{
    EXPORT_LABEL(__stdout)
 ENTRY_LABEL(__stdout)
    RETURN((Node *)&stdout_node);
\}

FUNCTION(__stderr)
\{
    EXPORT_LABEL(__stderr)
 ENTRY_LABEL(__stderr)
    RETURN((Node *)&stderr_node);
\}

\nwendcode{}\nwbegindocs{8}\nwdocspar
The function {\Tt{}openFile\nwendquote} opens a file with the specified file name
and file mode. Files can be opened for reading, writing, and with
read-write access, respectively. The file access mode is specified
using a constant from the type \texttt{IOMode} that is declared as
follows in the library module \texttt{IO}.
\begin{verbatim}
  data IOMode = ReadMode | WriteMode | AppendMode | ReadWriteMode
\end{verbatim}

\ToDo{\texttt{openFile} should implement the
single-writer/multiple-reader locking semantics mandated by the
Haskell library report.}

\nwenddocs{}\nwbegincode{9}\sublabel{NW3MnbPe-1qkPlQ-4}\nwmargintag{{\nwtagstyle{}\subpageref{NW3MnbPe-1qkPlQ-4}}}\moddef{files.c~{\nwtagstyle{}\subpageref{NW3MnbPe-1qkPlQ-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW3MnbPe-1qkPlQ-3}{NW3MnbPe-1qkPlQ-5}\nwenddeflinemarkup
enum \{
    ReadMode_tag,
    WriteMode_tag,
    AppendMode_tag,
    ReadWriteMode_tag
\};

DECLARE_CONST(__IO__ReadMode);
DECLARE_CONST(__IO__WriteMode);
DECLARE_CONST(__IO__AppendMode);
DECLARE_CONST(__IO__ReadWriteMode);

#define IO_ReadMode      (Node *)&__IO__ReadMode_node
#define IO_WriteMode     (Node *)&__IO__WriteMode_node
#define IO_AppendMode    (Node *)&__IO__AppendMode_node
#define IO_ReadWriteMode (Node *)&__IO__ReadWriteMode_node

DECLARE_ENTRYPOINT(__openFile);
DECLARE_LABEL(__openFile_1);
DECLARE_LABEL(__openFile_2);


FUNCTION(__openFile)
\{
    EXPORT_LABEL(__openFile)
 ENTRY_LABEL(__openFile)
    TRACE(("%I enter openFile%V\\n", 3, sp));
    CHECK_STACK(1);
    sp   -= 1;
    sp[0] = sp[1];
    sp[1] = (Node *)__openFile_1;
    GOTO(nf_string);
\}

static
FUNCTION(__openFile_1)
\{
    Node *fn;
    EXPORT_LABEL(__openFile_1)
 ENTRY_LABEL(__openFile_1)
    fn    = sp[0];
    sp[0] = sp[1];
    sp[1] = fn;
    GOTO(__openFile_2);
\}

static
FUNCTION(__openFile_2)
\{
    const char       *fn, *mode;
    int              flags;
    FILE             *fp;
    struct file_node *file;

 ENTRY_LABEL(__openFile_2)
    /* determine the access mode */
    EVAL_RIGID(__openFile_2);
    switch ( node_tag(sp[0]) )
    \{
    case ReadMode_tag:
        mode  = "r";
        flags = mask(readable);
        break;
    case WriteMode_tag:
        mode  = "w";
        flags = mask(writable);
        break;
    case AppendMode_tag:
        mode  = "a";
        flags = mask(writable);
        break;
    case ReadWriteMode_tag:
        mode  = "r+";
        flags = mask(readable) | mask(writable);
        break;
    default:
        fprintf(stderr, "openFile: invalid mode\\n");
        exit(2);
    \}

    /* open the file */
    fn = to_string(sp[1]);
    fp = fopen(fn, mode);
    free((char *)fn);
    if ( fp == (FILE *)0 )
    \{
        *++sp = from_string(strerror(errno));
        GOTO(__ioError);
    \}
    else
        sp += 3;

    /* create the file node */
    CHECK_HEAP(file_node_size);
    file         = (struct file_node *)hp;
    file->info   = &file_info;
    file->fp     = fp;
    file->flags  = flags;
    file->bmode  = -1;
    file->bsize  = 0;
    file->buffer = (char *)0;
    hp          += file_node_size;
    register_final((Node *)file);

    /* return the file */
    RETURN((Node *)file);
\}

\nwendcode{}\nwbegindocs{10}\nwdocspar
The function {\Tt{}hClose\nwendquote} closes a file handle. Calling {\Tt{}hClose\nwendquote} for a
closed file handle has no effect.

\nwenddocs{}\nwbegincode{11}\sublabel{NW3MnbPe-1qkPlQ-5}\nwmargintag{{\nwtagstyle{}\subpageref{NW3MnbPe-1qkPlQ-5}}}\moddef{files.c~{\nwtagstyle{}\subpageref{NW3MnbPe-1qkPlQ-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW3MnbPe-1qkPlQ-4}{NW3MnbPe-1qkPlQ-6}\nwenddeflinemarkup
DECLARE_ENTRYPOINT(__hClose);

FUNCTION(__hClose)
\{
    struct file_node *file;

    EXPORT_LABEL(__hClose)
 ENTRY_LABEL(__hClose)
    EVAL_RIGID(__hClose);
    file = (struct file_node *)sp[0];
    ASSERT(is_boxed(file) && node_tag(file) == FILE_TAG);
    close_handle(file);

    sp += 2;
    RETURN(unit);
\}

\nwendcode{}\nwbegindocs{12}\nwdocspar
The functions {\Tt{}hIsOpen\nwendquote}, {\Tt{}hIsClosed\nwendquote}, {\Tt{}hIsReadable\nwendquote},
{\Tt{}hIsWritable\nwendquote}, and {\Tt{}hIsSeekable\nwendquote} test whether these properties
apply to a file handle. Note that for a semi-closed handle neither
{\Tt{}hIsOpen\nwendquote} nor {\Tt{}hIsClosed\nwendquote} returns \texttt{True}.

\nwenddocs{}\nwbegincode{13}\sublabel{NW3MnbPe-1qkPlQ-6}\nwmargintag{{\nwtagstyle{}\subpageref{NW3MnbPe-1qkPlQ-6}}}\moddef{files.c~{\nwtagstyle{}\subpageref{NW3MnbPe-1qkPlQ-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW3MnbPe-1qkPlQ-5}{NW3MnbPe-1qkPlQ-7}\nwenddeflinemarkup
DECLARE_CONST(__prelude__False);
DECLARE_CONST(__prelude__True);

#define prelude_False (Node *)&__prelude__False_node
#define prelude_True  (Node *)&__prelude__True_node

DECLARE_ENTRYPOINT(__hIsOpen);
DECLARE_ENTRYPOINT(__hIsClosed);
DECLARE_ENTRYPOINT(__hIsReadable);
DECLARE_ENTRYPOINT(__hIsWritable);
DECLARE_ENTRYPOINT(__hIsSeekable);

FUNCTION(__hIsOpen)
\{
    struct file_node *file;
    Node             *r;

    EXPORT_LABEL(__hIsOpen)
 ENTRY_LABEL(__hIsOpen)
    EVAL_RIGID(__hIsOpen);
    file = (struct file_node *)sp[0];
    ASSERT(is_boxed(file) && node_tag(file) == FILE_TAG);
    sp += 2;

    r = file->flags & (mask(readable) | mask(writable))
        ? prelude_True : prelude_False;
    RETURN(r);
\}

FUNCTION(__hIsClosed)
\{
    struct file_node *file;
    Node             *r;

    EXPORT_LABEL(__hIsClosed)
 ENTRY_LABEL(__hIsClosed)
    EVAL_RIGID(__hIsClosed);
    file = (struct file_node *)sp[0];
    ASSERT(is_boxed(file) && node_tag(file) == FILE_TAG);
    sp += 2;

    r = file->fp == (FILE *)0 ? prelude_True : prelude_False;
    RETURN(r);
\}

FUNCTION(__hIsReadable)
\{
    struct file_node *file;
    Node             *r;

    EXPORT_LABEL(__hIsReadable)
 ENTRY_LABEL(__hIsReadable)
    EVAL_RIGID(__hIsReadable);
    file = (struct file_node *)sp[0];
    ASSERT(is_boxed(file) && node_tag(file) == FILE_TAG);
    sp += 2;

    r = file->flags & mask(readable) ? prelude_True : prelude_False;
    RETURN(r);
\}

FUNCTION(__hIsWritable)
\{
    struct file_node *file;
    Node             *r;

    EXPORT_LABEL(__hIsWritable)
 ENTRY_LABEL(__hIsWritable)
    EVAL_RIGID(__hIsWritable);
    file = (struct file_node *)sp[0];
    ASSERT(is_boxed(file) && node_tag(file) == FILE_TAG);
    sp += 2;

    r = file->flags & mask(writable) ? prelude_True : prelude_False;
    RETURN(r);
\}

FUNCTION(__hIsSeekable)
\{
    struct file_node *file;
    Node             *r;

    EXPORT_LABEL(__hIsSeekable)
 ENTRY_LABEL(__hIsSeekable)
    EVAL_RIGID(__hIsSeekable);
    file = (struct file_node *)sp[0];
    ASSERT(is_boxed(file) && node_tag(file) == FILE_TAG);
    sp += 2;

    if ( !(file->flags & (mask(readable) | mask(writable))) )
        r = prelude_False;
    else if ( ftell(file->fp) != - 1 )
        r = prelude_True;
    else
    \{
        clearerr(file->fp);
        r = prelude_False;
    \}
    RETURN(r);
\}

\nwendcode{}\nwbegindocs{14}\nwdocspar
The functions {\Tt{}isEOF\nwendquote} and {\Tt{}hIsEOF\nwendquote} return whether all of the
specified file has been read, i.e., whether the next call to
{\Tt{}hGetChar\nwendquote} for the handle will raise an end-of-file exception.
{\Tt{}isEOF\nwendquote} is an abbreviation for {\Tt{}hIsEOF\ stdin\nwendquote}.

Note that the semantics of {\Tt{}hIsEOF\nwendquote} is different from the C
semantics. Whereas {\Tt{}hIsEOF\nwendquote} returns {\Tt{}True\nwendquote} after the last
character of the file has been read, the C library sets the
end-of-file condition only after the reading the end-of-file
character. Therefore, our implementation tries to read the next
character from the file and puts it back with {\Tt{}ungetc\nwendquote}. Thus, it may
block the program until the next character is available.

\nwenddocs{}\nwbegincode{15}\sublabel{NW3MnbPe-1qkPlQ-7}\nwmargintag{{\nwtagstyle{}\subpageref{NW3MnbPe-1qkPlQ-7}}}\moddef{files.c~{\nwtagstyle{}\subpageref{NW3MnbPe-1qkPlQ-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW3MnbPe-1qkPlQ-6}{NW3MnbPe-1qkPlQ-8}\nwenddeflinemarkup
DECLARE_ENTRYPOINT(__isEOF);
DECLARE_ENTRYPOINT(__hIsEOF);

FUNCTION(__isEOF)
\{
    EXPORT_LABEL(__isEOF)
 ENTRY_LABEL(__isEOF)
    CHECK_STACK(1);
    sp   -= 1;
    sp[0] = (Node *)&stdin_node;
    GOTO(__hIsEOF);
\}

FUNCTION(__hIsEOF)
\{
    int              c;
    Node             *r;
    struct file_node *file;

    EXPORT_LABEL(__hIsEOF)
 ENTRY_LABEL(__hIsEOF)
    EVAL_RIGID(__hIsEOF);
    file = (struct file_node *)sp[0];
    ASSERT(is_boxed(file) && node_tag(file) == FILE_TAG);

    if ( !(file->flags & mask(readable)) )
    \{
        sp[0] = from_string("hIsEOF: handle not readable");
        GOTO(__ioError);
    \}

    ASSERT(file->fp != (FILE *)0);
    c = getc(file->fp);
    if ( c == EOF && ferror(file->fp) )
    \{
        int err = errno;

        close_readHandle(file);
        sp[0] = from_string(strerror(err));
        GOTO(__ioError);
    \}
    ungetc(c, file->fp);

    sp += 2;
    r   = c == EOF ? prelude_True : prelude_False;
    RETURN(r);
\}

\nwendcode{}\nwbegindocs{16}\nwdocspar
The functions {\Tt{}getChar\nwendquote} and {\Tt{}hGetChar\nwendquote} read a single character
from the specified input handle, with {\Tt{}getChar\nwendquote} being an
abbreviation for {\Tt{}hGetChar\ stdin\nwendquote}. Both functions raise an
end-of-file exception when reading beyond the last character of the
input. An access exception is reported when the handle is not open for
reading. Note that this also happens when the handle is in a
semi-closed state after {\Tt{}hGetContents\nwendquote} has been applied to it.

\nwenddocs{}\nwbegincode{17}\sublabel{NW3MnbPe-1qkPlQ-8}\nwmargintag{{\nwtagstyle{}\subpageref{NW3MnbPe-1qkPlQ-8}}}\moddef{files.c~{\nwtagstyle{}\subpageref{NW3MnbPe-1qkPlQ-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW3MnbPe-1qkPlQ-7}{NW3MnbPe-1qkPlQ-9}\nwenddeflinemarkup
DECLARE_ENTRYPOINT(__getChar);
DECLARE_ENTRYPOINT(__hGetChar);

FUNCTION(__getChar)
\{
    EXPORT_LABEL(__getChar)
 ENTRY_LABEL(__getChar)
    CHECK_STACK(1);
    sp   -= 1;
    sp[0] = (Node *)&stdin_node;
    GOTO(__hGetChar);
\}

FUNCTION(__hGetChar)
\{
    int              c;
    Node             *r;
    struct file_node *file;

    EXPORT_LABEL(__hGetChar)
 ENTRY_LABEL(__hGetChar)
    EVAL_RIGID(__hGetChar);
    file = (struct file_node *)sp[0];
    ASSERT(is_boxed(file) && node_tag(file) == FILE_TAG);

    if ( !(file->flags & mask(readable)) )
    \{
        sp[0] = from_string("hGetChar: handle not readable");
        GOTO(__ioError);
    \}

    ASSERT(file->fp != (FILE *)0);
    c = getc(file->fp);
    if ( c == EOF )
    \{
        boolean eof = feof(file->fp);
        int     err = errno;

        close_readHandle(file);
        sp[0] = from_string(eof ? "End of file" : strerror(err));
        GOTO(__ioError);
    \}

    sp += 2;
    r   = (Node *)(char_table + (c & 0xff));
    RETURN(r);
\}

\nwendcode{}\nwbegindocs{18}\nwdocspar
The function {\Tt{}hLookAhead\nwendquote} returns the next character from the input
file without removing it from the input stream.

\nwenddocs{}\nwbegincode{19}\sublabel{NW3MnbPe-1qkPlQ-9}\nwmargintag{{\nwtagstyle{}\subpageref{NW3MnbPe-1qkPlQ-9}}}\moddef{files.c~{\nwtagstyle{}\subpageref{NW3MnbPe-1qkPlQ-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW3MnbPe-1qkPlQ-8}{NW3MnbPe-1qkPlQ-A}\nwenddeflinemarkup
DECLARE_ENTRYPOINT(__hLookAhead);

FUNCTION(__hLookAhead)
\{
    int              c;
    Node             *r;
    struct file_node *file;

    EXPORT_LABEL(__hLookAhead)
 ENTRY_LABEL(__hLookAhead)
    EVAL_RIGID(__hLookAhead);
    file = (struct file_node *)sp[0];
    ASSERT(is_boxed(file) && node_tag(file) == FILE_TAG);

    if ( !(file->flags & mask(readable)) )
    \{
        sp[0] = from_string("hLookAhead: handle not readable");
        GOTO(__ioError);
    \}

    ASSERT(file->fp != (FILE *)0);
    c = getc(file->fp);
    if ( c == EOF )
    \{
        boolean eof = feof(file->fp);
        int     err = errno;

        if ( !eof )
            close_readHandle(file);
        sp[0] = from_string(eof ? "End of file" : strerror(err));
        GOTO(__ioError);
    \}
    ungetc(c, file->fp);

    sp += 2;
    r   = (Node *)(char_table + (c & 0xff));
    RETURN(r);
\}

\nwendcode{}\nwbegindocs{20}\nwdocspar
The functions {\Tt{}getLine\nwendquote} and {\Tt{}hGetLine\nwendquote} read a single line from the
specified handle, with {\Tt{}getLine\nwendquote} being an abbreviation for
{\Tt{}hGetLine\ stdin\nwendquote}. We implement these functions in the runtime system
instead of defining them in terms of {\Tt{}hIsEOF\nwendquote} and {\Tt{}hGetChar\nwendquote}
because this makes possible a more efficient implementation using
the {\Tt{}fgets\nwendquote} function. Note that {\Tt{}fgets\nwendquote} retains a newline
character in the input buffer; we have to remove it before converting
the string. If no newline has been read, we continue to read more
characters from the standard input until reaching either the
end-of-file or reading a newline character.

Concatenation of the line segments is a little bit tricky. We do not
use the \texttt{(++)} operator from the prelude in order to avoid the
quadratic complexity introduced by this operator when the string is
constructed from left to right. Instead we use an indirection node at
the end of each segment and set its pointer after reading the line
segment. Note that this destructive update does not have to be trailed
because {\Tt{}hGetLine\nwendquote} is an atomic action with respect to the Curry
runtime system.

\nwenddocs{}\nwbegincode{21}\sublabel{NW3MnbPe-1qkPlQ-A}\nwmargintag{{\nwtagstyle{}\subpageref{NW3MnbPe-1qkPlQ-A}}}\moddef{files.c~{\nwtagstyle{}\subpageref{NW3MnbPe-1qkPlQ-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW3MnbPe-1qkPlQ-9}{NW3MnbPe-1qkPlQ-B}\nwenddeflinemarkup
DECLARE_ENTRYPOINT(__getLine);
DECLARE_ENTRYPOINT(__hGetLine);

FUNCTION(__getLine)
\{
    EXPORT_LABEL(__getLine)
 ENTRY_LABEL(__getLine)
    CHECK_STACK(1);
    sp   -= 1;
    sp[0] = (Node *)&stdin_node;
    GOTO(__hGetLine);
\}

FUNCTION(__hGetLine)
\{
    char buf[256], *cp;
    Node *line, *tail;
    FILE *fp;

    EXPORT_LABEL(__hGetLine)
 ENTRY_LABEL(__hGetLine)
    EVAL_RIGID(__hGetLine);
    ASSERT(is_boxed(sp[0]) && node_tag(sp[0]) == FILE_TAG);

    if ( !(((struct file_node *)sp[0])->flags & mask(readable)) )
    \{
        sp[0] = from_string("hGetLine: handle not readable");
        GOTO(__ioError);
    \}

    fp = ((struct file_node *)sp[0])->fp;
    ASSERT(fp != (FILE *)0);
    if ( fgets(buf, 256, fp) == (char *)0 )
    \{
        boolean eof = feof(fp);
        int     err = errno;

        close_readHandle((struct file_node *)sp[0]);
        sp[0] = from_string(eof ? "End of file" : strerror(err));
        GOTO(__ioError);
    \}

    CHECK_STACK(2);
    sp   -= 2;
    sp[0] = sp[1] = (Node *)0;
    sp[3] = nil;

    do
    \{
        for ( cp = buf; *cp != '\\n' && *cp != '\\0'; cp++ )
            ;

        if ( *cp == '\\n' )
        \{
            *cp  = '\\0';
            tail = nil;
        \}
        else
        \{
            CHECK_HEAP(indir_node_size);
            tail         = (Node *)hp;
            tail->n.info = &indir_info;
            tail->n.node = nil;
            hp          += indir_node_size;
        \}

        sp[0] = tail;
        line  = prefix_string(buf, tail);
        if ( sp[3] == nil )
            sp[3] = line;
        else
            sp[1]->n.node = line;
        sp[1] = sp[0];
    \} while ( sp[1] != nil && fgets(buf, 256, fp) != (char *)0 );

    if ( sp[1] != nil )
        close_readHandle((struct file_node *)sp[2]);

    line = sp[3];
    sp  += 4;
    RETURN(line);
\}

\nwendcode{}\nwbegindocs{22}\nwdocspar
The functions {\Tt{}getContents\nwendquote} and {\Tt{}hGetContents\nwendquote} return the contents
of the specified file as a lazy stream, where {\Tt{}getContents\nwendquote} is an
abbreviation for {\Tt{}hGetContents\ stdin\nwendquote}. The handle is put into a
semi-closed state by removing the {\Tt{}readable\nwendquote} bit from the flags. The
character stream is constructed on demand with the help of the
{\Tt{}lazyRead\nwendquote} function.

The function {\Tt{}readFile\nwendquote} is just wrapper function that combines
{\Tt{}openFile\nwendquote} and {\Tt{}hGetContents\nwendquote}. We define it here so that the type
{\Tt{}IOMode\nwendquote} need not be defined in the prelude.

\nwenddocs{}\nwbegincode{23}\sublabel{NW3MnbPe-1qkPlQ-B}\nwmargintag{{\nwtagstyle{}\subpageref{NW3MnbPe-1qkPlQ-B}}}\moddef{files.c~{\nwtagstyle{}\subpageref{NW3MnbPe-1qkPlQ-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW3MnbPe-1qkPlQ-A}{NW3MnbPe-1qkPlQ-C}\nwenddeflinemarkup
DECLARE_ENTRYPOINT(__readFile);
DECLARE_ENTRYPOINT(__getContents);
DECLARE_ENTRYPOINT(__hGetContents);
DECLARE_LABEL(lazyRead);
DECLARE_LABEL(lazyRead_eval);
DECLARE_LABEL(lazyRead_lazy);

static FunctionInfo lazyRead_info         = FUNINFO("lazyRead", lazyRead, 2);
static NodeInfo     lazyRead_suspend_info = SUSPINFO(lazyRead);

FUNCTION(__readFile)
\{
    Node *fn, *world;

    EXPORT_LABEL(__readFile)
 ENTRY_LABEL(__readFile)
    fn    = sp[0];
    world = sp[1];

    CHECK_STACK(3);
    sp   -= 3;
    sp[0] = fn;
    sp[1] = IO_ReadMode;
    sp[2] = world;
    sp[3] = (Node *)__hGetContents;
    GOTO(__openFile);
\}

FUNCTION(__getContents)
\{
    EXPORT_LABEL(__getContents)
 ENTRY_LABEL(__getContents)
    CHECK_STACK(1);
    sp   -= 1;
    sp[0] = (Node *)&stdin_node;
    GOTO(__hGetContents);
\}

FUNCTION(__hGetContents)
\{
    Node                *clos, *susp;
    struct file_node    *file;

    EXPORT_LABEL(__hGetContents)
 ENTRY_LABEL(__hGetContents)
    EVAL_RIGID(__hGetContents);
    file = (struct file_node *)sp[0];
    ASSERT(is_boxed(file) && node_tag(file) == FILE_TAG);

    if ( !(file->flags & mask(readable)) )
    \{
        sp[0] = from_string("hGetContents: handle not readable");
        GOTO(__ioError);
    \}

    /* put the file into a semi-closed state */
    file->flags &= ~mask(readable);

    /* construct the (lazy) input stream */
    CHECK_HEAP(closure_node_size(2) + suspend_node_size);
    clos             = (Node *)hp;
    clos->cl.info    = &lazyRead_info;
    clos->cl.args[0] = (Node *)hp;
    clos->cl.args[1] = sp[0];
    hp              += closure_node_size(2);

    susp         = (Node *)hp;
    susp->s.info = &lazyRead_suspend_info;
    susp->s.fn   = clos;
    susp->s.spc  = (SearchSpace *)0;
    hp          += suspend_node_size;

    sp += 2;
    RETURN(susp);
\}

static
FUNCTION(lazyRead_eval)
\{
    Node *clos;
 ENTRY_LABEL(lazyRead_eval)
    CHECK_STACK1();
    clos  = sp[0];
    sp   -= 1;
    sp[0] = clos->cl.args[0];
    sp[1] = clos->cl.args[1];
    GOTO(lazyRead);
\}

static
FUNCTION(lazyRead_lazy)
\{
    Node *susp, *clos;
 ENTRY_LABEL(lazyRead_lazy)
    susp = sp[0];

    /* suspend the search if the node is not local */
    if ( !is_local_space(susp->s.spc) )
        GOTO(suspend_thread(resume, susp));

    /* lock the suspension */
    clos = susp->s.fn;
    SAVE(susp, q.wq);
    susp->info = &queueMe_info;
    susp->q.wq = (ThreadQueue)0;

    /* create an update frame */
    CHECK_STACK(3);
    sp   -= 3;
    sp[0] = clos->cl.args[0];
    sp[1] = clos->cl.args[1];
    sp[2] = (Node *)update;

    /* enter the callee */
    GOTO(lazyRead);
\}

static
FUNCTION(lazyRead)
\{
    int              c;
    Node             *list, *tail;
    struct file_node *file;

 ENTRY_LABEL(lazyRead)
    file = (struct file_node *)sp[1];
    if ( file->fp == (FILE *)0 )
        list = nil;
    else
    \{
        c = fgetc(file->fp);
        if ( c == EOF )
        \{
            close_readHandle(file);
            list = nil;
        \}
        else
        \{
            CHECK_HEAP(suspend_node_size + cons_node_size);

            tail         = (Node *)hp;
            tail->s.info = &lazyRead_suspend_info;
            tail->s.fn   = sp[0];
            tail->s.spc  = (SearchSpace *)0;
            hp          += suspend_node_size;

            list            = (Node *)hp;
            list->c.info    = &cons_info;
            list->c.args[0] = (Node *)(char_table + (c & 0xff));
            list->c.args[1] = tail;
            hp             += cons_node_size;
        \}
    \}

    sp += 2;
    RETURN(list);
\}

\nwendcode{}\nwbegindocs{24}\nwdocspar
The functions {\Tt{}putChar\nwendquote} and {\Tt{}hPutChar\nwendquote} write a single character to
the specified handle, where {\Tt{}putChar\nwendquote} is an abbreviation for
{\Tt{}hPutChar\ stdout\nwendquote}.

\nwenddocs{}\nwbegincode{25}\sublabel{NW3MnbPe-1qkPlQ-C}\nwmargintag{{\nwtagstyle{}\subpageref{NW3MnbPe-1qkPlQ-C}}}\moddef{files.c~{\nwtagstyle{}\subpageref{NW3MnbPe-1qkPlQ-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW3MnbPe-1qkPlQ-B}{NW3MnbPe-1qkPlQ-D}\nwenddeflinemarkup
DECLARE_ENTRYPOINT(__putChar);
DECLARE_ENTRYPOINT(__hPutChar);
DECLARE_LABEL(__hPutChar_1);

FUNCTION(__putChar)
\{
    EXPORT_LABEL(__putChar)
 ENTRY_LABEL(__putChar)
    CHECK_STACK(1);
    sp   -= 1;
    sp[0] = sp[1];
    sp[1] = (Node *)&stdout_node;
    GOTO(__hPutChar_1);
\}

FUNCTION(__hPutChar)
\{
    Node *file;

    EXPORT_LABEL(__hPutChar)
 ENTRY_LABEL(__hPutChar)
    EVAL_RIGID(__hPutChar);
    file  = sp[0];
    sp[0] = sp[1];
    sp[1] = file;
    GOTO(__hPutChar_1);
\}

static
FUNCTION(__hPutChar_1)
\{
    struct file_node *file;
 ENTRY_LABEL(__hPutChar_1)
    EVAL_RIGID_CHAR(__hPutChar_1);

    file = (struct file_node *)sp[1];
    ASSERT(is_boxed(file) && node_tag(file) == FILE_TAG);

    if ( !(file->flags & mask(writable)) )
    \{
        *++sp = from_string("hPutChar: handle not writable");
        GOTO(__ioError);
    \}

    ASSERT(file->fp != (FILE *)0);
    if ( putc(sp[0]->ch.ch, file->fp) == EOF )
    \{
        int err = errno;

        close_writeHandle(file);
        *++sp = from_string(strerror(err));
        GOTO(__ioError);
    \}

    sp += 3;
    RETURN(unit);
\}

\nwendcode{}\nwbegindocs{26}\nwdocspar
The functions {\Tt{}putStr\nwendquote} and {\Tt{}hPutStr\nwendquote} write a string to a file
handle, with {\Tt{}putStr\nwendquote} being an abbreviation for {\Tt{}hPutStr\ stdout\nwendquote}.

\nwenddocs{}\nwbegincode{27}\sublabel{NW3MnbPe-1qkPlQ-D}\nwmargintag{{\nwtagstyle{}\subpageref{NW3MnbPe-1qkPlQ-D}}}\moddef{files.c~{\nwtagstyle{}\subpageref{NW3MnbPe-1qkPlQ-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW3MnbPe-1qkPlQ-C}{NW3MnbPe-1qkPlQ-E}\nwenddeflinemarkup
DECLARE_ENTRYPOINT(__putStr);
DECLARE_ENTRYPOINT(__hPutStr);
DECLARE_LABEL(__hPutStr_1);
DECLARE_LABEL(__hPutStr_2);

FUNCTION(__putStr)
\{
    EXPORT_LABEL(__putStr)
 ENTRY_LABEL(__putStr)
    CHECK_STACK(1);
    sp   -= 1;
    sp[0] = sp[1];
    sp[1] = (Node *)&stdout_node;
    GOTO(__hPutStr_1);
\}

FUNCTION(__hPutStr)
\{
    Node *file;

    EXPORT_LABEL(__hPutStr)
 ENTRY_LABEL(__hPutStr)
    EVAL_RIGID(__hPutStr);
    file = sp[0];
    ASSERT(is_boxed(file) && node_tag(file) == FILE_TAG);

    if ( !(((struct file_node *)file)->flags & mask(writable)) )
    \{
        *++sp = from_string("hPutStr: handle not writable");
        GOTO(__ioError);
    \}

    sp[0] = sp[1];
    sp[1] = file;
    GOTO(__hPutStr_1);
\}

static
FUNCTION(__hPutStr_1)
\{
    Node *list;
 ENTRY_LABEL(__hPutStr_1)
    EVAL_RIGID(__hPutStr_1);
    list = sp[0];
    switch ( node_tag(list) )
    \{
    case NIL_TAG:
        sp += 3;
        RETURN(unit);
    case CONS_TAG:
        CHECK_STACK1();
        sp   -= 1;
        sp[0] = list->c.args[0];
        sp[1] = list->c.args[1];
        GOTO(__hPutStr_2);
    default:
        break;
    \}
    fprintf(stderr, "hPutStr: invalid argument\\n");
    exit(2);
\}

static
FUNCTION(__hPutStr_2)
\{
    struct file_node *file;
 ENTRY_LABEL(__hPutStr_2)
    EVAL_RIGID_CHAR(__hPutStr_2);

    file = (struct file_node *)sp[2];
    if ( fputc(sp[0]->ch.ch, file->fp) == EOF )
    \{
        int err = errno;

        close_writeHandle(file);
        sp   += 2;
        sp[0] = from_string(strerror(err));
        GOTO(__ioError);
    \}

    sp += 1;
    GOTO(__hPutStr_1);
\}

\nwendcode{}\nwbegindocs{28}\nwdocspar
The functions {\Tt{}writeFile\nwendquote} and {\Tt{}appendFile\nwendquote} write a string to a
file. The current contents of the file is replaced by the string
when using {\Tt{}writeFile\nwendquote}. When {\Tt{}appendFile\nwendquote} is used, the string is
appended to the end of the file. Both functions create the file if it
does not exist.

The functions make use of an auxiliary function {\Tt{}hPutContents\nwendquote} that
calls {\Tt{}hPutStr\nwendquote} and then closes the file handle.

\nwenddocs{}\nwbegincode{29}\sublabel{NW3MnbPe-1qkPlQ-E}\nwmargintag{{\nwtagstyle{}\subpageref{NW3MnbPe-1qkPlQ-E}}}\moddef{files.c~{\nwtagstyle{}\subpageref{NW3MnbPe-1qkPlQ-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW3MnbPe-1qkPlQ-D}{NW3MnbPe-1qkPlQ-F}\nwenddeflinemarkup
DECLARE_ENTRYPOINT(__writeFile);
DECLARE_ENTRYPOINT(__appendFile);
DECLARE_ENTRYPOINT(__hPutContents);
DECLARE_LABEL(__hPutContents_1);

FUNCTION(__writeFile)
\{
    Node *fn, *world;

    EXPORT_LABEL(__writeFile)
 ENTRY_LABEL(__writeFile)
    fn    = sp[0];
    world = sp[2];

    CHECK_STACK(3);
    sp   -= 3;
    sp[0] = fn;
    sp[1] = IO_WriteMode;
    sp[2] = world;
    sp[3] = (Node *)__hPutContents;
    GOTO(__openFile);
\}

FUNCTION(__appendFile)
\{
    Node *fn, *world;

    EXPORT_LABEL(__appendFile)
 ENTRY_LABEL(__appendFile)
    fn    = sp[0];
    world = sp[2];

    CHECK_STACK(3);
    sp   -= 3;
    sp[0] = fn;
    sp[1] = IO_AppendMode;
    sp[2] = world;
    sp[3] = (Node *)__hPutContents;
    GOTO(__openFile);
\}

FUNCTION(__hPutContents)
\{
    Node *file, *str, *world;

    EXPORT_LABEL(__hPutContents)
 ENTRY_LABEL(__hPutContents)
    file  = sp[0];
    str   = sp[1];
    world = sp[2];

    CHECK_STACK(3);
    sp   -= 3;
    sp[0] = file;
    sp[1] = str;
    sp[2] = world;
    sp[3] = (Node *)__hPutContents_1;
    sp[4] = file;
    GOTO(__hPutStr);
\}

static
FUNCTION(__hPutContents_1)
\{
 ENTRY_LABEL(__hPutContents_1)
    sp += 1;
    GOTO(__hClose);
\}

\nwendcode{}\nwbegindocs{30}\nwdocspar
The function {\Tt{}hFileSize\nwendquote} returns the size of a file in bytes,
provided that the file is seekable.

\nwenddocs{}\nwbegincode{31}\sublabel{NW3MnbPe-1qkPlQ-F}\nwmargintag{{\nwtagstyle{}\subpageref{NW3MnbPe-1qkPlQ-F}}}\moddef{files.c~{\nwtagstyle{}\subpageref{NW3MnbPe-1qkPlQ-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW3MnbPe-1qkPlQ-E}{NW3MnbPe-1qkPlQ-G}\nwenddeflinemarkup
DECLARE_ENTRYPOINT(__hFileSize);

FUNCTION(__hFileSize)
\{
    long             curpos, endpos;
    Node             *r;
    struct file_node *file;

    EXPORT_LABEL(__hFileSize)
 ENTRY_LABEL(__hFileSize)
    EVAL_RIGID(__hFileSize);
    file = (struct file_node *)sp[0];
    ASSERT(is_boxed(file) && node_tag(file) == FILE_TAG);

    if ( !(file->flags & (mask(readable) | mask(writable))) )
    \{
        sp[0] = from_string("hFileSize: handle not open");
        GOTO(__ioError);
    \}

    ASSERT(file->fp != (FILE *)0);
    curpos = ftell(file->fp);
    if ( curpos == -1 || fseek(file->fp, 0, SEEK_END) == -1 )
    \{
        sp[0] = from_string(strerror(errno));
        GOTO(__ioError);
    \}

    endpos = ftell(file->fp);
    if ( endpos == -1 || fseek(file->fp, curpos, SEEK_SET) == -1 )
    \{
        sp[0] = from_string(strerror(errno));
        GOTO(__ioError);
    \}

    sp += 2;
#if ONLY_BOXED_OBJECTS
    CHECK_HEAP(int_node_size);
    r       = (Node *)hp;
    r->info = &int_info;
    r->i.i  = endpos;
    hp     += int_node_size;
#else
    r = mk_int(endpos);
#endif
    RETURN(r);
\}

\nwendcode{}\nwbegindocs{32}\nwdocspar
The function {\Tt{}hIsTerminalDevice\nwendquote} returns {\Tt{}True\nwendquote} if the specified
handle is connected to a terminal and {\Tt{}False\nwendquote} otherwise. We use the
{\Tt{}isatty\nwendquote} function for testing this property.

\nwenddocs{}\nwbegincode{33}\sublabel{NW3MnbPe-1qkPlQ-G}\nwmargintag{{\nwtagstyle{}\subpageref{NW3MnbPe-1qkPlQ-G}}}\moddef{files.c~{\nwtagstyle{}\subpageref{NW3MnbPe-1qkPlQ-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW3MnbPe-1qkPlQ-F}{NW3MnbPe-1qkPlQ-H}\nwenddeflinemarkup
DECLARE_ENTRYPOINT(__hIsTerminalDevice);

FUNCTION(__hIsTerminalDevice)
\{
    Node             *r;
    struct file_node *file;

    EXPORT_LABEL(__hIsTerminalDevice)
 ENTRY_LABEL(__hIsTerminalDevice)
    EVAL_RIGID(__hIsTerminalDevice);
    file = (struct file_node *)sp[0];
    ASSERT(is_boxed(file) && node_tag(file) == FILE_TAG);

    if ( !(file->flags & (mask(readable) | mask(writable))) )
    \{
        sp[0] = from_string("hIsTerminalDevice: handle not open");
        GOTO(__ioError);
    \}
    ASSERT(file->fp != (FILE *)0);

    sp += 2;
    r   = isatty(fileno(file->fp)) ? prelude_True : prelude_False;
    RETURN(r);
\}

\nwendcode{}\nwbegindocs{34}\nwdocspar
The function {\Tt{}hGetBuffering\nwendquote} returns the buffering mode used for the
given file handle. Unfortunately, there is no portable way to
determine the buffering mode used for a file handle. Therefore, the
mode is saved in the file structure when {\Tt{}hSetBuffering\nwendquote} is called
(see below). The initial buffering mode is determined by checking
whether the file is connected to a terminal or to a file. In the
former case we assume that line buffering is used, otherwise block
buffering is assumed.

The buffer mode is returned as an instance of the type
\texttt{BufferMode} declared in module \texttt{IO} as follows.
\begin{verbatim}
  data BufferMode = NoBuffering | LineBuffering | BlockBuffering (Maybe Int)
\end{verbatim}

\nwenddocs{}\nwbegincode{35}\sublabel{NW3MnbPe-1qkPlQ-H}\nwmargintag{{\nwtagstyle{}\subpageref{NW3MnbPe-1qkPlQ-H}}}\moddef{files.c~{\nwtagstyle{}\subpageref{NW3MnbPe-1qkPlQ-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW3MnbPe-1qkPlQ-G}{NW3MnbPe-1qkPlQ-I}\nwenddeflinemarkup
enum \{ Nothing_tag, Just_tag \};
DECLARE_CONST(__prelude__Nothing);
DECLARE_DATA(__prelude__Just);

enum \{ NoBuffering_tag, LineBuffering_tag, BlockBuffering_tag \};
DECLARE_CONST(__IO__NoBuffering);
DECLARE_CONST(__IO__LineBuffering);
DECLARE_DATA(__IO__BlockBuffering);

DECLARE_ENTRYPOINT(__hGetBuffering); 

FUNCTION(__hGetBuffering)
\{
    short            bmode;
    long             bsize;
    Node             *size, *r;
    struct file_node *file;

    EXPORT_LABEL(__hGetBuffering)
 ENTRY_LABEL(__hGetBuffering)
    EVAL_RIGID(__hGetBuffering);
    file = (struct file_node *)sp[0];
    ASSERT(is_boxed(file) && node_tag(file) == FILE_TAG);

    if ( !(file->flags & (mask(readable) | mask(writable))) )
    \{
        sp[0] = from_string("hGetBuffering: handle not open");
        GOTO(__ioError);
    \}

    ASSERT(file->fp != (FILE *)0);
    sp += 2;
    for (;;)
    \{
        bmode = file->bmode;
        bsize = file->bsize;
        switch ( bmode )
        \{
        case -1:
            file->bmode = isatty(fileno(file->fp)) ? _IOLBF : _IOFBF;
            continue;
        case _IONBF:
            r = (Node *)&__IO__NoBuffering_node;
            break;
        case _IOLBF:
            r = (Node *)&__IO__LineBuffering_node;
            break;
        case _IOFBF:
            CHECK_HEAP(int_node_size + 2 * constr_node_size(1));
            if ( bsize != 0 )
            \{
 #if ONLY_BOXED_OBJECTS
                r       = (Node *)hp;
                r->info = &int_info;
                r->i.i  = bsize;
                hp     += int_node_size;
#else
                r = mk_int(bsize);
#endif
                size            = (Node *)hp;
                size->info      = &__prelude__Just_info;
                size->c.args[0] = r;
                hp             += constr_node_size(1);
            \}
            else
                size = (Node *)&__prelude__Nothing_node;

            r            = (Node *)hp;
            r->info      = &__IO__BlockBuffering_info;
            r->c.args[0] = size;
            hp          += constr_node_size(1);
            break;
        default:
            fprintf(stderr, "hGetBuffering: invalid buffer mode %d\\n", bmode);
            exit(2);
        \}
        break;
    \}

    RETURN(r);
\}

\nwendcode{}\nwbegindocs{36}\nwdocspar
The function {\Tt{}hSetBuffering\nwendquote} changes the current buffering mode of a
file handle.

\nwenddocs{}\nwbegincode{37}\sublabel{NW3MnbPe-1qkPlQ-I}\nwmargintag{{\nwtagstyle{}\subpageref{NW3MnbPe-1qkPlQ-I}}}\moddef{files.c~{\nwtagstyle{}\subpageref{NW3MnbPe-1qkPlQ-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW3MnbPe-1qkPlQ-H}{NW3MnbPe-1qkPlQ-J}\nwenddeflinemarkup
DECLARE_ENTRYPOINT(__hSetBuffering);
DECLARE_LABEL(__hSetBuffering_1);
DECLARE_LABEL(__hSetBuffering_2);
DECLARE_LABEL(__hSetBuffering_3);

FUNCTION(__hSetBuffering)
\{
    Node *file;
    EXPORT_LABEL(__hSetBuffering)
 ENTRY_LABEL(__hSetBuffering)
    EVAL_RIGID(__hSetBuffering);
    file  = sp[0];
    sp[0] = sp[1];
    sp[1] = file;
    GOTO(__hSetBuffering_1);
\}

static
FUNCTION(__hSetBuffering_1)
\{
    short            bmode;
    struct file_node *file;
 ENTRY_LABEL(__hSetBuffering_1)
    EVAL_RIGID(__hSetBuffering_1);
    switch ( node_tag(sp[0]) )
    \{
    case NoBuffering_tag:
        bmode = _IONBF;
        break;
    case LineBuffering_tag:
        bmode = _IOLBF;
        break;
    case BlockBuffering_tag:
        sp[0] = sp[0]->c.args[0];
        GOTO(__hSetBuffering_2);
    default:
        fprintf(stderr, "hSetBuffering: invalid mode\\n");
        exit(2);
    \}

    file = (struct file_node *)sp[1];
    ASSERT(is_boxed(file) && node_tag(file) == FILE_TAG);
    if ( !(file->flags & (mask(readable) | mask(writable))) )
    \{
        *++sp = from_string("hSetBuffering: handle not open");
        GOTO(__ioError);
    \}

    ASSERT(file->fp != (FILE *)0);
    if ( setvbuf(file->fp, (char *)0, bmode, 0) == -1 )
    \{
        *++sp = from_string(strerror(errno));
        GOTO(__ioError);
    \}
    file->bmode = bmode;
    file->bsize = 0;
    if ( file->buffer != (char *)0 )
        free(file->buffer);
    file->buffer = (char *)0;

    sp += 3;
    RETURN(unit);
\}

static
FUNCTION(__hSetBuffering_2)
\{
    struct file_node *file;
 ENTRY_LABEL(__hSetBuffering_2)
    EVAL_RIGID(__hSetBuffering_2);
    switch ( node_tag(sp[0]) )
    \{
    case Nothing_tag:
        break;
    case Just_tag:
        sp[0] = sp[0]->c.args[0];
        GOTO(__hSetBuffering_3);
    default:
        fprintf(stderr, "hSetBuffering: invalid mode\\n");
        exit(2);
    \}

    file = (struct file_node *)sp[1];
    ASSERT(is_boxed(file) && node_tag(file) == FILE_TAG);
    if ( !(file->flags & (mask(readable) | mask(writable))) )
    \{
        *++sp = from_string("hSetBuffering: handle not open");
        GOTO(__ioError);
    \}

    ASSERT(file->fp != (FILE *)0);
    if ( setvbuf(file->fp, (char *)0, _IOFBF, 0) == -1 )
    \{
        *++sp = from_string(strerror(errno));
        GOTO(__ioError);
    \}
    file->bmode = _IOFBF;
    file->bsize = 0;
    if ( file->buffer != (char *)0 )
        free(file->buffer);
    file->buffer = (char *)0;

    sp += 3;
    RETURN(unit);
\}

static
FUNCTION(__hSetBuffering_3)
\{
    long             bsize;
    char             *buffer;
    struct file_node *file;
 ENTRY_LABEL(__hSetBuffering_3)
    EVAL_RIGID_INT(__hSetBuffering_3);
    file  = (struct file_node *)sp[1];
    ASSERT(is_boxed(file) && node_tag(file) == FILE_TAG);
    if ( !(file->flags & (mask(readable) | mask(writable))) )
    \{
        *++sp = from_string("hSetBuffering: handle not open");
        GOTO(__ioError);
    \}

    bsize = int_val(sp[0]);
    if ( bsize > 0 )
    \{
        buffer = (char *)malloc(bsize);
        if ( buffer == (char *)0 )
        \{
            fprintf(stderr, "hSetBuffering: memory exhausted\\n");
            exit(1);
        \}
    \}
    else
        buffer = (char *)0;

    ASSERT(file->fp != (FILE *)0);
    if ( setvbuf(file->fp, buffer, _IOFBF, bsize) == -1 )
    \{
        *++sp = from_string(strerror(errno));
        free(buffer);
        GOTO(__ioError);
    \}
    file->bmode = _IOFBF;
    file->bsize = bsize;
    if ( file->buffer != (char *)0 )
        free(file->buffer);
    file->buffer = buffer;

    sp += 3;
    RETURN(unit);
\}

\nwendcode{}\nwbegindocs{38}\nwdocspar
The function {\Tt{}hFlush\nwendquote} flushes the output buffer associated with
the specified handle.

\nwenddocs{}\nwbegincode{39}\sublabel{NW3MnbPe-1qkPlQ-J}\nwmargintag{{\nwtagstyle{}\subpageref{NW3MnbPe-1qkPlQ-J}}}\moddef{files.c~{\nwtagstyle{}\subpageref{NW3MnbPe-1qkPlQ-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW3MnbPe-1qkPlQ-I}{NW3MnbPe-1qkPlQ-K}\nwenddeflinemarkup
DECLARE_ENTRYPOINT(__hFlush);

FUNCTION(__hFlush)
\{
    struct file_node *file;

    EXPORT_LABEL(__hFlush)
 ENTRY_LABEL(__hFlush)
    EVAL_RIGID(__hFlush);
    file = (struct file_node *)sp[0];
    ASSERT(is_boxed(file) && node_tag(file) == FILE_TAG);

    if ( !(file->flags & mask(writable)) )
    \{
        sp[0] = from_string("hFlush: handle not writable");
        GOTO(__ioError);
    \}

    ASSERT(file->fp != (FILE *)0);
    if ( fflush(file->fp) == -1 )
    \{
        sp[0] = from_string(strerror(errno));
        GOTO(__ioError);
    \}

    sp += 2;
    RETURN(unit);
\}

\nwendcode{}\nwbegindocs{40}\nwdocspar
The function {\Tt{}hTell\nwendquote} returns the current I/O position of the file
associated with the specified handle.

\nwenddocs{}\nwbegincode{41}\sublabel{NW3MnbPe-1qkPlQ-K}\nwmargintag{{\nwtagstyle{}\subpageref{NW3MnbPe-1qkPlQ-K}}}\moddef{files.c~{\nwtagstyle{}\subpageref{NW3MnbPe-1qkPlQ-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW3MnbPe-1qkPlQ-J}{NW3MnbPe-1qkPlQ-L}\nwenddeflinemarkup
DECLARE_ENTRYPOINT(__hTell); 

FUNCTION(__hTell)
\{
    long             curpos;
    Node             *r;
    struct file_node *file;
    EXPORT_LABEL(__hTell)
 ENTRY_LABEL(__hTell)
    EVAL_RIGID(__hTell);
    file = (struct file_node *)sp[0];
    ASSERT(is_boxed(file) && node_tag(file) == FILE_TAG);

    if ( !(file->flags & (mask(readable) | mask(writable))) )
    \{
        sp[0] = from_string("hTell: handle not open");
        GOTO(__ioError);
    \}

    ASSERT(file->fp != (FILE *)0);
    curpos = ftell(file->fp);
    if ( curpos == -1 )
    \{
        sp[0] = from_string(strerror(errno));
        GOTO(__ioError);
    \}

    sp += 2;
#if ONLY_BOXED_OBJECTS
    CHECK_HEAP(int_node_size);
    r       = (Node *)hp;
    r->info = &int_info;
    r->i.i  = curpos;
    hp     += int_node_size;
#else
    r = mk_int(curpos);
#endif
    RETURN(r);
\}

\nwendcode{}\nwbegindocs{42}\nwdocspar
The function {\Tt{}hSeek\nwendquote} sets the I/O position of the specified handle
to a new position. The second argument determines how the offset
(the third argument) is interpreted. It must be a constant from the
type \texttt{SeekMode} defined in the module \texttt{IO} as follows.
\begin{verbatim}
  data SeekMode = AbsoluteSeek | RelativeSeek | SeekFromEnd
\end{verbatim}

\nwenddocs{}\nwbegincode{43}\sublabel{NW3MnbPe-1qkPlQ-L}\nwmargintag{{\nwtagstyle{}\subpageref{NW3MnbPe-1qkPlQ-L}}}\moddef{files.c~{\nwtagstyle{}\subpageref{NW3MnbPe-1qkPlQ-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW3MnbPe-1qkPlQ-K}{NW3MnbPe-1qkPlQ-M}\nwenddeflinemarkup
enum \{ AbsoluteSeek_tag, RelativeSeek_tag, SeekFromEnd_tag \};
DECLARE_CONST(__IO__AbsoluteSeek);
DECLARE_CONST(__IO__RelativeSeek);
DECLARE_CONST(__IO__SeekFromEnd);

DECLARE_ENTRYPOINT(__hSeek);
DECLARE_LABEL(__hSeek_1);
DECLARE_LABEL(__hSeek_2);

FUNCTION(__hSeek)
\{
    Node *file;

    EXPORT_LABEL(__hSeek)
 ENTRY_LABEL(__hSeek)
    EVAL_RIGID(__hSeek);
    file  = sp[0];
    sp[0] = sp[1];
    sp[1] = file;
    GOTO(__hSeek_1);
\}

static
FUNCTION(__hSeek_1)
\{
    Node *mode;

 ENTRY_LABEL(__hSeek_1)
    EVAL_RIGID(__hSeek_1);
    mode  = sp[0];
    sp[0] = sp[2];
    sp[2] = mode;
    GOTO(__hSeek_2);
\}

static
FUNCTION(__hSeek_2)
\{
    int              smode;
    struct file_node *file;
 ENTRY_LABEL(__hSeek_2)
    EVAL_RIGID_INT(__hSeek_2);

    file = (struct file_node *)sp[1];
    ASSERT(is_boxed(file) && node_tag(file) == FILE_TAG);

    if ( !(file->flags & (mask(readable) | mask(writable))) )
    \{
        sp   += 2;
        sp[0] = from_string("hSeek: handle not open");
        GOTO(__ioError);
    \}

    switch ( node_tag(sp[2]) )
    \{
    case AbsoluteSeek_tag:
        smode = SEEK_SET;
        break;
    case RelativeSeek_tag:
        smode = SEEK_CUR;
        break;
    case SeekFromEnd_tag:
        smode = SEEK_END;
        break;
    default:
        fprintf(stderr, "hSeek: invalid mode\\n");
        exit(2);
    \}

    ASSERT(file->fp != (FILE *)0);
    if ( fseek(file->fp, int_val(sp[0]), smode) == -1 )
    \{
        sp   += 2;
        sp[0] = from_string(strerror(errno));
        GOTO(__ioError);
    \}

    sp += 4;
    RETURN(unit);
\}

\nwendcode{}\nwbegindocs{44}\nwdocspar
The function {\Tt{}init{\_}files\nwendquote} initializes the standard channels and
optionally changes the buffer mode for standard input and output.

\nwenddocs{}\nwbegincode{45}\sublabel{NW3MnbPe-1qkPlQ-M}\nwmargintag{{\nwtagstyle{}\subpageref{NW3MnbPe-1qkPlQ-M}}}\moddef{files.c~{\nwtagstyle{}\subpageref{NW3MnbPe-1qkPlQ-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW3MnbPe-1qkPlQ-L}{\relax}\nwenddeflinemarkup
void
init_files(int bmode, long bsize)
\{
    char *buffer;

    /* set up the standard file pointers */
    stdin_node.fp = stdin;
    stdout_node.fp = stdout;
    stderr_node.fp = stderr;

    /* eventually change buffer modes for standard input and output */
    if ( bmode != -1 )
    \{
        /* don't allocate buffers if the file is not fully buffered */
        if ( bmode != _IOFBF )
            bsize = 0;

        /* change the buffer mode for the standard input channel */
        if ( bsize != 0 )
        \{
            buffer = (char *)malloc(bsize);
            if ( buffer == (char *)0 )
            \{
                fprintf(stderr, "cannot not allocate input buffer\\n");
                exit(1);
            \}
        \}
        else
            buffer = (char *)0;
        if ( setvbuf(stdin, buffer, bmode, bsize) == -1 )
        \{
            perror("setvbuf(stdin)");
            exit(1);
        \}
        stdin_node.bmode  = bmode;
        stdin_node.bsize  = bsize;
        stdin_node.buffer = buffer;

        /* change the buffer mode for the standard input channel */
        if ( bsize != 0 )
        \{
            buffer = (char *)malloc(bsize);
            if ( buffer == (char *)0 )
            \{
                fprintf(stderr, "cannot not allocate output buffer\\n");
                exit(1);
            \}
        \}
        else
            buffer = (char *)0;
        if ( setvbuf(stdout, buffer, bmode, bmode) == -1 )
        \{
            perror("setvbuf(stdout)");
            exit(1);
        \}
        stdout_node.bmode  = bmode;
        stdout_node.bsize  = bsize;
        stdout_node.buffer = buffer;
    \}
\}
\nwendcode{}

\nwixlogsorted{c}{{files.c}{NW3MnbPe-1qkPlQ-1}{\nwixd{NW3MnbPe-1qkPlQ-1}\nwixd{NW3MnbPe-1qkPlQ-2}\nwixd{NW3MnbPe-1qkPlQ-3}\nwixd{NW3MnbPe-1qkPlQ-4}\nwixd{NW3MnbPe-1qkPlQ-5}\nwixd{NW3MnbPe-1qkPlQ-6}\nwixd{NW3MnbPe-1qkPlQ-7}\nwixd{NW3MnbPe-1qkPlQ-8}\nwixd{NW3MnbPe-1qkPlQ-9}\nwixd{NW3MnbPe-1qkPlQ-A}\nwixd{NW3MnbPe-1qkPlQ-B}\nwixd{NW3MnbPe-1qkPlQ-C}\nwixd{NW3MnbPe-1qkPlQ-D}\nwixd{NW3MnbPe-1qkPlQ-E}\nwixd{NW3MnbPe-1qkPlQ-F}\nwixd{NW3MnbPe-1qkPlQ-G}\nwixd{NW3MnbPe-1qkPlQ-H}\nwixd{NW3MnbPe-1qkPlQ-I}\nwixd{NW3MnbPe-1qkPlQ-J}\nwixd{NW3MnbPe-1qkPlQ-K}\nwixd{NW3MnbPe-1qkPlQ-L}\nwixd{NW3MnbPe-1qkPlQ-M}}}%
\nwixlogsorted{c}{{files.h}{NW3MnbPe-4TFljM-1}{\nwixd{NW3MnbPe-4TFljM-1}}}%

