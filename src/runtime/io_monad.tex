\nwfilename{io_monad.nw}\nwbegindocs{0}% -*- noweb-code-mode: c-mode -*-% ===> this file was generated automatically by noweave --- better not edit it
% $Id: io_monad.nw,v 2.9 2004/05/02 09:17:27 wlux Exp $
%
% Copyright (c) 2001-2004, Wolfgang Lux
% See ../LICENSE for the full license.
%
\subsection{Monadic code}
The monadic driver is implemented in the file {\Tt{}io{\_}monad.c\nwendquote}. The main
entry-point into this module is the function {\Tt{}curry{\_}exec\nwendquote}, which
executes a monadic goal.

The function {\Tt{}curry{\_}exit\nwendquote} stops the execution of the program with
the given return code, which will be returned from {\Tt{}curry{\_}exec\nwendquote}.

The functions {\Tt{}getProgName\nwendquote} and {\Tt{}getArgs\nwendquote} return the name of the
program and its arguments, respectively.

\nwenddocs{}\nwbegincode{1}\sublabel{NW2fwvhY-2qUM7Y-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2fwvhY-2qUM7Y-1}}}\moddef{io\_monad.h~{\nwtagstyle{}\subpageref{NW2fwvhY-2qUM7Y-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
extern int  curry_exec(FunctionInfo *main_info_table, int argc, char **argv);
extern void curry_exit(int rc) __attribute__((noreturn));

extern Node *getProgName(void);
extern Node *getArgs(void);

DECLARE_ENTRYPOINT(__ioError);

\nwnotused{io_monad.h}\nwendcode{}\nwbegindocs{2}\nwdocspar
\nwenddocs{}\nwbegincode{3}\sublabel{NW2fwvhY-BiD76-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2fwvhY-BiD76-1}}}\moddef{io\_monad.c~{\nwtagstyle{}\subpageref{NW2fwvhY-BiD76-1}}}\endmoddef\nwstartdeflinemarkup\nwprevnextdefs{\relax}{NW2fwvhY-BiD76-2}\nwenddeflinemarkup
#include "curry.h"

DECLARE_LABEL(start_io);
DECLARE_LABEL(stop_io);
DECLARE_LABEL(choices_io);
DECLARE_LABEL(deadlock_io);
DECLARE_LABEL(fail_io);

static void fail_with(const char *msg) __attribute__((noreturn));

\nwalsodefined{\\{NW2fwvhY-BiD76-2}\\{NW2fwvhY-BiD76-3}\\{NW2fwvhY-BiD76-4}\\{NW2fwvhY-BiD76-5}\\{NW2fwvhY-BiD76-6}\\{NW2fwvhY-BiD76-7}\\{NW2fwvhY-BiD76-8}\\{NW2fwvhY-BiD76-9}\\{NW2fwvhY-BiD76-A}}\nwnotused{io_monad.c}\nwendcode{}\nwbegindocs{4}\nwdocspar
In this file we also provide the handler functions for
non-deterministic instructions, suspensions, and failures.
Non-deterministic code will raise an error in monadic code, deadlocks
and failures will terminate the program with an appropriate (error)
message.

\nwenddocs{}\nwbegindocs{5}\nwdocspar
\nwenddocs{}\nwbegincode{6}\sublabel{NW2fwvhY-BiD76-2}\nwmargintag{{\nwtagstyle{}\subpageref{NW2fwvhY-BiD76-2}}}\moddef{io\_monad.c~{\nwtagstyle{}\subpageref{NW2fwvhY-BiD76-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW2fwvhY-BiD76-1}{NW2fwvhY-BiD76-3}\nwenddeflinemarkup
static struct nondet_handlers io_handlers = \{
    choices_io, deadlock_io, fail_io
\};

static
FUNCTION(choices_io)
\{
 ENTRY_LABEL(choices_io)
    fail_with("ERROR: Cannot duplicate the world");
\}

static
FUNCTION(deadlock_io)
\{
 ENTRY_LABEL(deadlock_io)
    fail_with("Suspended");
\}

static
FUNCTION(fail_io)
\{
 ENTRY_LABEL(fail_io)
    fail_with("Failed");
\}

\nwendcode{}\nwbegindocs{7}\nwdocspar
The global entrypoint {\Tt{}start{\_}io\nwendquote} prepares the abstract machine to
evaluate the monadic goal on the top of the stack. The IO monad is
based on the type \texttt{IO}, which can be defined as
\begin{equation}
  \mbox{\texttt{type IO a = World -> (a,World)}}\label{eq:monadic-io}
\end{equation}
where the type \texttt{World} represents the state of the external
world. The state of the filesystem, etc. are managed implicitly in the
runtime system. Therefore, we can simply use the constant \texttt{()}
as a representation of the world. As this constant does not change we
can use a simpler reader monad instead of a state monad to implement
the \texttt{IO} type. Therefore, the runtime system really uses
\begin{equation}
  \mbox{\texttt{type IO a = () -> a}}\label{eq:our-io}
\end{equation}
Note that the IO monad in Curry is lazy, i.e., the result of a monadic
action is computed only when it is used by the program. Thus, the
program \verb|return undefined >> putStrLn "Hello world"| will print
the string \verb|Hello world| on the standard output. While this is
straight forward to implement using
representation~(\ref{eq:monadic-io}), we must be careful not to
evaluate the returned node in our representation~(\ref{eq:our-io}).

The program used for evaluating a monadic goal will compute the value
(of type \texttt{IO a}) returned by the goal to head-normal form and
terminate the program afterwards. The value computed by the monadic
action itself is discarded. In fact it is not computed at all.

\nwenddocs{}\nwbegincode{8}\sublabel{NW2fwvhY-BiD76-3}\nwmargintag{{\nwtagstyle{}\subpageref{NW2fwvhY-BiD76-3}}}\moddef{io\_monad.c~{\nwtagstyle{}\subpageref{NW2fwvhY-BiD76-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW2fwvhY-BiD76-2}{NW2fwvhY-BiD76-4}\nwenddeflinemarkup
static int  curry_argc;
static char **curry_argv;
static int  curry_rc = 0;

int
curry_exec(FunctionInfo *main_info_table, int argc, char **argv)
\{
    struct closure_node main_function;

    curry_argc = argc;
    curry_argv = argv;

    CHECK_STACK1();
    main_function.info = main_info_table;
    *--sp = (Node *)&main_function;

    run(start_io);
    return curry_rc;
\}

void
curry_exit(int rc)
\{
    curry_rc = rc;
    halt();
\}

static
FUNCTION(start_io)
\{
 ENTRY_LABEL(start_io)
    nondet_handlers = io_handlers;
    TRACE(("start program\\n"));
    CHECK_STACK(2);
    sp   -= 2;
    sp[0] = sp[2];
    sp[1] = unit;
    sp[2] = (Node *)0;
    start_thread(3);
    /* Hack: Change the return address of the main thread */
    sp[2] = (Node *)stop_io;
    GOTO(___64_);
\}

static
FUNCTION(stop_io)
\{
 ENTRY_LABEL(stop_io)
    curry_exit(0);
\}

static void
fail_with(const char *msg)
\{
    fprintf(stderr, "%s\\n", msg);
    curry_exit(1);
\}

\nwendcode{}\nwbegindocs{9}\nwdocspar
The function {\Tt{}getProgName\nwendquote} allocates and returns a new string in the
heap for the program's name. Similarly, {\Tt{}getArgs\nwendquote} returns a list of
the program's arguments (excluding the name). This information is
determined by looking at the values stored in {\Tt{}curry{\_}argc\nwendquote} and
{\Tt{}curry{\_}argv\nwendquote}.

\nwenddocs{}\nwbegincode{10}\sublabel{NW2fwvhY-BiD76-4}\nwmargintag{{\nwtagstyle{}\subpageref{NW2fwvhY-BiD76-4}}}\moddef{io\_monad.c~{\nwtagstyle{}\subpageref{NW2fwvhY-BiD76-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW2fwvhY-BiD76-3}{NW2fwvhY-BiD76-5}\nwenddeflinemarkup
Node *
getProgName()
\{
    return from_string(curry_argv[0]);
\}

Node *
getArgs()
\{
    unsigned i = curry_argc;
    Node     *arg, *cons = nil;
    ADD_LOCAL_ROOTS1((Node *)0);
#define tail LOCAL_ROOT[0]

    while ( i-- > 1 )
    \{
        /* NB: from_string may invoke gc; only tail is preserved here */ 
        tail            = cons;
        arg             = from_string(curry_argv[i]);
        cons            = (Node *)hp;
        cons->info      = &cons_info;
        cons->c.args[0] = arg;
        cons->c.args[1] = tail;
        hp             += cons_node_size;
    \}

#undef tail
    DROP_LOCAL_ROOTS();
    return cons;
\}

\nwendcode{}\nwbegindocs{11}\nwdocspar
The code for the primitive I/O actions \texttt{done}, \texttt{return},
\texttt{(>>)}, and \texttt{(>>=)} is implemented in this file, too.
The functions \texttt{done} and \texttt{(>>)} could be defined as
prelude functions but we can implement them more efficiently here.
Note that all functions take an additional argument due to the
underlying representation of the \texttt{IO} monad. Also note that
\texttt{return} does not evaluate its argument because of the lazy IO
monad semantics.

\nwenddocs{}\nwbegincode{12}\sublabel{NW2fwvhY-BiD76-5}\nwmargintag{{\nwtagstyle{}\subpageref{NW2fwvhY-BiD76-5}}}\moddef{io\_monad.c~{\nwtagstyle{}\subpageref{NW2fwvhY-BiD76-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW2fwvhY-BiD76-4}{NW2fwvhY-BiD76-6}\nwenddeflinemarkup
DECLARE_ENTRYPOINT(__done);

FUNCTION(__done)
\{
    EXPORT_LABEL(__done)
 ENTRY_LABEL(__done)
    sp += 1;
    RETURN(unit);
\}

DECLARE_ENTRYPOINT(__return);

FUNCTION(__return)
\{
    Node *r;

    EXPORT_LABEL(__return)
 ENTRY_LABEL(__return)
    r   = sp[0];
    sp += 2;
    RETURN(r);
\}

DECLARE_ENTRYPOINT(___62__62_);
DECLARE_LABEL(___62__62_1);

FUNCTION(___62__62_)
\{
    EXPORT_LABEL(___62__62_)
 ENTRY_LABEL(___62__62_)
    CHECK_STACK(2);
    sp   -= 2;
    sp[0] = sp[2];
    sp[1] = sp[4];
    sp[2] = (Node *)___62__62_1;
    GOTO(___64_);
\}

static
FUNCTION(___62__62_1)
\{
 ENTRY_LABEL(___62__62_1)
    sp += 1;
    GOTO(___64_);
\}

DECLARE_ENTRYPOINT(___62__62__61_);
DECLARE_LABEL(___62__62__61_1);
DECLARE_LABEL(___62__62__61_2);

FUNCTION(___62__62__61_)
\{
    EXPORT_LABEL(___62__62__61_)
 ENTRY_LABEL(___62__62__61_)
    CHECK_STACK(2);
    sp   -= 2;
    sp[0] = sp[2];
    sp[1] = sp[4];
    sp[2] = (Node *)___62__62__61_1;
    GOTO(___64_);
\}

static
FUNCTION(___62__62__61_1)
\{
 ENTRY_LABEL(___62__62__61_1)
    CHECK_STACK1();
    sp -= 1;
    sp[0] = sp[2];
    sp[2] = (Node *)___62__62__61_2;
    GOTO(___64_);
\}

static
FUNCTION(___62__62__61_2)
\{
 ENTRY_LABEL(___62__62__61_2)
    GOTO(___64_);
\}

\nwendcode{}\nwbegindocs{13}\nwdocspar
The function {\Tt{}catch\nwendquote} lets the user catch I/O exceptions in monadic
code. The function is passed a monadic action and an exception
handler. It creates a new exception frame on the stack and saves the
handler and the previous exception frame in the new frame, and then
executes the monadic action in the new context. When the action
returns normally, the frame is removed from the stack and the result
is returned to the caller.

\nwenddocs{}\nwbegincode{14}\sublabel{NW2fwvhY-BiD76-6}\nwmargintag{{\nwtagstyle{}\subpageref{NW2fwvhY-BiD76-6}}}\moddef{io\_monad.c~{\nwtagstyle{}\subpageref{NW2fwvhY-BiD76-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW2fwvhY-BiD76-5}{NW2fwvhY-BiD76-7}\nwenddeflinemarkup
DECLARE_ENTRYPOINT(__catch);
DECLARE_LABEL(__catch_1);

FUNCTION(__catch)
\{
    Node           *action, *handler, *world;
    ExceptionFrame *prevFrame;

    EXPORT_LABEL(__catch)
 ENTRY_LABEL(__catch)

    CHECK_STACK(wordsof(ExceptionFrame));
    action  = sp[0];
    handler = sp[1];
    world   = sp[2];

    /* create and initialize the new exception frame */
    sp += 3 - wordsof(ExceptionFrame);
    prevFrame    = efp;
    efp          = (ExceptionFrame *)sp;
    efp->handler = handler;
    efp->frame   = prevFrame;

    /* invoke the action */
    sp -= 3;
    sp[0] = action;
    sp[1] = world;
    sp[2] = (Node *)__catch_1;
    GOTO(___64_);
\}

static
FUNCTION(__catch_1)
\{
    Node           *r;
    ExceptionFrame *curFrame;

 ENTRY_LABEL(__catch_1)
    r = sp[0];

    curFrame = efp;
    efp      = efp->frame;
    sp       = (Node **)curFrame + wordsof(ExceptionFrame);

    RETURN(r);
\}

\nwendcode{}\nwbegindocs{15}\nwdocspar
The function {\Tt{}ioError\nwendquote} raises a user exception. It removes the stack
up to and including the current exception frame and applies the
exception handler from that frame to the exception value. If no
exception handler is available -- as may happen when
{\Tt{}unsafePerformIO\nwendquote} is used -- the program is aborted using the
{\Tt{}error\nwendquote} function from the prelude.

\nwenddocs{}\nwbegincode{16}\sublabel{NW2fwvhY-BiD76-7}\nwmargintag{{\nwtagstyle{}\subpageref{NW2fwvhY-BiD76-7}}}\moddef{io\_monad.c~{\nwtagstyle{}\subpageref{NW2fwvhY-BiD76-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW2fwvhY-BiD76-6}{NW2fwvhY-BiD76-8}\nwenddeflinemarkup
DECLARE_ENTRYPOINT(__prelude__error);
DECLARE_LABEL(__ioError_1);

FUNCTION(__ioError)
\{
    Node           *exc, *handler, *world;
    ExceptionFrame *curFrame;

    EXPORT_LABEL(__ioError)
 ENTRY_LABEL(__ioError)
    TRACE(("%I throw %N\\n", sp[0]));

    if ( efp == (ExceptionFrame *)0 )
    \{
        sp[1] = prefix_string("Uncaught I/O exception:\\n", sp[0]);
        sp   += 1;
        GOTO(__prelude__error);
    \}

    exc      = sp[0];
    world    = sp[1];
    curFrame = efp;
    handler  = efp->handler;
    efp      = efp->frame;

    sp    = (Node **)curFrame + wordsof(ExceptionFrame) - 4;
    sp[0] = handler;
    sp[1] = exc;
    sp[2] = (Node *)__ioError_1;
    sp[3] = world;
    GOTO(___64_);
\}

static
FUNCTION(__ioError_1)
\{
 ENTRY_LABEL(__ioError_1)
    GOTO(___64_);
\}

\nwendcode{}\nwbegindocs{17}\nwdocspar
The function {\Tt{}unsafePerformIO\nwendquote} allows executing a monadic action
and returning its result into a regular function. The function can be
used for implementing a simple (unsafe) trace function and can also
serve for generating unique entities~\cite{AugustssonRittriSynek94:Unique}.

Recall that the IO monad is lazy, therefore we must evaluate the result
of the monadic action to head normal form, eventually.

\textbf{As the name of the function suggests, its use is totally
unsafe. This function is a hack and should not be used casually.}

\nwenddocs{}\nwbegincode{18}\sublabel{NW2fwvhY-BiD76-8}\nwmargintag{{\nwtagstyle{}\subpageref{NW2fwvhY-BiD76-8}}}\moddef{io\_monad.c~{\nwtagstyle{}\subpageref{NW2fwvhY-BiD76-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW2fwvhY-BiD76-7}{NW2fwvhY-BiD76-9}\nwenddeflinemarkup
DECLARE_ENTRYPOINT(__unsafePerformIO);
DECLARE_LABEL(__unsafePerformIO_1);

FUNCTION(__unsafePerformIO)
\{
    EXPORT_LABEL(__unsafePerformIO)
 ENTRY_LABEL(__unsafePerformIO)
    CHECK_STACK(2);
    sp   -= 2;
    sp[0] = sp[2];
    sp[1] = unit;
    sp[2] = (Node *) __unsafePerformIO_1;
    GOTO(___64_);
\}

static
FUNCTION(__unsafePerformIO_1)
\{
    Node *r;

 ENTRY_LABEL(__unsafePerformIO_1)
    r = sp[0];
    if ( is_boxed(r) )
        GOTO(r->info->eval);
    sp += 1;
    RETURN(r);
\}

\nwendcode{}\nwbegindocs{19}\nwdocspar
The {\Tt{}fixIO\nwendquote} function was recently introduced in Haskell in order to
allow recursive bindings in a monad. The function is the fixpoint
operator in the IO monad with type {\Tt{}(a\ ->\ IO\ a)\ ->\ IO\ a\nwendquote} and
corresponds to the regular fix point operator {\Tt{}fix\ ::\ (a\ ->\ a)\ ->\ a\nwendquote}
that can be defined as
\begin{equation}
  \mbox{\texttt{fix f = let x = f x in x}}\label{eq:fix}
\end{equation}
in Curry.\footnote{Actually, this definition is not valid according to
the Curry report because of the recursive value binding. However, it
is accepted as an extension by our compiler.} The following is an
attempt to implement fixIO in Curry. Using the
representation~(\ref{eq:monadic-io}) of \texttt{IO a} together with
\texttt{type World = ()}, {\Tt{}fixIO\nwendquote} can be defined as follows.
\begin{equation}
  \mbox{\texttt{fixIO f () = let (x,()) = f x () in (x,())}}\label{eq:fixIO}
\end{equation}
As we use the representation~(\ref{eq:our-io}) instead
of~(\ref{eq:monadic-io}), our implementation is even closer to the
definition of \texttt{fix}.
\begin{equation}
  \mbox{\texttt{fixIO f () = let x = f x () in x}}\label{eq:our-fixIO}
\end{equation}

\nwenddocs{}\nwbegincode{20}\sublabel{NW2fwvhY-BiD76-9}\nwmargintag{{\nwtagstyle{}\subpageref{NW2fwvhY-BiD76-9}}}\moddef{io\_monad.c~{\nwtagstyle{}\subpageref{NW2fwvhY-BiD76-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW2fwvhY-BiD76-8}{NW2fwvhY-BiD76-A}\nwenddeflinemarkup
DECLARE_ENTRYPOINT(__fixIO);

FUNCTION(__fixIO)
\{
    Node *clos, *clos2, *susp;
    EXPORT_LABEL(__fixIO)
 ENTRY_LABEL(__fixIO)
    CHECK_HEAP(2*closure_node_size(2) + suspend_node_size);
    clos  = (Node *)hp;
    clos2 = (Node *)(hp + closure_node_size(2));
    susp  = (Node *)(hp + 2*closure_node_size(2));
    hp   += 2*closure_node_size(2) + suspend_node_size;

    clos->cl.info    = &___64__info;
    clos->cl.args[0] = sp[0];
    clos->cl.args[1] = susp;

    clos2->cl.info    = &___64__info;
    clos2->cl.args[0] = clos;
    clos2->cl.args[1] = sp[1];

    susp->s.info = &___64__suspend_info;
    susp->s.fn   = clos2;
    susp->s.spc  = ss;
    hp          += suspend_node_size;

    *++sp = susp;
    GOTO(susp->info->eval);    
\}

\nwendcode{}\nwbegindocs{21}\nwdocspar
The primitive I/O action {\Tt{}performGC\nwendquote} invokes the garbage collector.

\nwenddocs{}\nwbegincode{22}\sublabel{NW2fwvhY-BiD76-A}\nwmargintag{{\nwtagstyle{}\subpageref{NW2fwvhY-BiD76-A}}}\moddef{io\_monad.c~{\nwtagstyle{}\subpageref{NW2fwvhY-BiD76-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW2fwvhY-BiD76-9}{\relax}\nwenddeflinemarkup
DECLARE_ENTRYPOINT(__performGC);

FUNCTION(__performGC)
\{
    EXPORT_LABEL(__performGC)
 ENTRY_LABEL(__performGC)
    sp += 1;
    collect(0);
    RETURN(unit);
\}
\nwendcode{}

\nwixlogsorted{c}{{io_monad.c}{NW2fwvhY-BiD76-1}{\nwixd{NW2fwvhY-BiD76-1}\nwixd{NW2fwvhY-BiD76-2}\nwixd{NW2fwvhY-BiD76-3}\nwixd{NW2fwvhY-BiD76-4}\nwixd{NW2fwvhY-BiD76-5}\nwixd{NW2fwvhY-BiD76-6}\nwixd{NW2fwvhY-BiD76-7}\nwixd{NW2fwvhY-BiD76-8}\nwixd{NW2fwvhY-BiD76-9}\nwixd{NW2fwvhY-BiD76-A}}}%
\nwixlogsorted{c}{{io_monad.h}{NW2fwvhY-2qUM7Y-1}{\nwixd{NW2fwvhY-2qUM7Y-1}}}%

