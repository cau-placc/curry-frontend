\nwfilename{constraints.nw}\nwbegindocs{0}% -*- noweb-code-mode: c-mode -*-% ===> this file was generated automatically by noweave --- better not edit it
% $Id: constraints.nw,v 2.9 2004/05/02 09:17:27 wlux Exp $
%
% Copyright (c) 2002-2004, Wolfgang Lux
% See ../LICENSE for the full license.
%
\subsection{Basic constraints}
This file implements two basic constraint functions, viz. the trivial
constraint \texttt{success}, which is always satisfied, and the
concurrent conjunction of two constraints \texttt{\&}. The equality
constraint \texttt{=:=} is defined in section~\ref{sec:unification}.

\nwenddocs{}\nwbegincode{1}\sublabel{NW2LggXa-1aceii-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2LggXa-1aceii-1}}}\moddef{constraints.c~{\nwtagstyle{}\subpageref{NW2LggXa-1aceii-1}}}\endmoddef\nwstartdeflinemarkup\nwprevnextdefs{\relax}{NW2LggXa-1aceii-2}\nwenddeflinemarkup
#include "config.h"
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include "debug.h"
#include "run.h"
#include "heap.h"
#include "stack.h"
#include "eval.h"
#include "threads.h"
#include "spaces.h"
#include "cam.h"
#include "trace.h"

DECLARE_ENTRYPOINT(__success);

FUNCTION(__success)
\{
    EXPORT_LABEL(__success)
 ENTRY_LABEL(__success)
    RETURN(Success);
\}

\nwalsodefined{\\{NW2LggXa-1aceii-2}\\{NW2LggXa-1aceii-3}\\{NW2LggXa-1aceii-4}}\nwnotused{constraints.c}\nwendcode{}\nwbegindocs{2}\nwdocspar
The code for the parallel conjunction tries to avoid creating a
new thread whenever this is possible. The only case where a new thread
must be started is when both arguments are (suspended)
applications. In this case, the evaluation of the first argument is
started on a new thread. In order to synchronize the current thread
and its new child, at least one of the applications must be a
suspension. A new suspension node is created if
necessary. Otherwise, if there is one argument that is not in normal
form, its evaluation will be started. Finally, for queue-me closures
and the case of two variables, the current thread will be
suspended. Note that the concurrent conjunction may return an unbound
variable to the caller. The caller is responsible for suspending the
computation until this variable is bound.

\nwenddocs{}\nwbegincode{3}\sublabel{NW2LggXa-1aceii-2}\nwmargintag{{\nwtagstyle{}\subpageref{NW2LggXa-1aceii-2}}}\moddef{constraints.c~{\nwtagstyle{}\subpageref{NW2LggXa-1aceii-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW2LggXa-1aceii-1}{NW2LggXa-1aceii-3}\nwenddeflinemarkup
DECLARE_ENTRYPOINT(___38_);
DECLARE_LABEL(___38__1);
DECLARE_LABEL(___38__2);

FUNCTION(___38_)
\{
    Node *c1, *c2, *aux;

    EXPORT_LABEL(___38_)
 ENTRY_LABEL(___38_)

    for ( c1 = sp[0]; node_tag(c1) == INDIR_TAG; c1 = c1->n.node )
        ;
    for ( c2 = sp[1]; node_tag(c2) == INDIR_TAG; c2 = c2->n.node )
        ;

    switch ( node_tag(c1) )
    \{
    case CLOSURE_TAG:
        switch ( node_tag(c2) )
        \{
        case CLOSURE_TAG:
            sp[0] = c1;
            sp[1] = c2;
            CHECK_HEAP(queueMe_node_size);
            aux        = (Node *)hp;
            aux->info  = &queueMe_info;
            aux->q.wq  = (ThreadQueue)0;
            aux->q.spc = ss;
            hp        += queueMe_node_size;
            CHECK_STACK(4);
            sp   -= 4;
            sp[0] = sp[4];
            sp[1] = (Node *)update;
            sp[2] = aux;
            sp[3] = (Node *)___38_;
            sp[4] = aux;
            start_thread(4);
            GOTO(sp[0]->info->eval);
        case SUSPEND_TAG:
            aux = c1;
            c1  = c2;
            c2  = aux;
            break;
        \}
        /* FALL THROUGH!!! */
    case SUSPEND_TAG:
        switch ( node_tag(c2) )
        \{
        case CLOSURE_TAG:
        case SUSPEND_TAG:
            CHECK_STACK(2);
            sp   -= 2;
            sp[0] = c1;
            sp[1] = (Node *)___38_;
            sp[2] = c1;
            sp[3] = c2;
            start_thread(2);
            GOTO(sp[0]->info->eval);
        case QUEUEME_TAG:
        case VARIABLE_TAG:
            CHECK_STACK1();
            sp   -= 1;
            sp[0] = c1;
            sp[1] = (Node *)___38__1;
            sp[2] = c2;
            GOTO(c1->info->eval);
        case SUCCESS_TAG:
            *++sp = c1;
            GOTO(c1->info->eval);
        \}
        break;
    case QUEUEME_TAG:
        switch ( node_tag(c2) )
        \{
        case CLOSURE_TAG:
        case SUSPEND_TAG:
            CHECK_STACK1();
            sp   -= 1;
            sp[0] = c2;
            sp[1] = (Node *)___38__1;
            sp[2] = c1;
            GOTO(c2->info->eval);
        case QUEUEME_TAG:
        case VARIABLE_TAG:
            CHECK_STACK1();
            sp   -= 1;
            sp[0] = c1;
            sp[1] = (Node *)___38__1;
            sp[2] = c2;
            GOTO(c1->info->eval);
        case SUCCESS_TAG:
            *++sp = c1;
            GOTO(c1->info->eval);
        \}
        break;
    case VARIABLE_TAG:
        /* evaluate the other argument then delay */
        switch ( node_tag(c2) )
        \{
        case CLOSURE_TAG:
        case SUSPEND_TAG:
        case QUEUEME_TAG:
            CHECK_STACK1();
            sp   -= 1;
            sp[0] = c2;
            sp[1] = (Node *)___38__1;
            sp[2] = c1;
            GOTO(c2->info->eval);
        case VARIABLE_TAG:
            sp[0] = c1;
            sp[1] = c2;
            GOTO(delay_thread(___38__2, c1));
        case SUCCESS_TAG:
            sp += 2;
            RETURN(c1);
        \}
        break;
    case SUCCESS_TAG:
        /* trivial case */
        switch ( node_tag(c2) )
        \{
        case CLOSURE_TAG:
        case SUSPEND_TAG:
        case QUEUEME_TAG:
            *++sp = c2;
            GOTO(c2->info->eval);
        case VARIABLE_TAG:
        case SUCCESS_TAG:
            sp += 2;
            RETURN(c2);
        \}
        break;
    \}
    fprintf(stderr, "(&) invalid argument\\n");
    exit(2);
\}

\nwendcode{}\nwbegindocs{4}\nwdocspar
When an argument has been evaluated to head normal form, it must be
either a variable or the constant {\Tt{}Success\nwendquote}. In the latter case we
can simply return the other argument to the caller -- except if it is
still a queue-me closure. In the former case, we may return the
variable if the other argument was evaluated to {\Tt{}Success\nwendquote} in the
meantime.

\nwenddocs{}\nwbegincode{5}\sublabel{NW2LggXa-1aceii-3}\nwmargintag{{\nwtagstyle{}\subpageref{NW2LggXa-1aceii-3}}}\moddef{constraints.c~{\nwtagstyle{}\subpageref{NW2LggXa-1aceii-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW2LggXa-1aceii-2}{NW2LggXa-1aceii-4}\nwenddeflinemarkup
static
FUNCTION(___38__1)
\{
    Node *c1, *c2;

 ENTRY_LABEL(___38__1)
    /* if the evaluated argument is now success return the other one */
    for ( c1 = sp[0]; node_tag(c1) == INDIR_TAG; c1 = c1->n.node )
        ;
    c2 = sp[1];
    if ( node_tag(c1) == SUCCESS_TAG )
    \{
    again_1:
        switch ( node_tag(c2) )
        \{
        case INDIR_TAG:
            c2 = c2->n.node;
            goto again_1;
        case QUEUEME_TAG:
            *++sp = c2;
            GOTO(c2->info->eval);
        case VARIABLE_TAG:
        case SUCCESS_TAG:
            sp += 2;
            RETURN(c2);
        default:
            fprintf(stderr, "(&): invalid argument\\n");
            exit(2);
        \}
    \}

    /* wait for the other argument being evaluated if it is a queue-me */
    ASSERT(node_tag(c1) == VARIABLE_TAG);
 again_2:
    switch ( node_tag(c2) )
    \{
    case INDIR_TAG:
        c2 = c2->n.node;
        goto again_2;
    case QUEUEME_TAG:
        CHECK_STACK1();
        sp   -= 1;
        sp[0] = c2;
        sp[1] = (Node *)___38__1;
        sp[2] = c1;
        GOTO(c2->info->eval);
    case VARIABLE_TAG:
        sp[0] = c1;
        sp[1] = c2;
        GOTO(delay_thread(___38__2, c1));
    case SUCCESS_TAG:
        break;
    \}

    sp += 2;
    RETURN(c1);
\}

\nwendcode{}\nwbegindocs{6}\nwdocspar
After waiting for an unbound variable to become ground, we can always
return the other argument. Note that this code can be invoked only if
the other argument was a variable node. Therefore, it can only be
still a variable or an indirection, which either points to another
variable or to {\Tt{}Success\nwendquote}.

\nwenddocs{}\nwbegincode{7}\sublabel{NW2LggXa-1aceii-4}\nwmargintag{{\nwtagstyle{}\subpageref{NW2LggXa-1aceii-4}}}\moddef{constraints.c~{\nwtagstyle{}\subpageref{NW2LggXa-1aceii-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW2LggXa-1aceii-3}{\relax}\nwenddeflinemarkup
static
FUNCTION(___38__2)
\{
    Node *c1, *c2;

 ENTRY_LABEL(___38__2)
    for ( c1 = sp[0]; node_tag(c1) == INDIR_TAG; c1 = c1->n.node )
        ;
    for ( c2 = sp[1]; node_tag(c2) == INDIR_TAG; c2 = c2->n.node )
        ;
    ASSERT(node_tag(c1) == SUCCESS_TAG);
    ASSERT(node_tag(c2) == SUCCESS_TAG || node_tag(c2) == VARIABLE_TAG);

    sp += 2;
    RETURN(c2);
\}
\nwendcode{}

\nwixlogsorted{c}{{constraints.c}{NW2LggXa-1aceii-1}{\nwixd{NW2LggXa-1aceii-1}\nwixd{NW2LggXa-1aceii-2}\nwixd{NW2LggXa-1aceii-3}\nwixd{NW2LggXa-1aceii-4}}}%

