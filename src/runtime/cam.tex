\nwfilename{cam.nw}\nwbegindocs{0}% -*- noweb-code-mode: c-mode -*-% ===> this file was generated automatically by noweave --- better not edit it
% $Id: cam.nw,v 2.5 2003/06/08 20:37:59 wlux Exp $
%
% Copyright (c) 2001-2003, Wolfgang Lux
% See ../LICENSE for the full license.
%
\subsection{Abstract machine instruction macros}
The header file {\Tt{}cam.h\nwendquote} defines a few useful macros for writing
external functions.

\nwenddocs{}\nwbegindocs{1}\nwdocspar
The {\Tt{}RETURN\nwendquote} and {\Tt{}ENTER\nwendquote} macros return a value on the top of the
stack to the caller of the current function. {\Tt{}RETURN\nwendquote} must be used
only if the value is known to be in head normal form. Otherwise the
{\Tt{}ENTER\nwendquote} macro must be used which starts the evaluation of the node
if it is not in head normal form with a tail call to the evaluation
code.

\nwenddocs{}\nwbegincode{2}\sublabel{NW1y9PES-2yhhlt-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW1y9PES-2yhhlt-1}}}\moddef{cam.h~{\nwtagstyle{}\subpageref{NW1y9PES-2yhhlt-1}}}\endmoddef\nwstartdeflinemarkup\nwprevnextdefs{\relax}{NW1y9PES-2yhhlt-2}\nwenddeflinemarkup
#define RETURN(_res) \{ \\
    Label ret_ip = (Label)sp[0]; \\
    sp[0] = (_res); \\
    TRACE(("%I return %N\\n", (_res))); \\
    GOTO(ret_ip); \\
\}

#define ENTER(_node) \{ \\
    if ( is_boxed(_node) ) \{ \\
        CHECK_STACK1(); \\
        *--sp = (_node); \\
        GOTO((_node)->info->eval); \\
    \} \\
    RETURN(_node); \\
\}

\nwalsodefined{\\{NW1y9PES-2yhhlt-2}\\{NW1y9PES-2yhhlt-3}}\nwnotused{cam.h}\nwendcode{}\nwbegindocs{3}\nwdocspar
The {\Tt{}FAIL\nwendquote} macro invokes the current failure handler.

\nwenddocs{}\nwbegincode{4}\sublabel{NW1y9PES-2yhhlt-2}\nwmargintag{{\nwtagstyle{}\subpageref{NW1y9PES-2yhhlt-2}}}\moddef{cam.h~{\nwtagstyle{}\subpageref{NW1y9PES-2yhhlt-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW1y9PES-2yhhlt-1}{NW1y9PES-2yhhlt-3}\nwenddeflinemarkup
#define FAIL() GOTO(nondet_handlers.fail)

\nwendcode{}\nwbegindocs{5}\nwdocspar
The following macros implement evaluation of the node on the top of
the stack. All macros except {\Tt{}EVAL{\_}FLEX{\_}POLY\nwendquote} also suspend the
current thread until the node is not an unbound variable.
{\Tt{}EVAL{\_}RIGID{\_}CHAR\nwendquote}, {\Tt{}EVAL{\_}RIGID{\_}INT\nwendquote}, {\Tt{}EVAL{\_}RIGID{\_}FLOAT\nwendquote}, and
{\Tt{}EVAL{\_}RIGID{\_}POLY\nwendquote} carefully check for unboxed values while the other
macros assume that the node on the top of the stack is always boxed.
The argument of all macros is the label where execution continues
after the node has been evaluated or after resuming the current
thread. In general this is the entry-point of the function that uses
the {\Tt{}EVAL\nwendquote} macro.

\nwenddocs{}\nwbegincode{6}\sublabel{NW1y9PES-2yhhlt-3}\nwmargintag{{\nwtagstyle{}\subpageref{NW1y9PES-2yhhlt-3}}}\moddef{cam.h~{\nwtagstyle{}\subpageref{NW1y9PES-2yhhlt-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW1y9PES-2yhhlt-2}{\relax}\nwenddeflinemarkup
#define EVAL_RIGID(l) \\
for (;;) \{ \\
    switch ( sp[0]->info->tag ) \{ \\
    case INDIR_TAG: sp[0] = sp[0]->n.node; continue; \\
    case CLOSURE_TAG: case SUSPEND_TAG: case QUEUEME_TAG: \\
        CHECK_STACK1(); sp -= 1; sp[0] = sp[1]; sp[1] = (Node *)(l); \\
        GOTO(sp[0]->info->eval); \\
    case VARIABLE_TAG: GOTO(delay_thread(l, sp[0])); \\
    default: break; \\
    \} \\
    break; \\
\}

#define EVAL_RIGID_CHAR(l) \\
for (;;) \{ \\
    switch ( sp[0]->info->tag ) \{ \\
    case INDIR_TAG: sp[0] = sp[0]->n.node; continue; \\
    case CLOSURE_TAG: case SUSPEND_TAG: case QUEUEME_TAG: \\
        CHECK_STACK1(); sp -= 1; sp[0] = sp[1]; sp[1] = (Node *)(l); \\
        GOTO(sp[0]->info->eval); \\
    case VARIABLE_TAG: GOTO(delay_thread(l, sp[0])); \\
    default: ASSERT(sp[0]->info->tag == CHAR_TAG); break; \\
    \} \\
    break; \\
\}

#define EVAL_RIGID_INT(l) \\
for (;;) \{ \\
    if ( is_boxed(sp[0]) ) \\
        switch ( sp[0]->info->tag ) \{ \\
        case INDIR_TAG: sp[0] = sp[0]->n.node; continue; \\
        case CLOSURE_TAG: case SUSPEND_TAG: case QUEUEME_TAG: \\
            CHECK_STACK1(); sp -= 1; sp[0] = sp[1]; sp[1] = (Node *)(l); \\
            GOTO(sp[0]->info->eval); \\
        case VARIABLE_TAG: GOTO(delay_thread(l, sp[0])); \\
        default: ASSERT(sp[0]->info->tag == INT_TAG); break; \\
        \} \\
    break; \\
\}

#define EVAL_RIGID_FLOAT(l) \\
for (;;) \{ \\
    switch ( sp[0]->info->tag ) \{ \\
    case INDIR_TAG: sp[0] = sp[0]->n.node; continue; \\
    case CLOSURE_TAG: case SUSPEND_TAG: case QUEUEME_TAG: \\
        CHECK_STACK1(); sp -= 1; sp[0] = sp[1]; sp[1] = (Node *)(l); \\
        GOTO(sp[0]->info->eval); \\
    case VARIABLE_TAG: GOTO(delay_thread(l, sp[0])); \\
    default: ASSERT(sp[0]->info->tag == FLOAT_TAG); break; \\
    \} \\
    break; \\
\}

#define EVAL_FLEX_POLY(l) \\
for (;;) \{ \\
    if ( is_boxed(sp[0]) ) \\
        switch ( sp[0]->info->tag ) \{ \\
        case INDIR_TAG: sp[0] = sp[0]->n.node; continue; \\
        case CLOSURE_TAG: case SUSPEND_TAG: case QUEUEME_TAG: \\
            CHECK_STACK1(); sp -= 1; sp[0] = sp[1]; sp[1] = (Node *)(l); \\
            GOTO(sp[0]->info->eval); \\
        default: break; \\
        \} \\
    break; \\
\}

#define EVAL_RIGID_POLY(l) \\
for (;;) \{ \\
    if ( is_boxed(sp[0]) ) \\
        switch ( sp[0]->info->tag ) \{ \\
        case INDIR_TAG: sp[0] = sp[0]->n.node; continue; \\
        case CLOSURE_TAG: case SUSPEND_TAG: case QUEUEME_TAG: \\
            CHECK_STACK1(); sp -= 1; sp[0] = sp[1]; sp[1] = (Node *)(l); \\
            GOTO(sp[0]->info->eval); \\
        case VARIABLE_TAG: GOTO(delay_thread(l, sp[0])); \\
        default: break; \\
        \} \\
    break; \\
\}
\nwendcode{}

\nwixlogsorted{c}{{cam.h}{NW1y9PES-2yhhlt-1}{\nwixd{NW1y9PES-2yhhlt-1}\nwixd{NW1y9PES-2yhhlt-2}\nwixd{NW1y9PES-2yhhlt-3}}}%

