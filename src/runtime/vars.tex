\nwfilename{vars.nw}\nwbegindocs{0}% -*- noweb-code-mode: c-mode -*-% ===> this file was generated automatically by noweave --- better not edit it
% $Id: vars.nw,v 2.1 2002/12/01 10:32:27 lux Exp $
%
% Copyright (c) 2002, Wolfgang Lux
% See ../LICENSE for the full license.
%
\subsection{Naming variables}
For printing the result as well as for the \texttt{browse} function
and for the debugger we need to associate variable nodes with unique
names. This is done by maintaining a dictionary that maps the
addresses of variables onto names.

\nwenddocs{}\nwbegincode{1}\sublabel{NWqGiTS-1Uspz9-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWqGiTS-1Uspz9-1}}}\moddef{vars.c~{\nwtagstyle{}\subpageref{NWqGiTS-1Uspz9-1}}}\endmoddef\nwstartdeflinemarkup\nwprevnextdefs{\relax}{NWqGiTS-1Uspz9-2}\nwenddeflinemarkup
#include "config.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "debug.h"
#include "run.h"
#include "heap.h"
#include "stack.h"
#include "vars.h"

\nwalsodefined{\\{NWqGiTS-1Uspz9-2}\\{NWqGiTS-1Uspz9-3}\\{NWqGiTS-1Uspz9-4}\\{NWqGiTS-1Uspz9-5}\\{NWqGiTS-1Uspz9-6}\\{NWqGiTS-1Uspz9-7}}\nwnotused{vars.c}\nwendcode{}\nwbegindocs{2}\nwdocspar
At present the dictionary is implemented as a simple linked list
rooted in {\Tt{}names{\_}dict\nwendquote} and a pointer to the last node of the
dictionary is saved in {\Tt{}names{\_}tail\nwendquote}.

The type of dictionary nodes has to be exported because the garbage
collector must update the node pointers in the
dictionary. \textbf{These declarations should not be used in any other
module!}

\ToDo{Use a hash table for the dictionary.}

\nwenddocs{}\nwbegincode{3}\sublabel{NWqGiTS-3X3XIp-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWqGiTS-3X3XIp-1}}}\moddef{vars.h~{\nwtagstyle{}\subpageref{NWqGiTS-3X3XIp-1}}}\endmoddef\nwstartdeflinemarkup\nwprevnextdefs{\relax}{NWqGiTS-3X3XIp-2}\nwenddeflinemarkup
struct dict_node \{
    Node             *node;             /* variable node         */
    const char       *name;             /* name of variables     */
    struct dict_node *next;             /* link to next variable */
\};

extern struct dict_node *names_dict, *names_tail;

\nwalsodefined{\\{NWqGiTS-3X3XIp-2}\\{NWqGiTS-3X3XIp-3}\\{NWqGiTS-3X3XIp-4}\\{NWqGiTS-3X3XIp-5}}\nwnotused{vars.h}\nwendcode{}\nwbegindocs{4}\nwdocspar
\nwenddocs{}\nwbegincode{5}\sublabel{NWqGiTS-1Uspz9-2}\nwmargintag{{\nwtagstyle{}\subpageref{NWqGiTS-1Uspz9-2}}}\moddef{vars.c~{\nwtagstyle{}\subpageref{NWqGiTS-1Uspz9-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NWqGiTS-1Uspz9-1}{NWqGiTS-1Uspz9-3}\nwenddeflinemarkup
struct dict_node *names_dict;
struct dict_node *names_tail;

\nwendcode{}\nwbegindocs{6}\nwdocspar
New entries can be inserted into the dictionary using the function
{\Tt{}add{\_}name\nwendquote}. The name will {\Tt{}free\nwendquote}d when the dictionary is released,
so the {\Tt{}name\nwendquote} argument should point to a {\Tt{}malloc\nwendquote}ed string --
except for entries allocated in the startup code that are never going
to be released.

\nwenddocs{}\nwbegincode{7}\sublabel{NWqGiTS-3X3XIp-2}\nwmargintag{{\nwtagstyle{}\subpageref{NWqGiTS-3X3XIp-2}}}\moddef{vars.h~{\nwtagstyle{}\subpageref{NWqGiTS-3X3XIp-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NWqGiTS-3X3XIp-1}{NWqGiTS-3X3XIp-3}\nwenddeflinemarkup
extern void add_name(Node *node, const char *name);

\nwendcode{}\nwbegindocs{8}\nwdocspar
\nwenddocs{}\nwbegincode{9}\sublabel{NWqGiTS-1Uspz9-3}\nwmargintag{{\nwtagstyle{}\subpageref{NWqGiTS-1Uspz9-3}}}\moddef{vars.c~{\nwtagstyle{}\subpageref{NWqGiTS-1Uspz9-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NWqGiTS-1Uspz9-2}{NWqGiTS-1Uspz9-4}\nwenddeflinemarkup
void
add_name(Node *node, const char *name)
\{
    struct dict_node *next;

    next = (struct dict_node *)malloc(sizeof(struct dict_node));
    if ( next == (struct dict_node *)0 )
    \{
        fprintf(stderr, "dictionary space exhausted, aborting ...\\n");
        exit(2);
    \}
    next->node = node;
    next->name = name;
    next->next = (struct dict_node *)0;

    if ( names_tail == (struct dict_node *)0 )
    \{
        ASSERT(names_dict == (struct dict_node *)0);
        names_dict = names_tail = next;
    \}
    else
    \{
        names_tail->next = next;
        names_tail       = next;
    \}
\}

\nwendcode{}\nwbegindocs{10}\nwdocspar
The function {\Tt{}release{\_}names\nwendquote} releases all dictionary entries after
{\Tt{}new{\_}tail\nwendquote}. If this argument is {\Tt{}0\nwendquote} the whole dictionary is
released.

This function should be used to remove only the segment of dictionary
that was created since that last choicepoint or search context was
installed. Releasing a bigger segment might leave dangling pointers in
the control stack.

\nwenddocs{}\nwbegincode{11}\sublabel{NWqGiTS-3X3XIp-3}\nwmargintag{{\nwtagstyle{}\subpageref{NWqGiTS-3X3XIp-3}}}\moddef{vars.h~{\nwtagstyle{}\subpageref{NWqGiTS-3X3XIp-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NWqGiTS-3X3XIp-2}{NWqGiTS-3X3XIp-4}\nwenddeflinemarkup
extern void release_names(struct dict_node *new_tail);

\nwendcode{}\nwbegindocs{12}\nwdocspar
\nwenddocs{}\nwbegincode{13}\sublabel{NWqGiTS-1Uspz9-4}\nwmargintag{{\nwtagstyle{}\subpageref{NWqGiTS-1Uspz9-4}}}\moddef{vars.c~{\nwtagstyle{}\subpageref{NWqGiTS-1Uspz9-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NWqGiTS-1Uspz9-3}{NWqGiTS-1Uspz9-5}\nwenddeflinemarkup
void
release_names(struct dict_node *new_tail)
\{
    struct dict_node *curr, *next;

    if ( new_tail != names_tail )
    \{
        names_tail = new_tail;
        if ( new_tail == (struct dict_node *)0 )
        \{
            curr       = names_dict;
            names_dict = (struct dict_node *)0;
        \}
        else
        \{
            curr           = new_tail->next;
            new_tail->next = (struct dict_node *)0;
        \}

        for ( ; curr != (struct dict_node *)0; curr = next )
        \{
            next = curr->next;
            free((char *)curr->name);
            free(curr);
        \}
    \}
\}

\nwendcode{}\nwbegindocs{14}\nwdocspar
In order to cleanup the dictionary after a garbage collection and
update all pointers in the control stack, the function
{\Tt{}cleanup{\_}names\nwendquote} should be used. This function looks for dictionary
nodes which point to no node at all and release the memory occupied by
them. In addition, the saved dictionary tails on the control stack
are moved to the previous node which is still in use.

The processing is performed in three steps. First the dictionary list
is reversed (in order to be able to advance the dictionary pointers
backwards). In a next step the choicepoints and search contexts in the
control stack are processed from top to bottom and all dictionary
pointers are set to the next dictionary node with a non-null node
pointer. In the last phase, the dictionary list is reversed again and
all nodes which do not point to a node are released.

\ToDo{We can speed up the second phase a bit by making use of the fact
the many choicepoints will save the same dictionary. We only need to
find the next used dictionary for the first choicepoint in such a
sequence and can re-use the new dictionary tail for all these
choicepoints.}

\nwenddocs{}\nwbegincode{15}\sublabel{NWqGiTS-3X3XIp-4}\nwmargintag{{\nwtagstyle{}\subpageref{NWqGiTS-3X3XIp-4}}}\moddef{vars.h~{\nwtagstyle{}\subpageref{NWqGiTS-3X3XIp-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NWqGiTS-3X3XIp-3}{NWqGiTS-3X3XIp-5}\nwenddeflinemarkup
extern void cleanup_names(void);

\nwendcode{}\nwbegindocs{16}\nwdocspar
\nwenddocs{}\nwbegincode{17}\sublabel{NWqGiTS-1Uspz9-5}\nwmargintag{{\nwtagstyle{}\subpageref{NWqGiTS-1Uspz9-5}}}\moddef{vars.c~{\nwtagstyle{}\subpageref{NWqGiTS-1Uspz9-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NWqGiTS-1Uspz9-4}{NWqGiTS-1Uspz9-6}\nwenddeflinemarkup
void
cleanup_names()
\{
    struct dict_node *prev, *curr, *next;
    Choicepoint      *cp;

    /* Phase I: reverse the dictionary */
    prev = (struct dict_node *)0;
    for ( curr = names_dict; curr != (struct dict_node *)0; curr = next )
    \{
        next       = curr->next;
        curr->next = prev;
        prev       = curr;
    \}

    /* Phase II: update the control stack */
    for ( cp = bp; cp != (Choicepoint *)0; cp = cp->btBp )
    \{
        curr = cp->btDict;
        while ( curr != (struct dict_node *)0 && curr->node == (Node *)0 )
            curr = curr->next;
        cp->btDict = curr;
    \}

    /* Phase III: re-reverse the dictionary and release unused nodes */
    curr = prev;
    prev = (struct dict_node *)0;
    for ( ; curr != (struct dict_node *)0; curr = next )
    \{
        next = curr->next;
        if ( curr->node == (Node *)0 )
        \{
            free((char *)curr->name);
            free(curr);
        \}
        else
        \{
            curr->next = prev;
            prev       = curr;
        \}
    \}
    names_dict = prev;
\}

\nwendcode{}\nwbegindocs{18}\nwdocspar
The function {\Tt{}lookup{\_}name\nwendquote} returns the name of the given (variable)
node from the dictionary. If there is no name in the dictionary, a new
name is created with the help of the local function {\Tt{}gen{\_}name\nwendquote}.

\nwenddocs{}\nwbegincode{19}\sublabel{NWqGiTS-3X3XIp-5}\nwmargintag{{\nwtagstyle{}\subpageref{NWqGiTS-3X3XIp-5}}}\moddef{vars.h~{\nwtagstyle{}\subpageref{NWqGiTS-3X3XIp-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NWqGiTS-3X3XIp-4}{\relax}\nwenddeflinemarkup
extern const char *lookup_name(Node *node);

\nwendcode{}\nwbegindocs{20}\nwdocspar
\nwenddocs{}\nwbegincode{21}\sublabel{NWqGiTS-1Uspz9-6}\nwmargintag{{\nwtagstyle{}\subpageref{NWqGiTS-1Uspz9-6}}}\moddef{vars.c~{\nwtagstyle{}\subpageref{NWqGiTS-1Uspz9-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NWqGiTS-1Uspz9-5}{NWqGiTS-1Uspz9-7}\nwenddeflinemarkup
static const char *gen_name(void);

extern const char *lookup_name(Node *node)
\{
    const char       *name;
    struct dict_node *dict;

    for ( dict = names_dict; dict != (struct dict_node *)0; dict = dict->next )
        if ( dict->node == node )
            return dict->name;

    name = gen_name();
    add_name(node, name);
    return name;
\}

\nwendcode{}\nwbegindocs{22}\nwdocspar
The private function {\Tt{}gen{\_}name\nwendquote} uses the counter {\Tt{}dict{\_}index\nwendquote} in
order to create unique names. In order to avoid name conflicts with
entities defined in the program, all generated names start with an
underscore.

\ToDo{Provide a runtime option is to use either uppercase or lowercase
names for generated names.}

\ToDo{The counter should be reset when the dictionary is released
during backtracking.}

\nwenddocs{}\nwbegincode{23}\sublabel{NWqGiTS-1Uspz9-7}\nwmargintag{{\nwtagstyle{}\subpageref{NWqGiTS-1Uspz9-7}}}\moddef{vars.c~{\nwtagstyle{}\subpageref{NWqGiTS-1Uspz9-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NWqGiTS-1Uspz9-6}{\relax}\nwenddeflinemarkup
static unsigned long dict_index;

static const char *
gen_name()
\{
    char name[13];

    name[0] = '_';
    name[1] = 'a' + dict_index % 26;
    if ( dict_index < 26 )
        name[2] = '\\0';
    else
        sprintf(name + 2, "%ld", dict_index / 26);
    dict_index++;

    return (const char *)strdup(name);
\}
\nwendcode{}

\nwixlogsorted{c}{{vars.c}{NWqGiTS-1Uspz9-1}{\nwixd{NWqGiTS-1Uspz9-1}\nwixd{NWqGiTS-1Uspz9-2}\nwixd{NWqGiTS-1Uspz9-3}\nwixd{NWqGiTS-1Uspz9-4}\nwixd{NWqGiTS-1Uspz9-5}\nwixd{NWqGiTS-1Uspz9-6}\nwixd{NWqGiTS-1Uspz9-7}}}%
\nwixlogsorted{c}{{vars.h}{NWqGiTS-3X3XIp-1}{\nwixd{NWqGiTS-3X3XIp-1}\nwixd{NWqGiTS-3X3XIp-2}\nwixd{NWqGiTS-3X3XIp-3}\nwixd{NWqGiTS-3X3XIp-4}\nwixd{NWqGiTS-3X3XIp-5}}}%

