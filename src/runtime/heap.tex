\nwfilename{heap.nw}\nwbegindocs{0}% -*- noweb-code-mode: c-mode -*-% ===> this file was generated automatically by noweave --- better not edit it
% $Id: heap.nw,v 2.15 2004/05/01 13:18:14 wlux Exp $
%
% Copyright (c) 2001-2004, Wolfgang Lux
% See ../LICENSE for the full license.
%
\subsection{The Heap}
\nwenddocs{}\nwbegincode{1}\sublabel{NW14geTF-2OfYFn-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW14geTF-2OfYFn-1}}}\moddef{heap.c~{\nwtagstyle{}\subpageref{NW14geTF-2OfYFn-1}}}\endmoddef\nwstartdeflinemarkup\nwprevnextdefs{\relax}{NW14geTF-2OfYFn-2}\nwenddeflinemarkup
#include "config.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "run.h"
#include "heap.h"
#include "eval.h"

\nwalsodefined{\\{NW14geTF-2OfYFn-2}\\{NW14geTF-2OfYFn-3}\\{NW14geTF-2OfYFn-4}\\{NW14geTF-2OfYFn-5}\\{NW14geTF-2OfYFn-6}\\{NW14geTF-2OfYFn-7}\\{NW14geTF-2OfYFn-8}\\{NW14geTF-2OfYFn-9}\\{NW14geTF-2OfYFn-A}\\{NW14geTF-2OfYFn-B}\\{NW14geTF-2OfYFn-C}\\{NW14geTF-2OfYFn-D}\\{NW14geTF-2OfYFn-E}}\nwnotused{heap.c}\nwendcode{}\nwbegindocs{2}\nwdocspar
The abstract machine operates on a graph in the heap. All nodes of the
graph, except for integer numbers, are blocks allocated in
the heap. The heap is organized as an array of words, where a word
corresponds to the size of a pointer or (long) integer number --
32 bits on a 32-bit architecture.

\nwenddocs{}\nwbegincode{3}\sublabel{NW14geTF-MUqw7-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW14geTF-MUqw7-1}}}\moddef{heap.h~{\nwtagstyle{}\subpageref{NW14geTF-MUqw7-1}}}\endmoddef\nwstartdeflinemarkup\nwprevnextdefs{\relax}{NW14geTF-MUqw7-2}\nwenddeflinemarkup
/* booleans */
#ifndef __cplusplus
typedef enum bool \{ false, true \} boolean;
#else
# define boolean bool
#endif /*__cplusplus*/

/* words */
#define word_size       sizeof(word)
#define wordsof(x)      ((sizeof(x) + word_size - 1) / word_size)

typedef void *word;

\nwalsodefined{\\{NW14geTF-MUqw7-2}\\{NW14geTF-MUqw7-3}\\{NW14geTF-MUqw7-4}\\{NW14geTF-MUqw7-5}\\{NW14geTF-MUqw7-6}\\{NW14geTF-MUqw7-7}\\{NW14geTF-MUqw7-8}\\{NW14geTF-MUqw7-9}\\{NW14geTF-MUqw7-A}\\{NW14geTF-MUqw7-B}\\{NW14geTF-MUqw7-C}\\{NW14geTF-MUqw7-D}\\{NW14geTF-MUqw7-E}\\{NW14geTF-MUqw7-F}\\{NW14geTF-MUqw7-G}\\{NW14geTF-MUqw7-H}\\{NW14geTF-MUqw7-I}\\{NW14geTF-MUqw7-J}\\{NW14geTF-MUqw7-K}\\{NW14geTF-MUqw7-L}\\{NW14geTF-MUqw7-M}\\{NW14geTF-MUqw7-N}\\{NW14geTF-MUqw7-O}\\{NW14geTF-MUqw7-P}\\{NW14geTF-MUqw7-Q}\\{NW14geTF-MUqw7-R}\\{NW14geTF-MUqw7-S}\\{NW14geTF-MUqw7-T}}\nwnotused{heap.h}\nwendcode{}\nwbegindocs{4}\nwdocspar
Except if disabled by using the \texttt{--disable-unboxed}
configuration option, the runtime system uses an unboxed
representation for integer numbers. In this case the value of the
number is encoded directly in the pointer. In order to distinguish
unboxed values from regular pointers, the least significant bit of the
pointer is set. The remaining bits of the pointer contain the value.

\nwenddocs{}\nwbegincode{5}\sublabel{NW14geTF-MUqw7-2}\nwmargintag{{\nwtagstyle{}\subpageref{NW14geTF-MUqw7-2}}}\moddef{heap.h~{\nwtagstyle{}\subpageref{NW14geTF-MUqw7-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW14geTF-MUqw7-1}{NW14geTF-MUqw7-3}\nwenddeflinemarkup
/* unboxed objects */
#if !ONLY_BOXED_OBJECTS
# define IF_UNBOXED(unboxed,boxed) unboxed
#else
# define IF_UNBOXED(unboxed,boxed) boxed
#endif

/* check for boxed-ness of a node */
#define is_unboxed(node)        IF_UNBOXED(((long)(node) & 0x01), 0)
#define is_boxed(node)          !is_unboxed(node)

#if !ONLY_BOXED_OBJECTS
# define mk_unboxed(x)          (Node *)(((x) << 1) | 0x01)
# define unboxed_val(node)      ((long)(node) >> 1)
#endif

\nwendcode{}\nwbegindocs{6}\nwdocspar
All other objects are stored as nodes in the heap. The first word of a
node is a node descriptor that includes, among other things, a tag
number. This number is used to distinguish the different kinds of
nodes and in particular the different data constructors in an
algebraic data type. Non-negative tags are used for data constructors
and negative values are reserved for special node types defined by
the runtime system. All tags less than or equal to {\Tt{}ABSTRACT{\_}TAG\nwendquote}
can be used to implement references to external data, e.g., files. The
runtime system will never duplicate such nodes and use physical
equality when comparing them in equality and disequality constraints.

\nwenddocs{}\nwbegincode{7}\sublabel{NW14geTF-MUqw7-3}\nwmargintag{{\nwtagstyle{}\subpageref{NW14geTF-MUqw7-3}}}\moddef{heap.h~{\nwtagstyle{}\subpageref{NW14geTF-MUqw7-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW14geTF-MUqw7-2}{NW14geTF-MUqw7-4}\nwenddeflinemarkup
/* tag values */
enum \{
    ABSTRACT_TAG    = -13,      /* external objects */
    SCRIPT_TAG      = -12,      /* saved script/trail */
    THREAD_TAG      = -11,      /* threadqueue node */
    CHAR_TAG        = -10,      /* character node */
    INT_TAG         = -9,       /* integer number */
    FLOAT_TAG       = -8,       /* floating-point number */
    PAPP_TAG        = -7,       /* partial application node */
    CLOSURE_TAG     = -6,       /* closure node */
    SEARCH_CONT_TAG = -5,       /* search continuation */
    VARIABLE_TAG    = -4,       /* (unbound) logic variable */
    QUEUEME_TAG     = -3,       /* locked suspended application node */
    SUSPEND_TAG     = -2,       /* suspended application node */
    INDIR_TAG       = -1        /* indirection node */
\};

\nwendcode{}\nwbegindocs{8}\nwdocspar
The {\Tt{}Node\nwendquote} type is declared as a union of the various alternative
representations. The first field of the variants as well as of the
union itself is the {\Tt{}info\nwendquote} field which points to the node
descriptor. The descriptor comprises the tag number, the length of the
node in words, a pointer offset table, the evaluation code for the
node, a name, and an optional finalization function.

The length of the node includes the descriptor pointer; a valid size
must therefore be greater than 0. A length of 0 is used for objects
with variable sizes. In this case, the runtime system expects the
length of the node in the first word after the info pointer in the
node itself (see also the description of vectors below).

The pointer offset table is used by the garbage collector to
distinguish pointer and non-pointer fields in a node. The table starts
with the number of pointer fields in the node. Their offsets within
the node are saved in the following entries. All offsets in the table
must be defined in units of {\Tt{}word{\_}size\nwendquote}. The macro {\Tt{}word{\_}offsetof\nwendquote}
can be used to compute them. In order to simplify the common case of
nodes where all fields may contain valid pointers, a 0-pointer can be
used for the offset table in this case. The runtime system also
pre-allocates the trivial offset table for purely binary nodes. It can
be accessed through the global variable {\Tt{}ot{\_}binary\nwendquote}.

Vector nodes require some special treatment. If the elements of the
vector have some internal structure that requires a non-trivial offset
table, the first entry of the offset table must contain the negative
size of an element. The size is then followed by the number of pointer
fields in an element and their offsets.

\nwenddocs{}\nwbegincode{9}\sublabel{NW14geTF-MUqw7-4}\nwmargintag{{\nwtagstyle{}\subpageref{NW14geTF-MUqw7-4}}}\moddef{heap.h~{\nwtagstyle{}\subpageref{NW14geTF-MUqw7-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW14geTF-MUqw7-3}{NW14geTF-MUqw7-5}\nwenddeflinemarkup
/* node types -- defined below */
typedef union node          Node;
typedef struct node_info    NodeInfo;
typedef union thread_node   *ThreadQueue;       /* defined in threads.h */
typedef struct search_space SearchSpace;        /* defined in spaces.h */
typedef struct constraint   Constraint;
typedef void (*FinalFun)(Node *);

struct node_info
\{
    const int          tag;             /* tag number */
    const unsigned int length;          /* length of the node */
    const int          *offset_table;   /* pointer offset table */
    const Label        eval;            /* entrypoint for evaluation */
    const char         *cname;          /* constructor name */
    const FinalFun     final_fun;       /* optional finalization function */
\};

#define node_tag(node)          (node)->info->tag
#define node_size(node)         (node)->info->length
#define is_constr_node(node)    (node_tag(node) >= 0)
#define is_char_node(node)      (node_tag(node) == CHAR_TAG)
#define is_int_node(node) \\
    IF_UNBOXED(is_unboxed(node), (node_tag(node) == INT_TAG))
#define is_float_node(node)     (node_tag(node) == FLOAT_TAG)
#define is_papp_node(node)      (node_tag(node) == PAPP_TAG)
#define is_closure_node(node)   (node_tag(node) == CLOSURE_TAG)
#define is_variable_node(node)  (node_tag(node) == VARIABLE_TAG)
#define is_suspend_node(node)   (node_tag(node) == SUSPEND_TAG)
#define is_queueMe_node(node)   (node_tag(node) == QUEUEME_TAG)
#define is_indir_node(node)     (node_tag(node) == INDIR_TAG)
#define is_search_cont_node(node) (node_tag(node) == SEARCH_CONT_TAG)
#define is_abstract_node(node)  (node_tag(node) <= ABSTRACT_TAG)

#define word_offsetof(type,field) \\
    (int)((word *)&(((type *)0)->field) - (word *)0)

extern const int ot_binary[];

\nwendcode{}\nwbegindocs{10}\nwdocspar
\nwenddocs{}\nwbegincode{11}\sublabel{NW14geTF-2OfYFn-2}\nwmargintag{{\nwtagstyle{}\subpageref{NW14geTF-2OfYFn-2}}}\moddef{heap.c~{\nwtagstyle{}\subpageref{NW14geTF-2OfYFn-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW14geTF-2OfYFn-1}{NW14geTF-2OfYFn-3}\nwenddeflinemarkup
const int ot_binary[] = \{ 0 \};

\nwendcode{}\nwbegindocs{12}\nwdocspar
Data constructor applications are represented by {\Tt{}constr{\_}node\nwendquote}s.
They consist of an info pointer and a list of arguments which may be
empty. Constant data constructors are pre-allocated by the compiler,
whereas all other applications are allocated in the heap.

\nwenddocs{}\nwbegincode{13}\sublabel{NW14geTF-MUqw7-5}\nwmargintag{{\nwtagstyle{}\subpageref{NW14geTF-MUqw7-5}}}\moddef{heap.h~{\nwtagstyle{}\subpageref{NW14geTF-MUqw7-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW14geTF-MUqw7-4}{NW14geTF-MUqw7-6}\nwenddeflinemarkup
struct constr_node \{
    NodeInfo *info;
    Node     *args[1];
\};

#define constr_argc(node)       (node_size(node) - 1)
#define constr_node_size(argc)  ((argc) + 1)

\nwendcode{}\nwbegindocs{14}\nwdocspar
Lists and tuples are special cases of data constructors that are
pre-allocated in the runtime system.

In order to support the printing code, the runtime system implements
two predicates {\Tt{}is{\_}tuple\nwendquote} and {\Tt{}is{\_}operator\nwendquote} that check whether a
node info corresponds to a tuple and operator, respectively. The
function {\Tt{}is{\_}tuple\nwendquote} returns {\Tt{}true\nwendquote}, if the name consists of a
(non-empty) sequence of commas which are enclosed in parentheses. The
function {\Tt{}is{\_}operator\nwendquote} returns {\Tt{}true\nwendquote}, if the name contains any
non-alphanumeric characters except for {\Tt{}'\nwendquote} and {\Tt{}{\_}\nwendquote}. Dots ({\Tt{}.\nwendquote}) %'
that precede an alphanumeric character are ignored because they are
assumed to separate a module qualifier from the unqualified name. Note
that the empty list and unit constructors are not considered as
operator names.

\nwenddocs{}\nwbegincode{15}\sublabel{NW14geTF-MUqw7-6}\nwmargintag{{\nwtagstyle{}\subpageref{NW14geTF-MUqw7-6}}}\moddef{heap.h~{\nwtagstyle{}\subpageref{NW14geTF-MUqw7-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW14geTF-MUqw7-5}{NW14geTF-MUqw7-7}\nwenddeflinemarkup
#define NIL_TAG  ___91__93__tag
#define CONS_TAG ___58__tag
#define UNIT_TAG ___40__41__tag
#define SUCCESS_TAG __Success_tag

#define nil_node_size     constr_node_size(0)
#define cons_node_size    constr_node_size(2)
#define unit_node_size    constr_node_size(0)
#define success_node_size constr_node_size(0)

enum \{ NIL_TAG, CONS_TAG \};
enum \{ UNIT_TAG \};
enum \{ SUCCESS_TAG \};

extern NodeInfo ___91__93__info, ___58__info;
extern NodeInfo ___40__41__info;
extern NodeInfo __Success_info;
extern NodeInfo *___91__93__node, *___40__41__node;
extern NodeInfo *__Success_node;

#define nil  (Node *)&___91__93__node
#define unit (Node *)&___40__41__node
#define Success (Node *)&__Success_node
#define cons_info ___58__info

extern boolean is_tuple(const NodeInfo *info);
extern boolean is_operator(const NodeInfo *info);

\nwendcode{}\nwbegindocs{16}\nwdocspar
\nwenddocs{}\nwbegincode{17}\sublabel{NW14geTF-2OfYFn-3}\nwmargintag{{\nwtagstyle{}\subpageref{NW14geTF-2OfYFn-3}}}\moddef{heap.c~{\nwtagstyle{}\subpageref{NW14geTF-2OfYFn-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW14geTF-2OfYFn-2}{NW14geTF-2OfYFn-4}\nwenddeflinemarkup
NodeInfo ___91__93__info = \{
    NIL_TAG, nil_node_size, (const int *)0, (Label)eval_whnf, "[]", (FinalFun)0
\};
NodeInfo ___58__info = \{
    CONS_TAG, cons_node_size, (const int *)0, (Label)eval_whnf, ":", (FinalFun)0
\};
NodeInfo ___40__41__info = \{
    UNIT_TAG, unit_node_size, (const int *)0, (Label)eval_whnf, "()", (FinalFun)0
\};
NodeInfo __Success_info = \{
    SUCCESS_TAG, success_node_size, (const int *)0, (Label)eval_whnf, "Success",
    (FinalFun)0
\};

NodeInfo *___91__93__node = &___91__93__info;
NodeInfo *___40__41__node = &___40__41__info;
NodeInfo *__Success_node  = &__Success_info;

boolean
is_tuple(const NodeInfo *info)
\{
    const char *cp = info->cname;

    if ( *cp++ != '(' || *cp++ != ',' )
        return false;
    while ( *cp == ',' )
        cp++;
    return *cp++ == ')' && *cp == '\\0';
\}

boolean
is_operator(const NodeInfo *info)
\{
    const char *cp;

    if ( info == &___91__93__info || info == &___40__41__info )
        return false;

    for ( cp = info->cname; *cp != '\\0'; cp++ )
    \{
        if ( *cp == '.' )
            cp++;
        if ( !isalnum(*cp) && *cp != '\\'' && *cp != '_' )
            return true;
        else if ( *cp == '_' )
        \{
            if ( cp[1] == '#' )
                cp++;
            else if ( strncmp(cp + 1, "debug#", 6) )
                cp += 6;
        \}
    \}
    return false;
\}

\nwendcode{}\nwbegindocs{18}\nwdocspar
Vectors differ from tuples in that the size of a vector cannot be
determined from its type at compile time, but only at runtime when the
vector is actually allocated. Therefore, the size of a vector node
cannot be saved in its descriptor, but is saved in the first word of
the node after the info pointer.

\nwenddocs{}\nwbegincode{19}\sublabel{NW14geTF-MUqw7-7}\nwmargintag{{\nwtagstyle{}\subpageref{NW14geTF-MUqw7-7}}}\moddef{heap.h~{\nwtagstyle{}\subpageref{NW14geTF-MUqw7-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW14geTF-MUqw7-6}{NW14geTF-MUqw7-8}\nwenddeflinemarkup
struct vector_node \{
    NodeInfo *info;
    unsigned length;
    Node     *args[1];
\};

#define is_vector(node) ((node)->info->length == 0)
#define vector_argc(node) \\
    (((struct vector_node *)(node))->length - vector_node_size(0))
#define vector_node_size(argc) \\
    (wordsof(struct vector_node) + (argc) - 1)

\nwendcode{}\nwbegindocs{20}\nwdocspar
The following macros can be used in the program to define data
constructors. These macros implicitly pre-allocate a node for constant
constructors. Note that this node has the type {\Tt{}struct\ closure{\_}node\nwendquote}
because it is not possible to use a static initializer for a {\Tt{}union\nwendquote}
in ANSI C.

\nwenddocs{}\nwbegincode{21}\sublabel{NW14geTF-MUqw7-8}\nwmargintag{{\nwtagstyle{}\subpageref{NW14geTF-MUqw7-8}}}\moddef{heap.h~{\nwtagstyle{}\subpageref{NW14geTF-MUqw7-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW14geTF-MUqw7-7}{NW14geTF-MUqw7-9}\nwenddeflinemarkup
#define DECLARE_CONST(name) \\
DECLARE_DATA(name); \\
extern NodeInfo *name##_node

#define DECLARE_DATA(name) \\
extern NodeInfo name##_info

#define DECLARE_VECTOR(name) \\
DECLARE_DATA(name)

#define DEFINE_CONST(name,cname,tag) \\
DEFINE_DATA(name,cname,tag,0); \\
NodeInfo *name##_node = &name##_info

#define DEFINE_DATA(name,cname,tag,arity) \\
NodeInfo name##_info = \{ \\
    tag, constr_node_size(arity), (const int *)0, (Label)eval_whnf, cname, \\
    (FinalFun)0 \\
\}

#define DEFINE_VECTOR(name,cname,tag) \\
NodeInfo name##_info = \{ \\
    tag, 0, (const int *)0, (Label)eval_whnf, cname, (FinalFun)0 \\
\}

\nwendcode{}\nwbegindocs{22}\nwdocspar
Usually, integer numbers are stored as unboxed objects. In boxed mode,
an integer node consists of the tag and the integer value.

\nwenddocs{}\nwbegincode{23}\sublabel{NW14geTF-MUqw7-9}\nwmargintag{{\nwtagstyle{}\subpageref{NW14geTF-MUqw7-9}}}\moddef{heap.h~{\nwtagstyle{}\subpageref{NW14geTF-MUqw7-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW14geTF-MUqw7-8}{NW14geTF-MUqw7-A}\nwenddeflinemarkup
#if ONLY_BOXED_OBJECTS
extern NodeInfo int_info;
struct int_node \{
    NodeInfo *info;
    long int i;
\};
# define int_node_size          wordsof(struct int_node)
# define int_val(node)          (node)->i.i
#else
# define mk_int(i)              mk_unboxed(i)
# define int_node_size          0
# define int_val(node)          unboxed_val(node)
#endif

\nwendcode{}\nwbegindocs{24}\nwdocspar
\nwenddocs{}\nwbegincode{25}\sublabel{NW14geTF-2OfYFn-4}\nwmargintag{{\nwtagstyle{}\subpageref{NW14geTF-2OfYFn-4}}}\moddef{heap.c~{\nwtagstyle{}\subpageref{NW14geTF-2OfYFn-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW14geTF-2OfYFn-3}{NW14geTF-2OfYFn-5}\nwenddeflinemarkup
#if ONLY_BOXED_OBJECTS
NodeInfo int_info = \{ 
    INT_TAG, int_node_size, ot_binary, (Label)eval_whnf, (const char *)0, (FinalFun)0
\};
#endif

\nwendcode{}\nwbegindocs{26}\nwdocspar
Floating point numbers use type {\Tt{}double\nwendquote} for the represented number
to get the maximum precision. On some architectures values of this
type must be aligned on a double word boundary. As nodes in the heap
are aligned to a word boundary only, floating point values in a heap
node cannot be accessed directly in this case. The macros
{\Tt{}get{\_}float{\_}val\nwendquote} and {\Tt{}put{\_}float{\_}val\nwendquote} can be used for accessing
unaligned {\Tt{}double\nwendquote} values.

\emph{Do not replace the assignments in {\Tt{}get{\_}float{\_}val\nwendquote} and
{\Tt{}put{\_}float{\_}val\nwendquote} by a single call to {\Tt{}memcpy\nwendquote}. The Gnu C compiler
may generate inline code for {\Tt{}memcpy\nwendquote} when it is called with a fixed
size and may use floating-point instructions, which expect properly
aligned operands, in order to copy a {\Tt{}double\nwendquote} sized memory
region. Such happens, e.g., on the Sparc architecture.}

\nwenddocs{}\nwbegincode{27}\sublabel{NW14geTF-MUqw7-A}\nwmargintag{{\nwtagstyle{}\subpageref{NW14geTF-MUqw7-A}}}\moddef{heap.h~{\nwtagstyle{}\subpageref{NW14geTF-MUqw7-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW14geTF-MUqw7-9}{NW14geTF-MUqw7-B}\nwenddeflinemarkup
extern NodeInfo float_info;
struct float_node \{
    NodeInfo *info;
    double   d;
\};
#define float_node_size         wordsof(struct float_node)

#if UNALIGNED_DOUBLE
# define get_float_val(_d,node) _d = (node).d
# define put_float_val(node,_d) (node).d = _d
#else
union _conv \{
    double d;
    long   l[2];
\};

# define get_float_val(_d,node) do \{ \\
    union _conv conv; \\
    conv.l[0] = ((long *)&(node).d)[0]; \\
    conv.l[1] = ((long *)&(node).d)[1]; \\
    _d = conv.d; \\
\} while ( 0 )
# define put_float_val(node,_d) do \{ \\
    union _conv conv; \\
    conv.d = _d; \\
    ((long *)&(node).d)[0] = conv.l[0]; \\
    ((long *)&(node).d)[1] = conv.l[1]; \\
\} while ( 0 )
#endif

\nwendcode{}\nwbegindocs{28}\nwdocspar
\nwenddocs{}\nwbegincode{29}\sublabel{NW14geTF-20zlE5-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW14geTF-20zlE5-1}}}\moddef{Global variables~{\nwtagstyle{}\subpageref{NW14geTF-20zlE5-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW14geTF-2OfYFn-A}}\nwenddeflinemarkup
NodeInfo float_info = \{
    FLOAT_TAG, float_node_size, ot_binary, (Label)eval_whnf, (const char *)0,
    (FinalFun)0
\};

\nwused{\\{NW14geTF-2OfYFn-A}}\nwendcode{}\nwbegindocs{30}\nwdocspar
Character nodes are mostly similar to (boxed) integer nodes. However,
the characters in the range 0--255 are preallocated in the runtime
system.

\nwenddocs{}\nwbegincode{31}\sublabel{NW14geTF-MUqw7-B}\nwmargintag{{\nwtagstyle{}\subpageref{NW14geTF-MUqw7-B}}}\moddef{heap.h~{\nwtagstyle{}\subpageref{NW14geTF-MUqw7-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW14geTF-MUqw7-A}{NW14geTF-MUqw7-C}\nwenddeflinemarkup
extern NodeInfo char_info;
struct char_node \{
    NodeInfo *info;
    int ch;
\};

#define char_node_size          wordsof(struct char_node)

extern struct char_node char_table[256];
extern void init_chars(void);

\nwendcode{}\nwbegincode{32}\sublabel{NW14geTF-2OfYFn-5}\nwmargintag{{\nwtagstyle{}\subpageref{NW14geTF-2OfYFn-5}}}\moddef{heap.c~{\nwtagstyle{}\subpageref{NW14geTF-2OfYFn-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW14geTF-2OfYFn-4}{NW14geTF-2OfYFn-6}\nwenddeflinemarkup
NodeInfo char_info = \{
    CHAR_TAG, char_node_size, ot_binary, (Label)eval_whnf, (const char *)0,
    (FinalFun)0
\};

struct char_node char_table[256];

void
init_chars()
\{
    int i;

    for (i = 0; i < 256; i++ )
    \{
        char_table[i].info = &char_info;
        char_table[i].ch = i;
    \}
\}

\nwendcode{}\nwbegindocs{33}\nwdocspar
Closure nodes are allocated for all functions. Closure nodes use an
extended node info which, in addition to the standard fields, contains
the entry-point and arity of the function. Partial and full
applications can be distinguished by their tag values {\Tt{}PAPP{\_}TAG\nwendquote} and
{\Tt{}CLOSURE{\_}TAG\nwendquote}, respectively.

\nwenddocs{}\nwbegincode{34}\sublabel{NW14geTF-MUqw7-C}\nwmargintag{{\nwtagstyle{}\subpageref{NW14geTF-MUqw7-C}}}\moddef{heap.h~{\nwtagstyle{}\subpageref{NW14geTF-MUqw7-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW14geTF-MUqw7-B}{NW14geTF-MUqw7-D}\nwenddeflinemarkup
typedef struct function_info \{
    const NodeInfo     node_info;       /* common fields */
    const Label        entry;           /* entry-point of the function */
    const unsigned int arity;           /* arity of the function */
\} FunctionInfo;

struct closure_node \{
    FunctionInfo *info;
    Node         *args[1];              /* arguments */
\};
#define closure_argc(node)      (node_size(node) - closure_node_size(0))
#define closure_node_size(argc) (wordsof(struct closure_node) + (argc-1))

\nwendcode{}\nwbegindocs{35}\nwdocspar
For a function, an info vector has to be defined for each arity at
which the function can be applied. These info vectors are allocated in
an array in ascending order with respect to the number of arguments.
The following macros can be used to define these vector tables. They
presume the existence of an entry-point for evaluating a (fully
applied) closure node, whose name is derived by adding the suffix
{\Tt{}{\_}eval\nwendquote} to the name of the entry-point.

\nwenddocs{}\nwbegincode{36}\sublabel{NW14geTF-MUqw7-D}\nwmargintag{{\nwtagstyle{}\subpageref{NW14geTF-MUqw7-D}}}\moddef{heap.h~{\nwtagstyle{}\subpageref{NW14geTF-MUqw7-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW14geTF-MUqw7-C}{NW14geTF-MUqw7-E}\nwenddeflinemarkup
#define FUNINFO(fname,entrypoint,arity) \\
\{ \{ CLOSURE_TAG, closure_node_size(arity), (const int *)0, entrypoint##_eval, \\
    fname, (FinalFun)0 \}, entrypoint, arity \}

#define PAPPINFO(fname,argc,entrypoint,arity) \\
\{ \{ PAPP_TAG, closure_node_size(argc), (const int *)0, eval_whnf, fname, \\
    (FinalFun)0 \}, entrypoint, arity \},

\nwendcode{}\nwbegindocs{37}\nwdocspar
Unbound logic variables comprise a list of suspended threads, which
must be woken after the variable is bound, and a pointer to the search
space in which the variable was created. In addition, a list of
constraints (other than equality constraints, which are implemented by
overwriting the variable node) can be attached to a variable.

\nwenddocs{}\nwbegincode{38}\sublabel{NW14geTF-MUqw7-E}\nwmargintag{{\nwtagstyle{}\subpageref{NW14geTF-MUqw7-E}}}\moddef{heap.h~{\nwtagstyle{}\subpageref{NW14geTF-MUqw7-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW14geTF-MUqw7-D}{NW14geTF-MUqw7-F}\nwenddeflinemarkup
extern NodeInfo variable_info;
struct variable_node \{
    NodeInfo    *info;
    Constraint  *cstrs;         /* constraint list */
    ThreadQueue wq;             /* wait queue */
    SearchSpace *spc;           /* defining search space */
\};
#define variable_node_size      wordsof(struct variable_node)

\nwendcode{}\nwbegindocs{39}\nwdocspar
\nwenddocs{}\nwbegincode{40}\sublabel{NW14geTF-2OfYFn-6}\nwmargintag{{\nwtagstyle{}\subpageref{NW14geTF-2OfYFn-6}}}\moddef{heap.c~{\nwtagstyle{}\subpageref{NW14geTF-2OfYFn-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW14geTF-2OfYFn-5}{NW14geTF-2OfYFn-7}\nwenddeflinemarkup
NodeInfo variable_info = \{
    VARIABLE_TAG, variable_node_size, (const int *)0, (Label)eval_whnf,
    (const char *)0, (FinalFun)0
\};

\nwendcode{}\nwbegindocs{41}\nwdocspar
At present, the abstract machine supports only disequality constraints.
However, we implement are more generic interface for constraints here.
A list of constraints can be attached to a variable node. The {\Tt{}eval\nwendquote}
field in the node info structure of a constraint is used to point to a
binary function that is called when the variable is bound and that
checks whether the bound value is compatible with the constraint. Both
arguments are passed to the function on the data stack with the bound
value on the top of the stack.

\nwenddocs{}\nwbegincode{42}\sublabel{NW14geTF-MUqw7-F}\nwmargintag{{\nwtagstyle{}\subpageref{NW14geTF-MUqw7-F}}}\moddef{heap.h~{\nwtagstyle{}\subpageref{NW14geTF-MUqw7-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW14geTF-MUqw7-E}{NW14geTF-MUqw7-G}\nwenddeflinemarkup
extern NodeInfo constraint_info;
struct constraint \{
    NodeInfo   *info;
    Constraint *cstrs;          /* link to next constraint or 0 */
\};

\nwendcode{}\nwbegindocs{43}\nwdocspar
Suspended application nodes are composed of a pointer to the closure
which has to be evaluated and a pointer to the search space in which
the node was created. When the evaluation of a suspended application
is started, it is changed into a queue-me node that prevents other
threads from evaluating the node as well.

\nwenddocs{}\nwbegincode{44}\sublabel{NW14geTF-MUqw7-G}\nwmargintag{{\nwtagstyle{}\subpageref{NW14geTF-MUqw7-G}}}\moddef{heap.h~{\nwtagstyle{}\subpageref{NW14geTF-MUqw7-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW14geTF-MUqw7-F}{NW14geTF-MUqw7-H}\nwenddeflinemarkup
struct suspend_node \{
    NodeInfo    *info;
    Node        *fn;            /* pointer to function node */
    SearchSpace *spc;           /* defining search space */
\};
#define suspend_node_size       wordsof(struct suspend_node)

extern NodeInfo queueMe_info;
struct queueMe_node \{
    NodeInfo    *info;
    ThreadQueue wq;             /* pointer to waitqueue */
    SearchSpace *spc;           /* defining search space */
\};
#define queueMe_node_size       wordsof(struct queueMe_node)

\nwendcode{}\nwbegindocs{45}\nwdocspar
\nwenddocs{}\nwbegincode{46}\sublabel{NW14geTF-2OfYFn-7}\nwmargintag{{\nwtagstyle{}\subpageref{NW14geTF-2OfYFn-7}}}\moddef{heap.c~{\nwtagstyle{}\subpageref{NW14geTF-2OfYFn-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW14geTF-2OfYFn-6}{NW14geTF-2OfYFn-8}\nwenddeflinemarkup
NodeInfo queueMe_info = \{
    QUEUEME_TAG, queueMe_node_size, (const int *)0, (Label)eval_queueMe,
    (const char *)0, (FinalFun)0
\};

\nwendcode{}\nwbegindocs{47}\nwdocspar
Besides the info table, a descriptor for suspended application nodes
must be provided for every function. The following macro can be used
for that purpose. It assumes that the entry-point is named by adding
the suffix {\Tt{}{\_}lazy\nwendquote} to the name of function's entry-point.                  %'

\nwenddocs{}\nwbegincode{48}\sublabel{NW14geTF-MUqw7-H}\nwmargintag{{\nwtagstyle{}\subpageref{NW14geTF-MUqw7-H}}}\moddef{heap.h~{\nwtagstyle{}\subpageref{NW14geTF-MUqw7-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW14geTF-MUqw7-G}{NW14geTF-MUqw7-I}\nwenddeflinemarkup
#define SUSPINFO(entrypoint) \{ \\
    SUSPEND_TAG, suspend_node_size, (const int *)0, entrypoint##_lazy, \\
    (const char *)0, (FinalFun)0 \\
\}

\nwendcode{}\nwbegindocs{49}\nwdocspar
Indirection nodes are used in order to preserve sharing when a
variable node is bound and a suspended application is overwritten with
its result, respectively. This is done by changing the info vector of
the node and setting the {\Tt{}node\nwendquote} field in the indirection node. In
order to ensure proper operation of the garbage collector, the size in
the info vector of the indirection node must be the same as that of
the overwritten node. This means that different info vectors for
variable and suspension nodes have to be used. Indirection nodes are
also used in order to create cyclic data structures in a \verb|letrec|
expression.

\nwenddocs{}\nwbegincode{50}\sublabel{NW14geTF-MUqw7-I}\nwmargintag{{\nwtagstyle{}\subpageref{NW14geTF-MUqw7-I}}}\moddef{heap.h~{\nwtagstyle{}\subpageref{NW14geTF-MUqw7-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW14geTF-MUqw7-H}{NW14geTF-MUqw7-J}\nwenddeflinemarkup
extern NodeInfo indir_info, suspend_indir_info, variable_indir_info;
struct indir_node \{
    NodeInfo *info;
    Node     *node;
\};
#define indir_node_size         wordsof(struct indir_node)

\nwendcode{}\nwbegindocs{51}\nwdocspar
\nwenddocs{}\nwbegincode{52}\sublabel{NW14geTF-2OfYFn-8}\nwmargintag{{\nwtagstyle{}\subpageref{NW14geTF-2OfYFn-8}}}\moddef{heap.c~{\nwtagstyle{}\subpageref{NW14geTF-2OfYFn-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW14geTF-2OfYFn-7}{NW14geTF-2OfYFn-9}\nwenddeflinemarkup
NodeInfo indir_info = \{
    INDIR_TAG, indir_node_size, (const int *)0, (Label)eval_indir, (const char *)0,
    (FinalFun)0
\};
NodeInfo suspend_indir_info = \{
    INDIR_TAG, suspend_node_size, (const int *)0, (Label)eval_indir, (const char *)0,
    (FinalFun)0
\};
NodeInfo variable_indir_info = \{
    INDIR_TAG, variable_node_size, (const int *)0, (Label)eval_indir, (const char *)0,
    (FinalFun)0
\};

\nwendcode{}\nwbegindocs{53}\nwdocspar
Search continuations.

\nwenddocs{}\nwbegincode{54}\sublabel{NW14geTF-MUqw7-J}\nwmargintag{{\nwtagstyle{}\subpageref{NW14geTF-MUqw7-J}}}\moddef{heap.h~{\nwtagstyle{}\subpageref{NW14geTF-MUqw7-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW14geTF-MUqw7-I}{NW14geTF-MUqw7-K}\nwenddeflinemarkup
extern NodeInfo search_cont_info;
struct search_cont_node \{
    NodeInfo    *info;
    Label       code;           /* next instruction to be executed */
    Node        *susp;          /* suspended goal application */
    Node        *var;           /* goal variable */
    Node        *ds;            /* saved data stack */
    ThreadQueue rq;             /* saved ready queue */
    SearchSpace *spc;           /* local space of the continuation */
\};
#define search_cont_node_size   wordsof(struct search_cont_node)

\nwendcode{}\nwbegindocs{55}\nwdocspar
\nwenddocs{}\nwbegincode{56}\sublabel{NW14geTF-2OfYFn-9}\nwmargintag{{\nwtagstyle{}\subpageref{NW14geTF-2OfYFn-9}}}\moddef{heap.c~{\nwtagstyle{}\subpageref{NW14geTF-2OfYFn-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW14geTF-2OfYFn-8}{NW14geTF-2OfYFn-A}\nwenddeflinemarkup
NodeInfo search_cont_info = \{
    SEARCH_CONT_TAG, search_cont_node_size, (const int *)0, (Label)no_eval,
    "<state>", (FinalFun)0
\};

\nwendcode{}\nwbegindocs{57}\nwdocspar
Combined node type.

\nwenddocs{}\nwbegincode{58}\sublabel{NW14geTF-MUqw7-K}\nwmargintag{{\nwtagstyle{}\subpageref{NW14geTF-MUqw7-K}}}\moddef{heap.h~{\nwtagstyle{}\subpageref{NW14geTF-MUqw7-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW14geTF-MUqw7-J}{NW14geTF-MUqw7-L}\nwenddeflinemarkup
union node \{
    NodeInfo *info;
    struct char_node ch;
#if ONLY_BOXED_OBJECTS
    struct int_node i;
#endif
    struct float_node f;
    struct constr_node c;
    struct vector_node a;
    struct variable_node v;
    struct suspend_node s;
    struct queueMe_node q;
    struct indir_node n;
    struct closure_node cl;
    struct search_cont_node sc;
\};

\nwendcode{}\nwbegindocs{59}\nwdocspar
The heap is organized as a large array of words starting at
{\Tt{}heap{\_}base\nwendquote} with its top at {\Tt{}heap{\_}end\nwendquote}. The current allocation
pointer into the heap is kept in the variable {\Tt{}hp\nwendquote}, which
corresponds to the abstract machine register with the same name. The
variable {\Tt{}hlim\nwendquote} saves the value of the allocation pointer at the
time when the current choicepoint or search context was created. It is
used to avoid trailing of variables and suspended applications that
are younger than the current choicepoint.

\nwenddocs{}\nwbegincode{60}\sublabel{NW14geTF-MUqw7-L}\nwmargintag{{\nwtagstyle{}\subpageref{NW14geTF-MUqw7-L}}}\moddef{heap.h~{\nwtagstyle{}\subpageref{NW14geTF-MUqw7-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW14geTF-MUqw7-K}{NW14geTF-MUqw7-M}\nwenddeflinemarkup
extern word *hp, *hlim;
extern word *heap_base, *heap_end;

\nwendcode{}\nwbegindocs{61}\nwdocspar
\nwenddocs{}\nwbegincode{62}\sublabel{NW14geTF-2OfYFn-A}\nwmargintag{{\nwtagstyle{}\subpageref{NW14geTF-2OfYFn-A}}}\moddef{heap.c~{\nwtagstyle{}\subpageref{NW14geTF-2OfYFn-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW14geTF-2OfYFn-9}{NW14geTF-2OfYFn-B}\nwenddeflinemarkup
word *hp;
word *hlim;
word *heap_base;
word *heap_end;

\LA{}Global variables~{\nwtagstyle{}\subpageref{NW14geTF-20zlE5-1}}\RA{}

\nwendcode{}\nwbegindocs{63}\nwdocspar
Allocation is performed simply by incrementing the allocation pointer
by the appropriate amount. Before any allocation is performed, it
should be checked that enough words are still available in the heap.
Otherwise, the garbage collector must be called first. The macro
{\Tt{}CHECK{\_}HEAP\nwendquote} can be used for that purpose. The {\Tt{}collect\nwendquote} function
is passed the number of additional words that are required. If this
amount is not available after the collection, the program will be
aborted. The global flag {\Tt{}in{\_}gc\nwendquote} is set while the garbage collector
is executing.

\nwenddocs{}\nwbegincode{64}\sublabel{NW14geTF-MUqw7-M}\nwmargintag{{\nwtagstyle{}\subpageref{NW14geTF-MUqw7-M}}}\moddef{heap.h~{\nwtagstyle{}\subpageref{NW14geTF-MUqw7-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW14geTF-MUqw7-L}{NW14geTF-MUqw7-N}\nwenddeflinemarkup
extern boolean in_gc;
extern void collect(unsigned int);
#define CHECK_HEAP(n) do \{ if ( hp + (n) > heap_end ) collect(n); \} while ( 0 )

\nwendcode{}\nwbegindocs{65}\nwdocspar
\nwenddocs{}\nwbegincode{66}\sublabel{NW14geTF-2OfYFn-B}\nwmargintag{{\nwtagstyle{}\subpageref{NW14geTF-2OfYFn-B}}}\moddef{heap.c~{\nwtagstyle{}\subpageref{NW14geTF-2OfYFn-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW14geTF-2OfYFn-A}{NW14geTF-2OfYFn-C}\nwenddeflinemarkup
boolean in_gc = false;

\nwendcode{}\nwbegindocs{67}\nwdocspar
In order to find all live nodes during a garbage collection, the
garbage collector must know \emph{all} external roots into the
graph. The compiler ensures that all nodes which are used by the
program can be found via the abstract machine's registers. However,
roots in foreign code are not known to the compiler and must be
registered explicitly. The runtime system maintains two global lists
rooted in the variables {\Tt{}local{\_}roots\nwendquote} and {\Tt{}global{\_}roots\nwendquote},
respectively, for this purpose. The list {\Tt{}local{\_}roots\nwendquote} is intended
for registering temporary variables inside a function, whereas
{\Tt{}global{\_}roots\nwendquote} is intended for global variables whose livetime
extends beyond a function invocation.                                        %'

The list rooted in {\Tt{}global{\_}roots\nwendquote} is implemented as a simple linked
list containing the addresses of the additional roots. The
variable {\Tt{}local{\_}roots\nwendquote} points to an array of node pointers where the
first element contains the number of roots plus 1 and the second
element is a back link to the previous value of {\Tt{}local{\_}roots\nwendquote}. This
allows registering more than one local variable in a single step.

\nwenddocs{}\nwbegincode{68}\sublabel{NW14geTF-MUqw7-N}\nwmargintag{{\nwtagstyle{}\subpageref{NW14geTF-MUqw7-N}}}\moddef{heap.h~{\nwtagstyle{}\subpageref{NW14geTF-MUqw7-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW14geTF-MUqw7-M}{NW14geTF-MUqw7-O}\nwenddeflinemarkup
typedef struct global_root \{
    struct global_root *next;
    Node           **root;
\} GlobalRoot;
extern GlobalRoot *global_roots;
extern Node       **local_roots;

\nwendcode{}\nwbegindocs{69}\nwdocspar
\nwenddocs{}\nwbegincode{70}\sublabel{NW14geTF-2OfYFn-C}\nwmargintag{{\nwtagstyle{}\subpageref{NW14geTF-2OfYFn-C}}}\moddef{heap.c~{\nwtagstyle{}\subpageref{NW14geTF-2OfYFn-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW14geTF-2OfYFn-B}{NW14geTF-2OfYFn-D}\nwenddeflinemarkup
Node       **local_roots;
GlobalRoot *global_roots;

\nwendcode{}\nwbegindocs{71}\nwdocspar
Local variables in a function can be registered using the macros
{\Tt{}ADD{\_}LOCAL{\_}ROOTS\nwendquote}$n$ and unregistered with {\Tt{}DROP{\_}LOCAL{\_}ROOTS\nwendquote}. The
{\Tt{}ADD{\_}LOCAL{\_}ROOTS\nwendquote}$n$ macro, where $n$ is the number of local
variables, must be inserted between the declarations and the first
statement of a function. The {\Tt{}DROP{\_}LOCAL{\_}ROOTS\nwendquote} macro can be
inserted into the code whenever the protected variables are no longer
used. Note that all elements of the array must be initialized by the
function before the first allocation. The local variables can be
accessed using the macro {\Tt{}LOCAL{\_}ROOT\nwendquote} with offsets starting at zero.

\nwenddocs{}\nwbegincode{72}\sublabel{NW14geTF-MUqw7-O}\nwmargintag{{\nwtagstyle{}\subpageref{NW14geTF-MUqw7-O}}}\moddef{heap.h~{\nwtagstyle{}\subpageref{NW14geTF-MUqw7-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW14geTF-MUqw7-N}{NW14geTF-MUqw7-P}\nwenddeflinemarkup
#define LOCAL_ROOT_NODE __additional_roots__

#define DECLARE_LOCAL_ROOTS(n) \\
    Node *LOCAL_ROOT_NODE[(n)+2]; \\
    LOCAL_ROOT_NODE[0] = (Node *)n; \\
    LOCAL_ROOT_NODE[1] = (Node *)local_roots; \\
    local_roots = LOCAL_ROOT_NODE

#define ADD_LOCAL_ROOTS1(x) \\
    DECLARE_LOCAL_ROOTS(1); \\
    LOCAL_ROOT_NODE[2] = x
#define ADD_LOCAL_ROOTS2(x,y) \\
    DECLARE_LOCAL_ROOTS(2); \\
    LOCAL_ROOT_NODE[2] = x; \\
    LOCAL_ROOT_NODE[3] = y
#define ADD_LOCAL_ROOTS3(x,y,z) \\
    DECLARE_LOCAL_ROOTS(3); \\
    LOCAL_ROOT_NODE[2] = x; \\
    LOCAL_ROOT_NODE[3] = y; \\
    LOCAL_ROOT_NODE[4] = z

#define DROP_LOCAL_ROOTS() local_roots = (Node **)LOCAL_ROOT_NODE[1]

#define LOCAL_ROOT (LOCAL_ROOT_NODE+2)

\nwendcode{}\nwbegindocs{73}\nwdocspar
Global roots can be registered with the function {\Tt{}add{\_}global{\_}root\nwendquote}.
If a global root is no longer used, it can be released by calling
{\Tt{}remove{\_}global{\_}root\nwendquote} for it.

\emph{Make sure that the binding of a global root remains valid
after backtracking and when an encapsulated search fails.}

\nwenddocs{}\nwbegincode{74}\sublabel{NW14geTF-MUqw7-P}\nwmargintag{{\nwtagstyle{}\subpageref{NW14geTF-MUqw7-P}}}\moddef{heap.h~{\nwtagstyle{}\subpageref{NW14geTF-MUqw7-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW14geTF-MUqw7-O}{NW14geTF-MUqw7-Q}\nwenddeflinemarkup
extern void add_global_root(Node **root);
extern void remove_global_root(Node **root);

\nwendcode{}\nwbegindocs{75}\nwdocspar
\nwenddocs{}\nwbegincode{76}\sublabel{NW14geTF-2OfYFn-D}\nwmargintag{{\nwtagstyle{}\subpageref{NW14geTF-2OfYFn-D}}}\moddef{heap.c~{\nwtagstyle{}\subpageref{NW14geTF-2OfYFn-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW14geTF-2OfYFn-C}{NW14geTF-2OfYFn-E}\nwenddeflinemarkup
void
add_global_root(Node **root)
\{
    GlobalRoot *head;

    head = (GlobalRoot *)malloc(sizeof(GlobalRoot));
    if ( head == (GlobalRoot *)0 )
    \{
        fprintf(stderr, "Out of memory in add_global_root\\n");
        exit(1);
    \}

    head->next   = global_roots;
    head->root   = root;
    global_roots = head;
\}

void
remove_global_root(Node **root)
\{
    GlobalRoot *prev, *curr;

    for ( prev = (GlobalRoot *)0, curr = global_roots;
          curr != (GlobalRoot *)0;
          prev = curr, curr = curr->next )
        if ( curr->root == root )
        \{
            if ( prev != (GlobalRoot *)0 )
                prev->next = curr->next;
            else
                global_roots = curr->next;
            free(curr);
            return;
        \}

    fprintf(stderr, "remove_global_root: %p not registered as a root\\n", root);
    exit(1);
\}

\nwendcode{}\nwbegindocs{77}\nwdocspar
All nodes that require finalization may have to be registered with the
garbage collector. In particular, this is necessary for the two-space
copying collector which traverses only the live cells.

\nwenddocs{}\nwbegincode{78}\sublabel{NW14geTF-MUqw7-Q}\nwmargintag{{\nwtagstyle{}\subpageref{NW14geTF-MUqw7-Q}}}\moddef{heap.h~{\nwtagstyle{}\subpageref{NW14geTF-MUqw7-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW14geTF-MUqw7-P}{NW14geTF-MUqw7-R}\nwenddeflinemarkup
extern void register_final(Node *node);

\nwendcode{}\nwbegindocs{79}\nwdocspar
When a computation fails, all memory above the current heap limit
becomes garbage immediately. The function {\Tt{}release{\_}mem\nwendquote} can be used
to clean up the memory in this case. In particular, the finalization
function of all objects allocated in this region of the heap is called
and the heap pointer {\Tt{}hp\nwendquote} is reset to the heap limit {\Tt{}hlim\nwendquote}.

\nwenddocs{}\nwbegincode{80}\sublabel{NW14geTF-MUqw7-R}\nwmargintag{{\nwtagstyle{}\subpageref{NW14geTF-MUqw7-R}}}\moddef{heap.h~{\nwtagstyle{}\subpageref{NW14geTF-MUqw7-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW14geTF-MUqw7-Q}{NW14geTF-MUqw7-S}\nwenddeflinemarkup
extern void release_mem(void);

\nwendcode{}\nwbegindocs{81}\nwdocspar
The initialization function is reponsible for the initialization of
the heap. Because the initialization depends on the garbage collector
being used, this function must be implemented by the garbage
collector.

\nwenddocs{}\nwbegincode{82}\sublabel{NW14geTF-MUqw7-S}\nwmargintag{{\nwtagstyle{}\subpageref{NW14geTF-MUqw7-S}}}\moddef{heap.h~{\nwtagstyle{}\subpageref{NW14geTF-MUqw7-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW14geTF-MUqw7-R}{NW14geTF-MUqw7-T}\nwenddeflinemarkup
extern void init_heap(unsigned long);

\nwendcode{}\nwbegindocs{83}\nwdocspar
The function {\Tt{}heap{\_}exhausted\nwendquote} is used to terminate the program if
not enough space is available after a garbage collection.

\nwenddocs{}\nwbegincode{84}\sublabel{NW14geTF-MUqw7-T}\nwmargintag{{\nwtagstyle{}\subpageref{NW14geTF-MUqw7-T}}}\moddef{heap.h~{\nwtagstyle{}\subpageref{NW14geTF-MUqw7-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW14geTF-MUqw7-S}{\relax}\nwenddeflinemarkup
extern void heap_exhausted(void) __attribute__ ((noreturn));

\nwendcode{}\nwbegindocs{85}\nwdocspar
\nwenddocs{}\nwbegincode{86}\sublabel{NW14geTF-2OfYFn-E}\nwmargintag{{\nwtagstyle{}\subpageref{NW14geTF-2OfYFn-E}}}\moddef{heap.c~{\nwtagstyle{}\subpageref{NW14geTF-2OfYFn-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW14geTF-2OfYFn-D}{\relax}\nwenddeflinemarkup
void
heap_exhausted()
\{
    fprintf(stderr,
            "not enough free memory in heap after garbage collection\\n");
    exit(1);
\}
\nwendcode{}

\nwixlogsorted{c}{{Global variables}{NW14geTF-20zlE5-1}{\nwixd{NW14geTF-20zlE5-1}\nwixu{NW14geTF-2OfYFn-A}}}%
\nwixlogsorted{c}{{heap.c}{NW14geTF-2OfYFn-1}{\nwixd{NW14geTF-2OfYFn-1}\nwixd{NW14geTF-2OfYFn-2}\nwixd{NW14geTF-2OfYFn-3}\nwixd{NW14geTF-2OfYFn-4}\nwixd{NW14geTF-2OfYFn-5}\nwixd{NW14geTF-2OfYFn-6}\nwixd{NW14geTF-2OfYFn-7}\nwixd{NW14geTF-2OfYFn-8}\nwixd{NW14geTF-2OfYFn-9}\nwixd{NW14geTF-2OfYFn-A}\nwixd{NW14geTF-2OfYFn-B}\nwixd{NW14geTF-2OfYFn-C}\nwixd{NW14geTF-2OfYFn-D}\nwixd{NW14geTF-2OfYFn-E}}}%
\nwixlogsorted{c}{{heap.h}{NW14geTF-MUqw7-1}{\nwixd{NW14geTF-MUqw7-1}\nwixd{NW14geTF-MUqw7-2}\nwixd{NW14geTF-MUqw7-3}\nwixd{NW14geTF-MUqw7-4}\nwixd{NW14geTF-MUqw7-5}\nwixd{NW14geTF-MUqw7-6}\nwixd{NW14geTF-MUqw7-7}\nwixd{NW14geTF-MUqw7-8}\nwixd{NW14geTF-MUqw7-9}\nwixd{NW14geTF-MUqw7-A}\nwixd{NW14geTF-MUqw7-B}\nwixd{NW14geTF-MUqw7-C}\nwixd{NW14geTF-MUqw7-D}\nwixd{NW14geTF-MUqw7-E}\nwixd{NW14geTF-MUqw7-F}\nwixd{NW14geTF-MUqw7-G}\nwixd{NW14geTF-MUqw7-H}\nwixd{NW14geTF-MUqw7-I}\nwixd{NW14geTF-MUqw7-J}\nwixd{NW14geTF-MUqw7-K}\nwixd{NW14geTF-MUqw7-L}\nwixd{NW14geTF-MUqw7-M}\nwixd{NW14geTF-MUqw7-N}\nwixd{NW14geTF-MUqw7-O}\nwixd{NW14geTF-MUqw7-P}\nwixd{NW14geTF-MUqw7-Q}\nwixd{NW14geTF-MUqw7-R}\nwixd{NW14geTF-MUqw7-S}\nwixd{NW14geTF-MUqw7-T}}}%

