\nwfilename{stats.nw}\nwbegindocs{0}% -*- noweb-code-mode: c-mode -*-% ===> this file was generated automatically by noweave --- better not edit it
% $Id: stats.nw,v 2.3 2003/09/19 13:09:27 wlux Exp $
%
% Copyright (c) 2002, Wolfgang Lux
% See ../LICENSE for the full license.
%
\subsection{Gathering statistical information}
The compiled Curry program is able to gather some timing information
and memory allocation statistics. The interface to this module
consists of five functions. The function {\Tt{}stats{\_}init\nwendquote} will
initialize the module. The argument determines the amount of
information displayed. The function {\Tt{}stats{\_}terminate\nwendquote} prints the
final statistics when the program has finished. The functions
{\Tt{}stats{\_}begin{\_}gc\nwendquote} and {\Tt{}stats{\_}end{\_}gc\nwendquote} switch between normal program
execution and garbage collection for gathering the statistics. In
addition, they expect the amount of allocated memory as
arguments. Space which is freed by backtracking is recorded by the
function {\Tt{}stats{\_}backtrack\nwendquote}.

\nwenddocs{}\nwbegincode{1}\sublabel{NW1Wf9SV-3UHgrJ-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW1Wf9SV-3UHgrJ-1}}}\moddef{stats.h~{\nwtagstyle{}\subpageref{NW1Wf9SV-3UHgrJ-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
extern void stats_init(int on);
extern void stats_terminate(unsigned long allocated);

extern void stats_begin_gc(unsigned long allocated);
extern void stats_end_gc(unsigned long allocated);

extern void stats_backtrack(unsigned long freed);

\nwnotused{stats.h}\nwendcode{}\nwbegindocs{2}\nwdocspar
The implementation of the statistics module is pretty straight
forward. In order to determine the expired run-time we will use the
{\Tt{}rusage\nwendquote} function which is usually defined in the header file
{\Tt{}sys/resource.h\nwendquote} together with the necessary constants.

\nwenddocs{}\nwbegincode{3}\sublabel{NW1Wf9SV-rmKtN-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW1Wf9SV-rmKtN-1}}}\moddef{stats.c~{\nwtagstyle{}\subpageref{NW1Wf9SV-rmKtN-1}}}\endmoddef\nwstartdeflinemarkup\nwprevnextdefs{\relax}{NW1Wf9SV-rmKtN-2}\nwenddeflinemarkup
#include "config.h"
#include <stdio.h>
#include <sys/time.h>
#include <sys/resource.h>
#include "stats.h"

\LA{}Function prototypes~{\nwtagstyle{}\subpageref{NW1Wf9SV-G7sOC-1}}\RA{}
\LA{}Global variables~{\nwtagstyle{}\subpageref{NW1Wf9SV-20zlE5-1}}\RA{}

\nwalsodefined{\\{NW1Wf9SV-rmKtN-2}\\{NW1Wf9SV-rmKtN-3}\\{NW1Wf9SV-rmKtN-4}\\{NW1Wf9SV-rmKtN-5}\\{NW1Wf9SV-rmKtN-6}}\nwnotused{stats.c}\nwendcode{}\nwbegindocs{4}\nwdocspar
The amount of statistics to be presented is determined by the variable
{\Tt{}show{\_}stats\nwendquote}. If it is 0, nothing will be shown at all, if is 1 the
total execution time and garbage collector information is presented at
the end of the run and if it is larger, information about allocated
memory and live memory will be shown at every garbage collection, too.

\nwenddocs{}\nwbegincode{5}\sublabel{NW1Wf9SV-20zlE5-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW1Wf9SV-20zlE5-1}}}\moddef{Global variables~{\nwtagstyle{}\subpageref{NW1Wf9SV-20zlE5-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW1Wf9SV-rmKtN-1}}\nwprevnextdefs{\relax}{NW1Wf9SV-20zlE5-2}\nwenddeflinemarkup
static int show_stats;

\nwalsodefined{\\{NW1Wf9SV-20zlE5-2}\\{NW1Wf9SV-20zlE5-3}\\{NW1Wf9SV-20zlE5-4}}\nwused{\\{NW1Wf9SV-rmKtN-1}}\nwendcode{}\nwbegindocs{6}\nwdocspar
Timing information will be divided into the execution time in user
space during (normal) program execution, execution time in user space
during garbage collection, and system time for the whole program. The
times are computed with the help of the function {\Tt{}rusage\nwendquote}, which
returns user and system time information since the program start. In
addition, the elapsed wall clock time is computed using
{\Tt{}gettimeofday\nwendquote}.

\nwenddocs{}\nwbegincode{7}\sublabel{NW1Wf9SV-20zlE5-2}\nwmargintag{{\nwtagstyle{}\subpageref{NW1Wf9SV-20zlE5-2}}}\moddef{Global variables~{\nwtagstyle{}\subpageref{NW1Wf9SV-20zlE5-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW1Wf9SV-rmKtN-1}}\nwprevnextdefs{NW1Wf9SV-20zlE5-1}{NW1Wf9SV-20zlE5-3}\nwenddeflinemarkup
static struct timeval user_time, gc_time, sys_time, real_time;

\nwused{\\{NW1Wf9SV-rmKtN-1}}\nwendcode{}\nwbegindocs{8}\nwdocspar
Concerning memory allocation the statistics module computes the number
of allocated \emph{words} and the average number of live words during
each garbage collection. Because these numbers can become quite large,
we use variables of type {\Tt{}long\ long\nwendquote} here.

\nwenddocs{}\nwbegincode{9}\sublabel{NW1Wf9SV-20zlE5-3}\nwmargintag{{\nwtagstyle{}\subpageref{NW1Wf9SV-20zlE5-3}}}\moddef{Global variables~{\nwtagstyle{}\subpageref{NW1Wf9SV-20zlE5-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW1Wf9SV-rmKtN-1}}\nwprevnextdefs{NW1Wf9SV-20zlE5-2}{NW1Wf9SV-20zlE5-4}\nwenddeflinemarkup
unsigned long      n_gc;
unsigned long long total_collect, total_release, total_live;

\nwused{\\{NW1Wf9SV-rmKtN-1}}\nwendcode{}\nwbegindocs{10}\nwdocspar
The function {\Tt{}stats{\_}init\nwendquote} saves its argument in the global variable
{\Tt{}show{\_}stats\nwendquote} and computes the initial timing information. The time
spent in the initialization code will be added as a negative offset
for the collect user mode and system mode times. For that reason
{\Tt{}stats{\_}init\nwendquote} should be called after all other initializations have
been performed.

\nwenddocs{}\nwbegincode{11}\sublabel{NW1Wf9SV-rmKtN-2}\nwmargintag{{\nwtagstyle{}\subpageref{NW1Wf9SV-rmKtN-2}}}\moddef{stats.c~{\nwtagstyle{}\subpageref{NW1Wf9SV-rmKtN-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW1Wf9SV-rmKtN-1}{NW1Wf9SV-rmKtN-3}\nwenddeflinemarkup
void
stats_init(int level)
\{
    struct rusage  ru;
    struct timeval tv;
    show_stats = level;

    gettimeofday(&tv, (struct timezone *)0);
    getrusage(RUSAGE_SELF, &ru);
    sub_timeval(&user_time, ru.ru_utime);
    sub_timeval(&sys_time, ru.ru_stime);
    sub_timeval(&real_time, tv);
\}

\nwendcode{}\nwbegindocs{12}\nwdocspar
At the end of the program, {\Tt{}stats{\_}terminate\nwendquote} is used to display the
statistics information collected during the program. We assume here
that this function is called on regular termination of the program,
i.e., this call will always happen in normal execution mode and not in
garbage collection mode. 

\nwenddocs{}\nwbegincode{13}\sublabel{NW1Wf9SV-rmKtN-3}\nwmargintag{{\nwtagstyle{}\subpageref{NW1Wf9SV-rmKtN-3}}}\moddef{stats.c~{\nwtagstyle{}\subpageref{NW1Wf9SV-rmKtN-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW1Wf9SV-rmKtN-2}{NW1Wf9SV-rmKtN-4}\nwenddeflinemarkup
void
stats_terminate(unsigned long allocated)
\{
    struct rusage      ru;
    struct timeval     tv;
    unsigned long long total_alloc;

    gettimeofday(&tv, (struct timezone *)0);
    getrusage(RUSAGE_SELF, &ru);
    add_timeval(&user_time, ru.ru_utime);
    add_timeval(&sys_time, ru.ru_stime);
    add_timeval(&real_time, tv);

    total_alloc = allocated + total_collect + total_release;

    if ( show_stats > 0 )
    \{
        fprintf(stderr,
                "[user: %lu.%03us, gc: %lu.%03us,"
                " sys: %lu.%03us, real: %lu.%03us]\\n",
                (unsigned long)user_time.tv_sec,
                (unsigned)user_time.tv_usec / 1000,
                (unsigned long)gc_time.tv_sec,
                (unsigned)gc_time.tv_usec / 1000,
                (unsigned long)sys_time.tv_sec,
                (unsigned)sys_time.tv_usec / 1000,
                (unsigned long)real_time.tv_sec,
                (unsigned)real_time.tv_usec / 1000);

        fprintf(stderr, "[%llu words allocated", total_alloc);
        if ( n_gc > 0 )
            fprintf(stderr,
                    ", %lu collection%s copying %llu words (%.2g%% live)",
                    n_gc, n_gc > 1 ? "s" : "", total_live,
                    (double)total_live / (total_live + total_collect) * 100);
        fprintf(stderr, "]\\n");
    \}
\}

\nwendcode{}\nwbegindocs{14}\nwdocspar
The functions {\Tt{}stats{\_}begin{\_}gc\nwendquote} and {\Tt{}stats{\_}end{\_}gc\nwendquote} update the
timing information appropriately at the beginning and end of a garbage
collection. In addition, the allocation counts are updated with the
arguments passed to the functions. Note that only the cells that have
been freed by the garbage collection are actually added to number of
allocated cells. This will ensure that every live cell is counted only
once, viz. when the cell is finally freed. For that reason, the
{\Tt{}stats{\_}terminate\nwendquote} function had to update the allocation count with
the number of cells that are still allocated when the program
terminates.

If the value {\Tt{}show{\_}stats\nwendquote} is greater than 1, information about the
number of allocated and freed words is displayed to the user at the
end of a collection.

\nwenddocs{}\nwbegincode{15}\sublabel{NW1Wf9SV-20zlE5-4}\nwmargintag{{\nwtagstyle{}\subpageref{NW1Wf9SV-20zlE5-4}}}\moddef{Global variables~{\nwtagstyle{}\subpageref{NW1Wf9SV-20zlE5-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW1Wf9SV-rmKtN-1}}\nwprevnextdefs{NW1Wf9SV-20zlE5-3}{\relax}\nwenddeflinemarkup
static unsigned long n_alloc_before_gc;

\nwused{\\{NW1Wf9SV-rmKtN-1}}\nwendcode{}\nwbegindocs{16}\nwdocspar
\nwenddocs{}\nwbegincode{17}\sublabel{NW1Wf9SV-rmKtN-4}\nwmargintag{{\nwtagstyle{}\subpageref{NW1Wf9SV-rmKtN-4}}}\moddef{stats.c~{\nwtagstyle{}\subpageref{NW1Wf9SV-rmKtN-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW1Wf9SV-rmKtN-3}{NW1Wf9SV-rmKtN-5}\nwenddeflinemarkup
void
stats_begin_gc(unsigned long n_alloc)
\{
    struct rusage ru;

    getrusage(RUSAGE_SELF, &ru);
    add_timeval(&user_time, ru.ru_utime);
    sub_timeval(&gc_time, ru.ru_utime);

    n_alloc_before_gc = n_alloc;
    if ( show_stats > 1 )
        fprintf(stderr, "<GC: ");
\}

void
stats_end_gc(unsigned long n_alloc)
\{
    struct rusage ru;

    n_gc++;
    total_collect += n_alloc_before_gc - n_alloc;
    total_live    += n_alloc;

    getrusage(RUSAGE_SELF, &ru);
    add_timeval(&gc_time, ru.ru_utime);
    sub_timeval(&user_time, ru.ru_utime);

    if ( show_stats > 1 )
        fprintf(stderr, "%lu live words, %lu words freed>\\n",
                n_alloc, n_alloc_before_gc - n_alloc);
\}

\nwendcode{}\nwbegindocs{18}\nwdocspar
The function {\Tt{}stats{\_}backtrack\nwendquote} only has to update the number of
allocated words.

\nwenddocs{}\nwbegincode{19}\sublabel{NW1Wf9SV-rmKtN-5}\nwmargintag{{\nwtagstyle{}\subpageref{NW1Wf9SV-rmKtN-5}}}\moddef{stats.c~{\nwtagstyle{}\subpageref{NW1Wf9SV-rmKtN-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW1Wf9SV-rmKtN-4}{NW1Wf9SV-rmKtN-6}\nwenddeflinemarkup
void
stats_backtrack(unsigned long n_freed)
\{
    total_release += n_freed;
\}

\nwendcode{}\nwbegindocs{20}\nwdocspar
Unix systems usually do not provide any functions to compute the sum
or difference of two {\Tt{}timeval\nwendquote}s. The statistics module therefore
implements its own functions for that purpose. Note that the micro
seconds part will always be a positive number in the range between 0
and 999999.

\nwenddocs{}\nwbegincode{21}\sublabel{NW1Wf9SV-G7sOC-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW1Wf9SV-G7sOC-1}}}\moddef{Function prototypes~{\nwtagstyle{}\subpageref{NW1Wf9SV-G7sOC-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW1Wf9SV-rmKtN-1}}\nwenddeflinemarkup
static void add_timeval(struct timeval *, struct timeval);
static void sub_timeval(struct timeval *, struct timeval);

\nwused{\\{NW1Wf9SV-rmKtN-1}}\nwendcode{}\nwbegindocs{22}\nwdocspar
\nwenddocs{}\nwbegincode{23}\sublabel{NW1Wf9SV-rmKtN-6}\nwmargintag{{\nwtagstyle{}\subpageref{NW1Wf9SV-rmKtN-6}}}\moddef{stats.c~{\nwtagstyle{}\subpageref{NW1Wf9SV-rmKtN-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW1Wf9SV-rmKtN-5}{\relax}\nwenddeflinemarkup
static void
add_timeval(struct timeval *p_tv1, struct timeval tv2)
\{
    p_tv1->tv_sec += tv2.tv_sec;
    p_tv1->tv_usec += tv2.tv_usec;
    if ( p_tv1->tv_usec >= 1000000 )
    \{
        p_tv1->tv_sec++;
        p_tv1->tv_usec -= 1000000;
    \}
\}

static void
sub_timeval(struct timeval *p_tv1, struct timeval tv2)
\{
    p_tv1->tv_sec -= tv2.tv_sec;
    if ( p_tv1->tv_usec >= tv2.tv_usec )
        p_tv1->tv_usec -= tv2.tv_usec;
    else
    \{
        p_tv1->tv_sec--;
        p_tv1->tv_usec += 1000000 - tv2.tv_usec;
    \}
\}
\nwendcode{}

\nwixlogsorted{c}{{Function prototypes}{NW1Wf9SV-G7sOC-1}{\nwixu{NW1Wf9SV-rmKtN-1}\nwixd{NW1Wf9SV-G7sOC-1}}}%
\nwixlogsorted{c}{{Global variables}{NW1Wf9SV-20zlE5-1}{\nwixu{NW1Wf9SV-rmKtN-1}\nwixd{NW1Wf9SV-20zlE5-1}\nwixd{NW1Wf9SV-20zlE5-2}\nwixd{NW1Wf9SV-20zlE5-3}\nwixd{NW1Wf9SV-20zlE5-4}}}%
\nwixlogsorted{c}{{stats.c}{NW1Wf9SV-rmKtN-1}{\nwixd{NW1Wf9SV-rmKtN-1}\nwixd{NW1Wf9SV-rmKtN-2}\nwixd{NW1Wf9SV-rmKtN-3}\nwixd{NW1Wf9SV-rmKtN-4}\nwixd{NW1Wf9SV-rmKtN-5}\nwixd{NW1Wf9SV-rmKtN-6}}}%
\nwixlogsorted{c}{{stats.h}{NW1Wf9SV-3UHgrJ-1}{\nwixd{NW1Wf9SV-3UHgrJ-1}}}%

