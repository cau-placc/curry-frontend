\nwfilename{eval.nw}\nwbegindocs{0}% -*- noweb-code-mode: c-mode -*-% ===> this file was generated automatically by noweave --- better not edit it
% $Id: eval.nw,v 2.15 2004/05/02 09:17:27 wlux Exp $
%
% Copyright (c) 2001-2004, Wolfgang Lux
% See ../LICENSE for the full license.
%
\subsection{Evaluation}\label{sec:eval}
Every node has an entry-point, which is called when the program has to
evaluate a node. The common entry-points are defined in this module,
entry-points for closures and suspended application nodes are
generated by the compiler. All entry-points are called with the node
to be evaluated on the top of the stack.

\nwenddocs{}\nwbegincode{1}\sublabel{NW2FT1VU-2P9Uvd-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2FT1VU-2P9Uvd-1}}}\moddef{eval.c~{\nwtagstyle{}\subpageref{NW2FT1VU-2P9Uvd-1}}}\endmoddef\nwstartdeflinemarkup\nwprevnextdefs{\relax}{NW2FT1VU-2P9Uvd-2}\nwenddeflinemarkup
#include "config.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "debug.h"
#include "run.h"
#include "heap.h"
#include "stack.h"
#include "trail.h"
#include "threads.h"
#include "spaces.h"
#include "trace.h"
#include "eval.h"
#include "cam.h"

\nwalsodefined{\\{NW2FT1VU-2P9Uvd-2}\\{NW2FT1VU-2P9Uvd-3}\\{NW2FT1VU-2P9Uvd-4}\\{NW2FT1VU-2P9Uvd-5}\\{NW2FT1VU-2P9Uvd-6}\\{NW2FT1VU-2P9Uvd-7}\\{NW2FT1VU-2P9Uvd-8}\\{NW2FT1VU-2P9Uvd-9}\\{NW2FT1VU-2P9Uvd-A}\\{NW2FT1VU-2P9Uvd-B}\\{NW2FT1VU-2P9Uvd-C}}\nwnotused{eval.c}\nwendcode{}\nwbegindocs{2}\nwdocspar
Some nodes, e.g. thread nodes, do not represent values and cannot be
evaluated at all. The entry-point {\Tt{}no{\_}eval\nwendquote} aborts the program if
such a node is ever entered.

\nwenddocs{}\nwbegincode{3}\sublabel{NW2FT1VU-KzbhV-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2FT1VU-KzbhV-1}}}\moddef{eval.h~{\nwtagstyle{}\subpageref{NW2FT1VU-KzbhV-1}}}\endmoddef\nwstartdeflinemarkup\nwprevnextdefs{\relax}{NW2FT1VU-KzbhV-2}\nwenddeflinemarkup
DECLARE_ENTRYPOINT(no_eval);

\nwalsodefined{\\{NW2FT1VU-KzbhV-2}\\{NW2FT1VU-KzbhV-3}\\{NW2FT1VU-KzbhV-4}\\{NW2FT1VU-KzbhV-5}\\{NW2FT1VU-KzbhV-6}\\{NW2FT1VU-KzbhV-7}}\nwnotused{eval.h}\nwendcode{}\nwbegindocs{4}\nwdocspar
\nwenddocs{}\nwbegincode{5}\sublabel{NW2FT1VU-2P9Uvd-2}\nwmargintag{{\nwtagstyle{}\subpageref{NW2FT1VU-2P9Uvd-2}}}\moddef{eval.c~{\nwtagstyle{}\subpageref{NW2FT1VU-2P9Uvd-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW2FT1VU-2P9Uvd-1}{NW2FT1VU-2P9Uvd-3}\nwenddeflinemarkup
FUNCTION(no_eval)
\{
    EXPORT_LABEL(no_eval)
 ENTRY_LABEL(no_eval)

    fprintf(stderr, "Internal error: this object should not be evaluated\\n");
    exit(9);
\}

\nwendcode{}\nwbegindocs{6}\nwdocspar
Numbers and data constructors are already in weak head normal form.
Their evaluation code, {\Tt{}eval{\_}whnf\nwendquote}, simply returns the node to the
caller.

\nwenddocs{}\nwbegincode{7}\sublabel{NW2FT1VU-KzbhV-2}\nwmargintag{{\nwtagstyle{}\subpageref{NW2FT1VU-KzbhV-2}}}\moddef{eval.h~{\nwtagstyle{}\subpageref{NW2FT1VU-KzbhV-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW2FT1VU-KzbhV-1}{NW2FT1VU-KzbhV-3}\nwenddeflinemarkup
DECLARE_ENTRYPOINT(eval_whnf);

\nwendcode{}\nwbegindocs{8}\nwdocspar
\nwenddocs{}\nwbegincode{9}\sublabel{NW2FT1VU-2P9Uvd-3}\nwmargintag{{\nwtagstyle{}\subpageref{NW2FT1VU-2P9Uvd-3}}}\moddef{eval.c~{\nwtagstyle{}\subpageref{NW2FT1VU-2P9Uvd-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW2FT1VU-2P9Uvd-2}{NW2FT1VU-2P9Uvd-4}\nwenddeflinemarkup
FUNCTION(eval_whnf)
\{
    Node *self;

    EXPORT_LABEL(eval_whnf)
 ENTRY_LABEL(eval_whnf)
    self = *sp++;
    RETURN(self);
\}

\nwendcode{}\nwbegindocs{10}\nwdocspar
An indirection node is evaluated by dereferencing the node and calling
the evaluation method of the referenced node. In order to speed up the
evaluation of indirection chains we use a loop that checks whether the
referenced node is itself an indirection node.  If the referenced node
is an unboxed integer number we return immediately to the caller.

\nwenddocs{}\nwbegincode{11}\sublabel{NW2FT1VU-KzbhV-3}\nwmargintag{{\nwtagstyle{}\subpageref{NW2FT1VU-KzbhV-3}}}\moddef{eval.h~{\nwtagstyle{}\subpageref{NW2FT1VU-KzbhV-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW2FT1VU-KzbhV-2}{NW2FT1VU-KzbhV-4}\nwenddeflinemarkup
DECLARE_ENTRYPOINT(eval_indir);

\nwendcode{}\nwbegindocs{12}\nwdocspar
\nwenddocs{}\nwbegincode{13}\sublabel{NW2FT1VU-2P9Uvd-4}\nwmargintag{{\nwtagstyle{}\subpageref{NW2FT1VU-2P9Uvd-4}}}\moddef{eval.c~{\nwtagstyle{}\subpageref{NW2FT1VU-2P9Uvd-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW2FT1VU-2P9Uvd-3}{NW2FT1VU-2P9Uvd-5}\nwenddeflinemarkup
FUNCTION(eval_indir)
\{
    Node *node;

    EXPORT_LABEL(eval_indir)
 ENTRY_LABEL(eval_indir)

    node = sp[0];
    ASSERT(is_boxed(node) && is_indir_node(node));

    /* dereference the indirection */
    do
    \{
        node = node->n.node;
    \}
    while ( is_boxed(node) && node->info->tag == INDIR_TAG );

    /* enter the node */
    if ( is_unboxed(node) )
    \{
        sp += 1;
        RETURN(node);
    \}
    sp[0] = node;
    GOTO(node->info->eval);
\}

\nwendcode{}\nwbegindocs{14}\nwdocspar
The {\Tt{}eval{\_}queueMe\nwendquote} code is used when the node on the top of the
stack is a queue-me closure. In this case, the current thread is
suspended until the evaluation of the corresponding application is
completed and the queue-me closure is overwritten with the result.

\nwenddocs{}\nwbegincode{15}\sublabel{NW2FT1VU-KzbhV-4}\nwmargintag{{\nwtagstyle{}\subpageref{NW2FT1VU-KzbhV-4}}}\moddef{eval.h~{\nwtagstyle{}\subpageref{NW2FT1VU-KzbhV-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW2FT1VU-KzbhV-3}{NW2FT1VU-KzbhV-5}\nwenddeflinemarkup
DECLARE_ENTRYPOINT(eval_queueMe);

\nwendcode{}\nwbegindocs{16}\nwdocspar
\nwenddocs{}\nwbegincode{17}\sublabel{NW2FT1VU-2P9Uvd-5}\nwmargintag{{\nwtagstyle{}\subpageref{NW2FT1VU-2P9Uvd-5}}}\moddef{eval.c~{\nwtagstyle{}\subpageref{NW2FT1VU-2P9Uvd-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW2FT1VU-2P9Uvd-4}{NW2FT1VU-2P9Uvd-6}\nwenddeflinemarkup
FUNCTION(eval_queueMe)
\{
    EXPORT_LABEL(eval_queueMe)
 ENTRY_LABEL(eval_queueMe)

    GOTO(suspend_thread(resume, sp[0]));
\}

\nwendcode{}\nwbegindocs{18}\nwdocspar
The {\Tt{}update\nwendquote} code is responsible for updating a suspended application
node with the result of the application. All threads that have been
delayed for entering the suspended application after its evaluation
was begun by the current thread are woken, but the current thread is
not interrupted.

\nwenddocs{}\nwbegincode{19}\sublabel{NW2FT1VU-KzbhV-5}\nwmargintag{{\nwtagstyle{}\subpageref{NW2FT1VU-KzbhV-5}}}\moddef{eval.h~{\nwtagstyle{}\subpageref{NW2FT1VU-KzbhV-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW2FT1VU-KzbhV-4}{NW2FT1VU-KzbhV-6}\nwenddeflinemarkup
DECLARE_ENTRYPOINT(update);

\nwendcode{}\nwbegindocs{20}\nwdocspar
\nwenddocs{}\nwbegincode{21}\sublabel{NW2FT1VU-2P9Uvd-6}\nwmargintag{{\nwtagstyle{}\subpageref{NW2FT1VU-2P9Uvd-6}}}\moddef{eval.c~{\nwtagstyle{}\subpageref{NW2FT1VU-2P9Uvd-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW2FT1VU-2P9Uvd-5}{NW2FT1VU-2P9Uvd-7}\nwenddeflinemarkup
FUNCTION(update)
\{
    Node       *result, *susp;
    Label       ret_ip;
    ThreadQueue wq;

    EXPORT_LABEL(update)
 ENTRY_LABEL(update)

    result = sp[0];
    susp   = sp[1];
    ret_ip = (Label)sp[2];
    sp    += 2;
    ASSERT(is_boxed(susp) && is_queueMe_node(susp) &&
           is_local_space(susp->q.spc));

    /* update the suspended application */
    TRACE(("%I %N = %N\\n", susp, result));
    wq = susp->q.wq;
    SAVE(susp, q.wq);
    susp->info   = &suspend_indir_info;
    susp->n.node = result;
    sp[0]        = result;

    /* wake all threads on the wait-queue of the application */
    if ( wq != (ThreadQueue)0 )
        wake_threads(wq);

    /* return to the caller */
    GOTO(ret_ip);
\}

\nwendcode{}\nwbegindocs{22}\nwdocspar
When a thread that has been suspended due to entering a queue-me node
is continued, the node on the top of the stack has to be dereferenced
before actually returning. The {\Tt{}resume\nwendquote} code performs this task.
Note that the node on the top of the stack is always in weak head
normal form when {\Tt{}resume\nwendquote} is entered. Therefore, it is safe to return
to the caller without entering the result.

\nwenddocs{}\nwbegincode{23}\sublabel{NW2FT1VU-KzbhV-6}\nwmargintag{{\nwtagstyle{}\subpageref{NW2FT1VU-KzbhV-6}}}\moddef{eval.h~{\nwtagstyle{}\subpageref{NW2FT1VU-KzbhV-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW2FT1VU-KzbhV-5}{NW2FT1VU-KzbhV-7}\nwenddeflinemarkup
DECLARE_ENTRYPOINT(resume);

\nwendcode{}\nwbegindocs{24}\nwdocspar
\nwenddocs{}\nwbegincode{25}\sublabel{NW2FT1VU-2P9Uvd-7}\nwmargintag{{\nwtagstyle{}\subpageref{NW2FT1VU-2P9Uvd-7}}}\moddef{eval.c~{\nwtagstyle{}\subpageref{NW2FT1VU-2P9Uvd-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW2FT1VU-2P9Uvd-6}{NW2FT1VU-2P9Uvd-8}\nwenddeflinemarkup
FUNCTION(resume)
\{
    Node  *result;
    Label ret_ip;

    EXPORT_LABEL(resume)
 ENTRY_LABEL(resume)

    /* dereference the indirection */
    result = sp[0];
    ret_ip = (Label)sp[1];
    while ( is_boxed(result) && result->info->tag == INDIR_TAG )
        result = result->n.node;
    *++sp = result;

    /* return to the caller */
    GOTO(ret_ip);
\}

\nwendcode{}\nwbegindocs{26}\nwdocspar
The compiler translates uses of higher order functions into first
order applications by inserting applications of the (binary) primitive
{\Tt{}@\nwendquote}. The code of this function first has to evaluate the function
argument to a (ground) head normal form. If the result is a closure
taking exactly one argument, a tail call to that function is
performed. Otherwise, a new closure -- which is still in head normal
form -- is returned to the caller. The info vector for this closure
is computed by using the fact that all tag vectors are found in an
array which is indexed by the number of arguments to which the
function is applied.

Actually, the compiler generates a whole family of functions {\Tt{}@\nwendquote}$_n$
for each module and number of arguments $n$ to which an unknown
function is applied in that module. The function {\Tt{}@\nwendquote} is defined here
for use in the runtime system itself, but it is also used by the
compiler in place of {\Tt{}@\nwendquote}$_1$.

Note that we do not provide a function info table for {\Tt{}@\nwendquote} because
this function is never applied partially.

\nwenddocs{}\nwbegincode{27}\sublabel{NW2FT1VU-KzbhV-7}\nwmargintag{{\nwtagstyle{}\subpageref{NW2FT1VU-KzbhV-7}}}\moddef{eval.h~{\nwtagstyle{}\subpageref{NW2FT1VU-KzbhV-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW2FT1VU-KzbhV-6}{\relax}\nwenddeflinemarkup
DECLARE_ENTRYPOINT(___64_);
extern FunctionInfo ___64__info;
extern NodeInfo     ___64__suspend_info;

\nwendcode{}\nwbegindocs{28}\nwdocspar
\nwenddocs{}\nwbegincode{29}\sublabel{NW2FT1VU-2P9Uvd-8}\nwmargintag{{\nwtagstyle{}\subpageref{NW2FT1VU-2P9Uvd-8}}}\moddef{eval.c~{\nwtagstyle{}\subpageref{NW2FT1VU-2P9Uvd-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW2FT1VU-2P9Uvd-7}{NW2FT1VU-2P9Uvd-9}\nwenddeflinemarkup
DECLARE_LABEL(___64__eval);
DECLARE_LABEL(___64__lazy);

FunctionInfo ___64__info         = FUNINFO("@", ___64_, 2);
NodeInfo     ___64__suspend_info = SUSPINFO(___64_);

static
FUNCTION(___64__eval)
\{
    Node *clos;
 ENTRY_LABEL(___64__eval)
    CHECK_STACK1();
    clos  = sp[0];
    sp   -= 1;
    sp[0] = clos->cl.args[0];
    sp[1] = clos->cl.args[1];
    GOTO(___64_);
\}

static
FUNCTION(___64__lazy)
\{
    Node *susp, *clos;
 ENTRY_LABEL(___64__lazy)
    susp = sp[0];

    /* suspend the search if the node is not local */
    if ( !is_local_space(susp->s.spc) )
        GOTO(suspend_thread(resume, susp));

    /* lock the suspension */
    clos = susp->s.fn;
    SAVE(susp, q.wq);
    susp->info = &queueMe_info;
    susp->q.wq = (ThreadQueue)0;

    /* create an update frame */
    CHECK_STACK(3);
    sp   -= 3;
    sp[0] = clos->cl.args[0];
    sp[1] = clos->cl.args[1];
    sp[2] = (Node *)update;

    /* enter the callee */
    GOTO(___64_);
\}

DECLARE_LABEL(___64__1);

FUNCTION(___64_)
\{
    EXPORT_LABEL(___64_)
 ENTRY_LABEL(___64_)
    TRACE(("%I enter @%V\\n", 2, sp));
    GOTO(___64__1);
\}

static
FUNCTION(___64__1)
\{
    unsigned int argc;
    Node         *clos;
    FunctionInfo *fInfo;

 ENTRY_LABEL(___64__1)
    /* evaluate the function argument to head normal form */
    EVAL_RIGID(___64__1);
    clos = sp[0];
    ASSERT(is_boxed(clos) && is_papp_node(clos));

    /* check the number of missing arguments */
    fInfo = clos->cl.info;
    argc  = closure_argc(clos);
    ASSERT(fInfo->arity > argc);
    if ( argc + 1 == fInfo->arity )
    \{
        ASSERT(fInfo[1].node_info.tag == CLOSURE_TAG);

        /* push the arguments onto the stack */
        CHECK_STACK(argc - 1);
        sp -= argc - 1;
        memcpy(sp, clos->cl.args, argc * word_size);

        /* perform a tail call to the closure */
        GOTO(fInfo->entry);
    \}

    /* allocate a new closure for the application */
    CHECK_HEAP(closure_node_size(argc + 1));

    /* create a new closure from the old closure and the argument */
    clos = (Node *)hp;
    memcpy(clos, sp[0], closure_node_size(argc) * word_size);
    clos->cl.info++;
    clos->cl.args[argc] = sp[1];
    hp += closure_node_size(argc + 1);

    /* return to the caller */
    sp += 2;
    RETURN(clos);
\}

\nwendcode{}\nwbegindocs{30}\nwdocspar
Due to the lack of a better place, this module also implements the
constructor function for non-empty lists.

Note that it is not necessary to export the entry-point because the
function will never be called directly.

\nwenddocs{}\nwbegincode{31}\sublabel{NW2FT1VU-2P9Uvd-9}\nwmargintag{{\nwtagstyle{}\subpageref{NW2FT1VU-2P9Uvd-9}}}\moddef{eval.c~{\nwtagstyle{}\subpageref{NW2FT1VU-2P9Uvd-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW2FT1VU-2P9Uvd-8}{NW2FT1VU-2P9Uvd-A}\nwenddeflinemarkup
DECLARE_LABEL(___58_);
DECLARE_LABEL(___58__eval);
FunctionInfo ___58__info_table[] = \{
    PAPPINFO(":", 0, ___58_, 2)
    PAPPINFO(":", 1, ___58_, 2)
    FUNINFO(":",     ___58_, 2)
\};
struct closure_node ___58__function = \{ ___58__info_table, \{ \} \};

static
FUNCTION(___58__eval)
\{
    Node *clos;
 ENTRY_LABEL(___58__eval)
    CHECK_STACK1();
    clos  = sp[0];
    sp   -= 1;
    sp[0] = clos->cl.args[0];
    sp[1] = clos->cl.args[1];
    GOTO(___58_);
\}

static
FUNCTION(___58_)
\{
    Node *cons;

 ENTRY_LABEL(___58_)

    TRACE(("%I enter :%V\\n", 2, sp));

    CHECK_HEAP(cons_node_size);
    cons            = (Node *)hp;
    cons->c.info    = &cons_info;
    cons->c.args[0] = sp[0];
    cons->c.args[1] = sp[1];
    hp             += cons_node_size;

    sp += 2;
    RETURN(cons);
\}

\nwendcode{}\nwbegindocs{32}\nwdocspar
The primitive function \texttt{seq} forces the evaluation of its
first argument to head normal form. It is rigid in its first argument,
but not its second.

\nwenddocs{}\nwbegincode{33}\sublabel{NW2FT1VU-2P9Uvd-A}\nwmargintag{{\nwtagstyle{}\subpageref{NW2FT1VU-2P9Uvd-A}}}\moddef{eval.c~{\nwtagstyle{}\subpageref{NW2FT1VU-2P9Uvd-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW2FT1VU-2P9Uvd-9}{NW2FT1VU-2P9Uvd-B}\nwenddeflinemarkup
DECLARE_ENTRYPOINT(__seq);

FUNCTION(__seq)
\{
    Node *node;

    EXPORT_LABEL(__seq)
 ENTRY_LABEL(__seq)
    EVAL_RIGID_POLY(__seq);
    node = sp[1];
    if ( is_boxed(node) )
    \{
        sp += 1;
        GOTO(node->info->eval);
    \}
    sp += 2;
    RETURN(node);
\}

\nwendcode{}\nwbegindocs{34}\nwdocspar
The primitive function \texttt{failed} simply invokes the current
failure handler.

\nwenddocs{}\nwbegincode{35}\sublabel{NW2FT1VU-2P9Uvd-B}\nwmargintag{{\nwtagstyle{}\subpageref{NW2FT1VU-2P9Uvd-B}}}\moddef{eval.c~{\nwtagstyle{}\subpageref{NW2FT1VU-2P9Uvd-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW2FT1VU-2P9Uvd-A}{NW2FT1VU-2P9Uvd-C}\nwenddeflinemarkup
DECLARE_ENTRYPOINT(__failed);

FUNCTION(__failed)
\{
    EXPORT_LABEL(__failed)
 ENTRY_LABEL(__failed)
    FAIL();
\}

\nwendcode{}\nwbegindocs{36}\nwdocspar
The polymorphic function \texttt{ground} ensures that the normal form
of its argument is a ground data term. This is done lazily so that
\texttt{ground} is semantically equivalent to \texttt{prelude.id}
otherwise.

\nwenddocs{}\nwbegincode{37}\sublabel{NW2FT1VU-2P9Uvd-C}\nwmargintag{{\nwtagstyle{}\subpageref{NW2FT1VU-2P9Uvd-C}}}\moddef{eval.c~{\nwtagstyle{}\subpageref{NW2FT1VU-2P9Uvd-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW2FT1VU-2P9Uvd-B}{\relax}\nwenddeflinemarkup
DECLARE_ENTRYPOINT(__ground);
DECLARE_LABEL(__ground_eval);
DECLARE_LABEL(__ground_lazy);
DECLARE_LABEL(__ground_1);

static
FUNCTION(__ground_eval)
\{
    Node *clos;
 ENTRY_LABEL(__ground_eval)
    clos  = sp[0];
    sp[0] = clos->cl.args[0];
    GOTO(__ground);
\}

static
FUNCTION(__ground_lazy)
\{
    Node *susp, *clos;
 ENTRY_LABEL(__ground_lazy)
    susp = sp[0];

    /* suspend the search if the node is not local */
    if ( !is_local_space(susp->s.spc) )
        GOTO(suspend_thread(resume, susp));

    /* lock the suspension */
    clos = susp->s.fn;
    SAVE(susp, q.wq);
    susp->info = &queueMe_info;
    susp->q.wq = (ThreadQueue)0;

    /* create an update frame */
    CHECK_STACK(2);
    sp   -= 2;
    sp[0] = clos->cl.args[0];
    sp[1] = (Node *)update;

    /* enter the callee */
    GOTO(__ground);
\}

FUNCTION(__ground)
\{
    EXPORT_LABEL(__ground)
 ENTRY_LABEL(__ground)
    TRACE(("%I enter ground%V\\n", 1, sp));
    GOTO(__ground_1);
\}

static
FUNCTION(__ground_1)
\{
    boolean             is_vect;
    unsigned int        n, sz;
    Node                *node, **argp, *clos, *susp;
    static FunctionInfo ground_info         = FUNINFO("ground", __ground, 1);
    static NodeInfo     ground_suspend_info = SUSPINFO(__ground);
 ENTRY_LABEL(__ground_1)
    EVAL_RIGID_POLY(__ground_1);
    node = sp[0];
    if ( is_boxed(node) && (is_constr_node(node) || is_papp_node(node)) )
    \{
        is_vect = is_vector(node);
        n       = is_vect ? vector_argc(node) : constr_argc(node);
        if ( n > 0 )
        \{
            sz = is_vect ? vector_node_size(n) : node_size(node);
            CHECK_HEAP(sz + n * (closure_node_size(1) + suspend_node_size));

            node = (Node *)(hp + n * (closure_node_size(1) + suspend_node_size));
            memcpy(node, sp[0], sz * word_size);

            for ( argp = is_vect ? node->a.args : node->c.args;
                  n > 0; 
                  argp++, n-- )
            \{
                clos             = (Node *)hp;
                clos->cl.info    = &ground_info;
                clos->cl.args[0] = *argp;
                hp              += closure_node_size(1);

                susp         = (Node *)hp;
                susp->s.info = &ground_suspend_info;
                susp->s.fn   = clos;
                susp->s.spc  = ss;
                hp          += suspend_node_size;

                *argp = susp;
            \}

            ASSERT((Node *)hp == node);
            hp  += sz;
        \}
    \}

    sp += 1;
    RETURN(node);
\}
\nwendcode{}

\nwixlogsorted{c}{{eval.c}{NW2FT1VU-2P9Uvd-1}{\nwixd{NW2FT1VU-2P9Uvd-1}\nwixd{NW2FT1VU-2P9Uvd-2}\nwixd{NW2FT1VU-2P9Uvd-3}\nwixd{NW2FT1VU-2P9Uvd-4}\nwixd{NW2FT1VU-2P9Uvd-5}\nwixd{NW2FT1VU-2P9Uvd-6}\nwixd{NW2FT1VU-2P9Uvd-7}\nwixd{NW2FT1VU-2P9Uvd-8}\nwixd{NW2FT1VU-2P9Uvd-9}\nwixd{NW2FT1VU-2P9Uvd-A}\nwixd{NW2FT1VU-2P9Uvd-B}\nwixd{NW2FT1VU-2P9Uvd-C}}}%
\nwixlogsorted{c}{{eval.h}{NW2FT1VU-KzbhV-1}{\nwixd{NW2FT1VU-KzbhV-1}\nwixd{NW2FT1VU-KzbhV-2}\nwixd{NW2FT1VU-KzbhV-3}\nwixd{NW2FT1VU-KzbhV-4}\nwixd{NW2FT1VU-KzbhV-5}\nwixd{NW2FT1VU-KzbhV-6}\nwixd{NW2FT1VU-KzbhV-7}}}%

