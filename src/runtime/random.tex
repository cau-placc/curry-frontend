\nwfilename{random.nw}\nwbegindocs{0}% -*- noweb-code-mode: c-mode -*-% ===> this file was generated automatically by noweave --- better not edit it
% $Id: random.nw,v 2.3 2004/05/03 15:59:58 wlux Exp $
%
% Copyright (c) 2004, Wolfgang Lux
% See ../LICENSE for the full license.
%
\subsection{Random numbers}
The functions in this file implement the primitives for the
\texttt{Random} module. The implementation is based on the
{\Tt{}random\nwendquote} function from the standard C library.

\nwenddocs{}\nwbegincode{1}\sublabel{NW2X27ZX-2c39tM-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2X27ZX-2c39tM-1}}}\moddef{random.c~{\nwtagstyle{}\subpageref{NW2X27ZX-2c39tM-1}}}\endmoddef\nwstartdeflinemarkup\nwprevnextdefs{\relax}{NW2X27ZX-2c39tM-2}\nwenddeflinemarkup
#include "config.h"
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <sys/time.h>
#include "debug.h"
#include "run.h"
#include "heap.h"
#include "stack.h"
#include "threads.h"
#include "eval.h"
#include "io_monad.h"
#include "cam.h"
#include "trace.h"

#define pair_node_size   constr_node_size(2)
#define pair_info        ___40__44__41__info

static DEFINE_DATA(___40__44__41_, "(,)", 0, 2);

\nwalsodefined{\\{NW2X27ZX-2c39tM-2}\\{NW2X27ZX-2c39tM-3}\\{NW2X27ZX-2c39tM-4}\\{NW2X27ZX-2c39tM-5}\\{NW2X27ZX-2c39tM-6}\\{NW2X27ZX-2c39tM-7}}\nwnotused{random.c}\nwendcode{}\nwbegindocs{2}\nwdocspar
We use state arrays with a size of 128 bytes. While larger state
arrays of 256 bytes are possible, it turns out that the first random
number is always an even number for them.

\nwenddocs{}\nwbegincode{3}\sublabel{NW2X27ZX-2c39tM-2}\nwmargintag{{\nwtagstyle{}\subpageref{NW2X27ZX-2c39tM-2}}}\moddef{random.c~{\nwtagstyle{}\subpageref{NW2X27ZX-2c39tM-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW2X27ZX-2c39tM-1}{NW2X27ZX-2c39tM-3}\nwenddeflinemarkup
#define STATESIZE 128

\nwendcode{}\nwbegindocs{4}\nwdocspar
In order to support multiple independent random number generators,
each generator uses its own state array, which is saved in the
corresponding {\Tt{}StdGen\nwendquote} node. The state arrays are allocated outside
of the heap in order to avoid problems with the garbage collection
moving nodes around, and are released when their {\Tt{}StdGen\nwendquote} nodes
becomes garbage.

\nwenddocs{}\nwbegincode{5}\sublabel{NW2X27ZX-2c39tM-3}\nwmargintag{{\nwtagstyle{}\subpageref{NW2X27ZX-2c39tM-3}}}\moddef{random.c~{\nwtagstyle{}\subpageref{NW2X27ZX-2c39tM-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW2X27ZX-2c39tM-2}{NW2X27ZX-2c39tM-4}\nwenddeflinemarkup
#define STDGEN_TAG       ABSTRACT_TAG
#define stdgen_node_size wordsof(StdGen)

static void finalize_stdgen(Node *);

typedef struct stdgen_node \{
    NodeInfo *info;
    int      random;            /* buffer for random bits */
    int      valid;             /* number of valid bits in the buffer */
    char     *state;
\} StdGen;

static NodeInfo stdgen_info = \{
    STDGEN_TAG, stdgen_node_size, ot_binary, (Label)eval_whnf,
    "<<Random.StdGen>>", finalize_stdgen
\};

static void
finalize_stdgen(Node *node)
\{
    StdGen *rng = (StdGen *)node;

    free(rng->state);
\}

\nwendcode{}\nwbegindocs{6}\nwdocspar
The function {\Tt{}mkStdGen\ ::\ Int\ ->\ StdGen\nwendquote} creates a new random number
generator that is initialized with the seed passed to {\Tt{}mkStdGen\nwendquote}.
Note that the code carefully maintains the state of the default random
number generator so as to not disrupt its operation.

\nwenddocs{}\nwbegincode{7}\sublabel{NW2X27ZX-2c39tM-4}\nwmargintag{{\nwtagstyle{}\subpageref{NW2X27ZX-2c39tM-4}}}\moddef{random.c~{\nwtagstyle{}\subpageref{NW2X27ZX-2c39tM-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW2X27ZX-2c39tM-3}{NW2X27ZX-2c39tM-5}\nwenddeflinemarkup
DECLARE_ENTRYPOINT(__mkStdGen);

FUNCTION(__mkStdGen)
\{
    unsigned long seed;
    StdGen        *rng;

    EXPORT_LABEL(__mkStdGen)
 ENTRY_LABEL(__mkStdGen)
    EVAL_RIGID_INT(__mkStdGen);

    seed = int_val(sp[0]);
    sp  += 1;

    CHECK_HEAP(stdgen_node_size);
    rng         = (StdGen *)hp;
    rng->info   = &stdgen_info;
    rng->state  = (char *)malloc(STATESIZE);
    rng->valid  = 0;
    rng->random = 0;
    hp         += stdgen_node_size;

    if ( rng->state == (char *)0 )
    \{
        fprintf(stderr, "mkStdGen: memory exhausted\\n");
        exit(1);
    \}
    setstate(initstate(seed, rng->state, STATESIZE));
    RETURN((Node *)rng);
\}

\nwendcode{}\nwbegindocs{8}\nwdocspar
The function {\Tt{}nextRStdGen\ ::\ Int\ ->\ Int\ ->\ StdGen\ ->\ (Int,StdGen)\nwendquote}
returns the next random number in the specified range for a particular
random number generator. The function {\Tt{}nextStdGen\nwendquote} is a partial
application of {\Tt{}nextRStdGen\nwendquote} using the minimum and maximum {\Tt{}Int\nwendquote}
values as lower and upper bounds, respectively. Both functions
carefully restore the state of the global random number generator
after computing the number.

In order to ensure an equal distribution of random numbers between the
two bounds $l$ and $h$, we interpret the random numbers returned by
{\Tt{}random\nwendquote} as a bit stream and take $n$ bits from that stream at every
call, where $n$ is the smallest number such that $2^n \geq h-l+1$. In
addition, we discard values outside the range $(0,h-l+1)$ in that
stream. A little analysis reveals that on average we take
$\frac{2^n}{h-l+1}$ values from the input stream. Thus, even in the
worst case, when we have $h-l+1 = 2^{n-1} + 1$ and
$\frac{2^n}{h-l+1} = \frac{2^n}{2^{n-1}+1} \approx 2$, we take at most
two values from the stream on average. Note that {\Tt{}random\nwendquote} returns
a number in the range $(0,2^{31}-1)$. Therefore, the {\Tt{}while\nwendquote} loop
may be executed more than once if a 32-bit or larger result is
requested.

\nwenddocs{}\nwbegincode{9}\sublabel{NW2X27ZX-2c39tM-5}\nwmargintag{{\nwtagstyle{}\subpageref{NW2X27ZX-2c39tM-5}}}\moddef{random.c~{\nwtagstyle{}\subpageref{NW2X27ZX-2c39tM-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW2X27ZX-2c39tM-4}{NW2X27ZX-2c39tM-6}\nwenddeflinemarkup
DECLARE_ENTRYPOINT(__nextStdGen);
DECLARE_ENTRYPOINT(__nextRStdGen);

DECLARE_LABEL(__nextRStdGen_1);
DECLARE_LABEL(__nextRStdGen_2);

#if ONLY_BOXED_OBJECTS
static struct int_node minInt_node = \{ &int_info, LONG_MIN \};
static struct int_node maxInt_node = \{ &int_info, LONG_MAX \};

# define minInt (Node *)&minInt_node
# define maxInt (Node *)&maxInt_node
#else
# define minInt mk_int(LONG_MIN/2)
# define maxInt mk_int(LONG_MAX/2)
#endif

FUNCTION(__nextStdGen)
\{
    EXPORT_LABEL(__nextStdGen)
 ENTRY_LABEL(__nextStdGen)
    CHECK_STACK(2);
    sp   -= 2;
    sp[0] = sp[2];
    sp[1] = minInt;
    sp[2] = maxInt;
    GOTO(__nextRStdGen_2);
\}

FUNCTION(__nextRStdGen)
\{
    Node *lo, *hi;
    EXPORT_LABEL(__nextRStdGen)
 ENTRY_LABEL(__nextRStdGen)
    EVAL_RIGID_INT(__nextRStdGen);
    lo    = sp[0];
    hi    = sp[1];
    sp[0] = hi;
    sp[1] = lo;
    GOTO(__nextRStdGen_1);
\}

static
FUNCTION(__nextRStdGen_1)
\{
    Node *rng, *hi;
 ENTRY_LABEL(__nextRStdGen_1)
    EVAL_RIGID_INT(__nextRStdGen_1);
    hi    = sp[0];
    rng   = sp[2];
    sp[0] = rng;
    sp[2] = hi;
    GOTO(__nextRStdGen_2);
\}

static
FUNCTION(__nextRStdGen_2)
\{
    char   *o;
    int    bits;
    long   lo, hi, r;
    unsigned long diff, mask;
    StdGen *rng;
    Node   *p, *i;

 ENTRY_LABEL(__nextRStdGen_2)
    EVAL_RIGID(__nextRStdGen_2);

    CHECK_HEAP(pair_node_size + int_node_size);

    rng = (StdGen *)sp[0];
    lo  = int_val(sp[1]);
    hi  = int_val(sp[2]);
    sp += 3;

    /* determine the number of bits required */
    if ( hi >= lo )
    \{
        diff = hi - lo;
        mask = 1;
        for (bits = 1; diff & ~mask; bits++)
            mask = (mask << 1) + 1;
    \}
    else
        FAIL();

    o = setstate(rng->state);
repeat:
    r = 0;
    while ( rng->valid < bits )
    \{
        bits       -= rng->valid;
        mask      >>= rng->valid;
        r          |= rng->random << bits;
        rng->random = random();
        rng->valid  = 31;
    \}
    r            |= rng->random & mask;
    rng->valid   -= bits;
    rng->random >>= bits;
    r            += lo;
    if ( r > hi )
        goto repeat;
    setstate(o);

#if ONLY_BOXED_OBJECTS
    i       = (Node *)hp;
    i->info = &int_info;
    i->i.i  = r;
    hp     += int_node_size;
#else
    i = mk_int(r);
#endif

    p            = (Node *)hp;
    p->info      = &pair_info;
    p->c.args[0] = i;
    p->c.args[1] = (Node *)rng;
    hp          += pair_node_size;

    RETURN(p);
\}

\nwendcode{}\nwbegindocs{10}\nwdocspar
The function {\Tt{}genRange\ ::\ StdGen\ ->\ (Int,Int)\nwendquote} yields the range of
values returned by the generator.

\nwenddocs{}\nwbegincode{11}\sublabel{NW2X27ZX-2c39tM-6}\nwmargintag{{\nwtagstyle{}\subpageref{NW2X27ZX-2c39tM-6}}}\moddef{random.c~{\nwtagstyle{}\subpageref{NW2X27ZX-2c39tM-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW2X27ZX-2c39tM-5}{NW2X27ZX-2c39tM-7}\nwenddeflinemarkup
FUNCTION(__genRange)
\{
    Node *r;
    EXPORT_LABEL(__genRange)
 ENTRY_LABEL(__genRange)
    sp          += 1;

    CHECK_HEAP(pair_node_size);
    r            = (Node *)hp;
    r->info      = &pair_info;
    r->c.args[0] = minInt;
    r->c.args[1] = maxInt;
    hp          += pair_node_size;

    RETURN(r);
\}

\nwendcode{}\nwbegindocs{12}\nwdocspar
The functions {\Tt{}getStdGen\ ::\ IO\ StdGen\nwendquote} and {\Tt{}setStdGen\ ::\ StdGen\ ->\ IO\ ()\nwendquote}
manage a global variable that maintains the default random number
generator. If the global variable has not been set, {\Tt{}getSetGen\nwendquote}
creates a new random number generator and initializes this generator
from the current time.

There is a fundamental problem with updating global variables like
{\Tt{}stdGen\nwendquote} in non-deterministic code. In our implementation, this
could leave a dangling pointer in {\Tt{}stdGen\nwendquote} when the
non-deterministic computation fails. While this could be avoided by
recording the update on the trail, things do not work out straight
when a search continuation whose code did update {\Tt{}stdGen\nwendquote} is copied.
In this case, the global variable cannot be copied and therefore the
copy would start using wrong values for {\Tt{}stdGen\nwendquote}. For that reason,
we simply abort the program with an error message when {\Tt{}setStdGen\nwendquote}
or {\Tt{}getStdGen\nwendquote} is called in non-deterministic code. Note that this
can happen only when these functions are used in an
{\Tt{}unsafePerformIO\nwendquote} context.

\nwenddocs{}\nwbegincode{13}\sublabel{NW2X27ZX-2c39tM-7}\nwmargintag{{\nwtagstyle{}\subpageref{NW2X27ZX-2c39tM-7}}}\moddef{random.c~{\nwtagstyle{}\subpageref{NW2X27ZX-2c39tM-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW2X27ZX-2c39tM-6}{\relax}\nwenddeflinemarkup
static StdGen *stdGen;

#define DET_CHECK(what) do \{ \\
    if ( bp != (Choicepoint *)0 ) \{ \\
        fprintf(stderr, "Cannot duplicate " what "\\n"); \\
        curry_exit(1); \\
    \} \\
\} while (0)

DECLARE_ENTRYPOINT(__setStdGen);

FUNCTION(__setStdGen)
\{
    EXPORT_LABEL(__setStdGen)
 ENTRY_LABEL(__setStdGen)
    EVAL_RIGID(__setStdGen);
    if ( stdGen == (StdGen *)0 )
        add_global_root((Node **)&stdGen);
    DET_CHECK("Random.stdGen");
    stdGen = (StdGen *)sp[0];
    sp    += 2;
    RETURN(unit);
\}

DECLARE_ENTRYPOINT(__getStdGen);
DECLARE_LABEL(__getStdGen_1);

FUNCTION(__getStdGen)
\{
    long           seed;
    struct timeval tv;
#if ONLY_BOXED_OBJECTS
    static struct int_node seed_node = \{ &int_info, 0 \};
#endif
    EXPORT_LABEL(__getStdGen)
 ENTRY_LABEL(__getStdGen)
    if ( stdGen != (StdGen *)0 )
    \{
        sp += 1;
        RETURN((Node *)stdGen);
    \}

    gettimeofday(&tv, (struct timezone *)0);
    srandom(tv.tv_sec ^ tv.tv_usec);
    seed = random();

    CHECK_STACK1();
    sp -= 1;
#if ONLY_BOXED_OBJECTS
    seed_node.i = seed;
    sp[0]       = (Node *)&seed_node;
#else
    sp[0] = mk_int(seed);
#endif
    sp[1] = (Node *)__getStdGen_1;
    GOTO(__mkStdGen);
\}

static
FUNCTION(__getStdGen_1)
\{
    Node *rng;
 ENTRY_LABEL(__getStdGen_1)
    rng = *sp++;
    add_global_root((Node **)&stdGen);
    DET_CHECK("Random.stdGen");
    stdGen = (StdGen *)rng;
    RETURN(rng);
\}
\nwendcode{}

\nwixlogsorted{c}{{random.c}{NW2X27ZX-2c39tM-1}{\nwixd{NW2X27ZX-2c39tM-1}\nwixd{NW2X27ZX-2c39tM-2}\nwixd{NW2X27ZX-2c39tM-3}\nwixd{NW2X27ZX-2c39tM-4}\nwixd{NW2X27ZX-2c39tM-5}\nwixd{NW2X27ZX-2c39tM-6}\nwixd{NW2X27ZX-2c39tM-7}}}%

