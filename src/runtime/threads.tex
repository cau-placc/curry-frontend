\nwfilename{threads.nw}\nwbegindocs{0}% -*- noweb-code-mode: c-mode -*-% ===> this file was generated automatically by noweave --- better not edit it
% $Id: threads.nw,v 2.10 2004/05/02 09:17:27 wlux Exp $
%
% Copyright (c) 2001-2004, Wolfgang Lux
% See ../LICENSE for the full license.
%
\subsection{Thread Management}
The runtime system implements concurrent evaluation using multiple
threads of control. The state of the running thread is maintained in
the machine registers and a few global variables declared here.

The global variable {\Tt{}cid\nwendquote} saves the thread id of the current thread.
Thread ids serve no particular purpose in the runtime system, but
they are quite useful in order to debug the abstract machine code. New
ids are generated by incrementing the private variable {\Tt{}tid\nwendquote}. We do
not care for overflows so a thread id may be no longer unique if you
manage to generate more than $2^{32}$ threads. The thread id {\Tt{}0\nwendquote} is
reserved and setting {\Tt{}cid\nwendquote} to {\Tt{}0\nwendquote} denotes that no thread is
running.

The base address of the data stack of the current thread is saved in
the global variable {\Tt{}ds{\_}base\nwendquote}.

\nwenddocs{}\nwbegincode{1}\sublabel{NW2D2Ose-1K10J3-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2D2Ose-1K10J3-1}}}\moddef{threads.h~{\nwtagstyle{}\subpageref{NW2D2Ose-1K10J3-1}}}\endmoddef\nwstartdeflinemarkup\nwprevnextdefs{\relax}{NW2D2Ose-1K10J3-2}\nwenddeflinemarkup
extern unsigned int cid;        /* id of current thread */
extern Node     **ds_base;

\nwalsodefined{\\{NW2D2Ose-1K10J3-2}\\{NW2D2Ose-1K10J3-3}\\{NW2D2Ose-1K10J3-4}\\{NW2D2Ose-1K10J3-5}}\nwnotused{threads.h}\nwendcode{}\nwbegindocs{2}\nwdocspar
\nwenddocs{}\nwbegincode{3}\sublabel{NW2D2Ose-3yVYBR-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2D2Ose-3yVYBR-1}}}\moddef{threads.c~{\nwtagstyle{}\subpageref{NW2D2Ose-3yVYBR-1}}}\endmoddef\nwstartdeflinemarkup\nwprevnextdefs{\relax}{NW2D2Ose-3yVYBR-2}\nwenddeflinemarkup
#include "config.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "debug.h"
#include "run.h"
#include "heap.h"
#include "stack.h"
#include "eval.h"
#include "threads.h"
#include "spaces.h"
#include "search.h"
#include "trail.h"
#include "trace.h"

unsigned int        cid;
static unsigned int tid;
Node                **ds_base;

\nwalsodefined{\\{NW2D2Ose-3yVYBR-2}\\{NW2D2Ose-3yVYBR-3}\\{NW2D2Ose-3yVYBR-4}\\{NW2D2Ose-3yVYBR-5}\\{NW2D2Ose-3yVYBR-6}\\{NW2D2Ose-3yVYBR-7}\\{NW2D2Ose-3yVYBR-8}\\{NW2D2Ose-3yVYBR-9}\\{NW2D2Ose-3yVYBR-A}\\{NW2D2Ose-3yVYBR-B}\\{NW2D2Ose-3yVYBR-C}\\{NW2D2Ose-3yVYBR-D}\\{NW2D2Ose-3yVYBR-E}\\{NW2D2Ose-3yVYBR-F}\\{NW2D2Ose-3yVYBR-G}}\nwnotused{threads.c}\nwendcode{}\nwbegindocs{4}\nwdocspar
The state of a thread which is not running is saved in a thread
node structure that is allocated in the heap. This state information
comprises the thread id, the reason for its suspension, the
continuation address, and a pointer to the current exception frame. In
addition, the stack of the thread may be saved in the thread node. In
order to relocate the exception handler chain when a thread is
restored, the base address of the stack is saved in the thread node as
well.

Thread nodes can be linked via the {\Tt{}next\nwendquote} field into a thread queue.
Suspended threads are added to the wait queue of the corresponding
variable or queue-me node. The runnable threads are collected in the
ready list {\Tt{}rq\nwendquote}.

A thread may be part of more than one queue. In this case, a surrogate
which points to the actual thread state is inserted into the queue.
All surrogates for a thread are linked in a ring and their state
pointer is set to {\Tt{}0\nwendquote} when the thread is woken through one of the
surrogates. The otherwise unused thread id {\Tt{}0\nwendquote} is used to mark
surrogates.

We maintain the invariant that the head of the ready queue is never a
surrogate whose state pointer is {\Tt{}0\nwendquote}. Thus, it is safe to use
{\Tt{}rq\ !=\ 0\nwendquote} in order to check for other runnable threads.

\ToDo{Instead of setting the state pointer to {\Tt{}0\nwendquote} the surrogates
should be removed from their queues. This requires to record the nodes
which maintain those queues in the surrogates.}

\nwenddocs{}\nwbegincode{5}\sublabel{NW2D2Ose-1K10J3-2}\nwmargintag{{\nwtagstyle{}\subpageref{NW2D2Ose-1K10J3-2}}}\moddef{threads.h~{\nwtagstyle{}\subpageref{NW2D2Ose-1K10J3-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW2D2Ose-1K10J3-1}{NW2D2Ose-1K10J3-3}\nwenddeflinemarkup
#if 0
typedef union thread_node *ThreadQueue; /* already declared in heap.h */
#endif

#define THREAD_INFO \\
    NodeInfo         *info; \\
    unsigned int     id;                /* (unique) thread id */ \\
    ThreadQueue      next;              /* link to next thread of queue */

struct thread_state \{
    THREAD_INFO
    int              reason;            /* reason for suspension */
    Label            ip;                /* next instruction to be executed */
    ExceptionFrame   *efp;              /* pointer to exception frame */
    Node             **ds_base;         /* base address of stack */
    unsigned int     ds_size;           /* size of data stack (segment) */
    Node             *ds;               /* saved data stack */
\};

struct thread_surrogate \{
    THREAD_INFO
    ThreadQueue      thd;               /* pointer to the "real" thread */
    ThreadQueue      link;              /* ring of surrogates for the thread */
\};

union thread_node \{
    struct thread_state     t;
    struct thread_surrogate s;
\};

extern ThreadQueue rq;

\nwendcode{}\nwbegindocs{6}\nwdocspar
\nwenddocs{}\nwbegincode{7}\sublabel{NW2D2Ose-3yVYBR-2}\nwmargintag{{\nwtagstyle{}\subpageref{NW2D2Ose-3yVYBR-2}}}\moddef{threads.c~{\nwtagstyle{}\subpageref{NW2D2Ose-3yVYBR-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW2D2Ose-3yVYBR-1}{NW2D2Ose-3yVYBR-3}\nwenddeflinemarkup
#define thread_node_size        wordsof(union thread_node)
#define thread_state_size       wordsof(struct thread_state)
#define thread_surrogate_size   wordsof(struct thread_surrogate)

static const int ot_thread[] = \{
    2,
    word_offsetof(struct thread_state, next),
    word_offsetof(struct thread_state, ds)
\};
static NodeInfo thread_info = \{
    THREAD_TAG, thread_state_size, ot_thread, (Label)no_eval, (const char *)0,
    (FinalFun)0
\};

static const int ot_surrogate[] = \{
    3,
    word_offsetof(struct thread_surrogate, next),
    word_offsetof(struct thread_surrogate, thd),
    word_offsetof(struct thread_surrogate, link)
\};
static NodeInfo surrogate_info = \{
    THREAD_TAG, thread_surrogate_size, ot_surrogate, (Label)no_eval,
    (const char *)0, (FinalFun)0
\};

ThreadQueue rq;

\nwendcode{}\nwbegindocs{8}\nwdocspar
The thread state includes the reason why the thread was interrupted.
Possible reasons are {\Tt{}None\nwendquote} in case of a fork and {\Tt{}Yield\nwendquote} if the
thread was performing a yield. The reasons {\Tt{}Eval\nwendquote} and {\Tt{}Delay\nwendquote} are
used if the thread is suspended due to a queue-me and unbound variable
node, respectively.

\nwenddocs{}\nwbegincode{9}\sublabel{NW2D2Ose-1K10J3-3}\nwmargintag{{\nwtagstyle{}\subpageref{NW2D2Ose-1K10J3-3}}}\moddef{threads.h~{\nwtagstyle{}\subpageref{NW2D2Ose-1K10J3-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW2D2Ose-1K10J3-2}{NW2D2Ose-1K10J3-4}\nwenddeflinemarkup
enum suspend_reason \{
    None,                       /* interrupted */
    Yield,                      /* rescheduled due non-determinism */
    Delay,                      /* suspended due to unbound variable */
    Eval                        /* suspended due to locked application */
\};

\nwendcode{}\nwbegindocs{10}\nwdocspar
\nwenddocs{}\nwbegincode{11}\sublabel{NW2D2Ose-3yVYBR-3}\nwmargintag{{\nwtagstyle{}\subpageref{NW2D2Ose-3yVYBR-3}}}\moddef{threads.c~{\nwtagstyle{}\subpageref{NW2D2Ose-3yVYBR-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW2D2Ose-3yVYBR-2}{NW2D2Ose-3yVYBR-4}\nwenddeflinemarkup
static const char   *reasons[] = \{ "None", "Yield", "Delay", "Eval" \};

\nwendcode{}\nwbegindocs{12}\nwdocspar
The interface to the thread management code consists of eight global
functions and the entry-point {\Tt{}stop{\_}thread\nwendquote}. The function
{\Tt{}start{\_}thread\nwendquote} starts a new thread, {\Tt{}stop{\_}thread\nwendquote} terminates the
current thread, and the functions {\Tt{}suspend{\_}thread\nwendquote} and
{\Tt{}delay{\_}thread\nwendquote} suspend the current thread and add this thread to the
wait queue of node {\Tt{}n\nwendquote}. The former is intended to be used for locked
suspended applications, the latter for unbound variables. The function
{\Tt{}yield{\_}thread\nwendquote} interrupts the current thread and moves it to the end
of the ready queue. The function {\Tt{}yield{\_}delay{\_}thread\nwendquote} is a
combination of {\Tt{}yield{\_}thread\nwendquote} and {\Tt{}delay{\_}thread\nwendquote}. It interrupts
the running thread and moves it to the end of the ready queue. In
addition, the running thread is inserted into the wait queue of a
variable so that it will be woken when that variable is bound.

The functions {\Tt{}activate{\_}threads\nwendquote} and {\Tt{}wake{\_}threads\nwendquote} wake a list of
suspended threads. Whereas {\Tt{}activate{\_}threads\nwendquote} interrupts the current
thread and activates the first woken thread immediately, the running
thread remains active when {\Tt{}wake{\_}threads\nwendquote} is used. The last
function, {\Tt{}join{\_}queues\nwendquote}, concatenates the two thread queues {\Tt{}tq1\nwendquote}
and {\Tt{}tq2\nwendquote}.

\nwenddocs{}\nwbegincode{13}\sublabel{NW2D2Ose-1K10J3-4}\nwmargintag{{\nwtagstyle{}\subpageref{NW2D2Ose-1K10J3-4}}}\moddef{threads.h~{\nwtagstyle{}\subpageref{NW2D2Ose-1K10J3-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW2D2Ose-1K10J3-3}{NW2D2Ose-1K10J3-5}\nwenddeflinemarkup
extern void start_thread(unsigned int n);
DECLARE_ENTRYPOINT(stop_thread);
extern Label suspend_thread(Label l, Node *n);
extern Label delay_thread(Label l, Node *n);
extern Label yield_thread(Label l);
extern Label yield_delay_thread(Label l, Node *n);
extern Label activate_threads(ThreadQueue wq, Label l);
extern void wake_threads(ThreadQueue wq);
extern ThreadQueue join_queues(ThreadQueue tq1, ThreadQueue tq2);

\nwendcode{}\nwbegindocs{14}\nwdocspar
The function {\Tt{}save{\_}continuation\nwendquote} saves the current state of the
abstract machine with respect to the current search context in a
search continuation. When the search continuation is restored, the
execution continues at the specified code address. The different
search continuations at a non-deterministic alternative in the code
differ only in the continuation address. The functions
{\Tt{}restore{\_}continuation\nwendquote} and {\Tt{}resume{\_}continuation\nwendquote} restore a search
continuation in the current search context. The difference between
both functions is that the running thread remains active when the
continuation is restored with {\Tt{}restore{\_}continuation\nwendquote} and the
runnable threads of the continuation will be activated when they
current thread stops or suspends. In contrast, the function
{\Tt{}resume{\_}continuation\nwendquote} will interrupt the current thread and activate
the running thread of the search continuation immediately.

\nwenddocs{}\nwbegincode{15}\sublabel{NW2D2Ose-1K10J3-5}\nwmargintag{{\nwtagstyle{}\subpageref{NW2D2Ose-1K10J3-5}}}\moddef{threads.h~{\nwtagstyle{}\subpageref{NW2D2Ose-1K10J3-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW2D2Ose-1K10J3-4}{\relax}\nwenddeflinemarkup
extern Node *save_continuation(Label l, Node **ds_base);
extern void restore_continuation(Node *cont);
extern Label resume_continuation(Node *cont);

\nwendcode{}\nwbegindocs{16}\nwdocspar
\nwenddocs{}\nwbegincode{17}\sublabel{NW2D2Ose-3yVYBR-4}\nwmargintag{{\nwtagstyle{}\subpageref{NW2D2Ose-3yVYBR-4}}}\moddef{threads.c~{\nwtagstyle{}\subpageref{NW2D2Ose-3yVYBR-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW2D2Ose-3yVYBR-3}{NW2D2Ose-3yVYBR-5}\nwenddeflinemarkup
static void new_thread(void);
static Label activate_thread(void);
static void terminate_thread(void);
static ThreadQueue interrupt_thread(Label, enum suspend_reason);
static ExceptionFrame *relocate_thread(ExceptionFrame *, int);

static NodeInfo saved_stack_info = \{
    0, 0, (const int *)0, (Label)no_eval, (const char *)0, (FinalFun)0
\};

\nwendcode{}\nwbegindocs{18}\nwdocspar
The function {\Tt{}start{\_}thread\nwendquote} starts a new thread. It uses the stack
frames from the top of the stack to initialize the new thread. The
size of these frames is passed as an argument to {\Tt{}start{\_}thread\nwendquote}. The
current thread is interrupted and will continue its execution at the
return address found at the bottom of the new thread's stack when it
is resumed. If this return address is {\Tt{}0\nwendquote}, {\Tt{}start{\_}thread\nwendquote} assumes
that it is creating the initial thread of the program or an
encapsulated search and therefore no thread is interrupted. The return
address at the bottom of the new thread's stack is replaced by
{\Tt{}stop{\_}thread\nwendquote} so that the thread is terminated automatically when it
returns from the bottom frame.

\nwenddocs{}\nwbegincode{19}\sublabel{NW2D2Ose-3yVYBR-5}\nwmargintag{{\nwtagstyle{}\subpageref{NW2D2Ose-3yVYBR-5}}}\moddef{threads.c~{\nwtagstyle{}\subpageref{NW2D2Ose-3yVYBR-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW2D2Ose-3yVYBR-4}{NW2D2Ose-3yVYBR-6}\nwenddeflinemarkup
void
start_thread(unsigned int n)
\{
    ThreadQueue thd;
    Label       contIp;

    ASSERT(n > 0);

    /* start a new thread */
    contIp = (Label)sp[n-1];
    if ( contIp != (Label)0 )
    \{
        thd         = interrupt_thread(contIp, None);
        thd->t.next = rq;
        rq          = thd;
    \}
    new_thread();
    TRACE(("%I starting\\n"));

    /* move the initial stack to the new thread */
    ds_base += n;
    if ( rq != (ThreadQueue)0 )
        rq->t.ds_size -= n;

    /* save the ultimate return address */
    sp[n-1] = (Node *)stop_thread;
\}

\nwendcode{}\nwbegindocs{20}\nwdocspar
The {\Tt{}stop{\_}thread\nwendquote} code terminates the current thread and
activates the next thread from the ready queue.

\nwenddocs{}\nwbegincode{21}\sublabel{NW2D2Ose-3yVYBR-6}\nwmargintag{{\nwtagstyle{}\subpageref{NW2D2Ose-3yVYBR-6}}}\moddef{threads.c~{\nwtagstyle{}\subpageref{NW2D2Ose-3yVYBR-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW2D2Ose-3yVYBR-5}{NW2D2Ose-3yVYBR-7}\nwenddeflinemarkup
FUNCTION(stop_thread)
\{
    EXPORT_LABEL(stop_thread)
 ENTRY_LABEL(stop_thread)

    TRACE(("%I terminated\\n"));
    terminate_thread();
    GOTO(activate_thread());
\}

\nwendcode{}\nwbegindocs{22}\nwdocspar
The functions {\Tt{}suspend{\_}thread\nwendquote} and {\Tt{}delay{\_}thread\nwendquote} suspend the
current thread and add it to the wait queue of the specified node.
This node should be either a queue-me node ({\Tt{}suspend{\_}thread\nwendquote}) or an
unbound variable ({\Tt{}delay{\_}thread\nwendquote}). If the node is not local to the
current search space, the current encapsulated search is suspended.

\nwenddocs{}\nwbegincode{23}\sublabel{NW2D2Ose-3yVYBR-7}\nwmargintag{{\nwtagstyle{}\subpageref{NW2D2Ose-3yVYBR-7}}}\moddef{threads.c~{\nwtagstyle{}\subpageref{NW2D2Ose-3yVYBR-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW2D2Ose-3yVYBR-6}{NW2D2Ose-3yVYBR-8}\nwenddeflinemarkup
Label
suspend_thread(Label l, Node *susp)
\{
    ThreadQueue thd;

    ASSERT(is_boxed(susp) && (is_suspend_node(susp) || is_queueMe_node(susp)));
    if ( !is_local_space(susp->q.spc) )
        return suspend_search(l, susp, Eval);

    \{
        ADD_LOCAL_ROOTS1(susp);
#define susp LOCAL_ROOT[0]
        thd = interrupt_thread(l, Eval);
        SAVE(susp, q.wq);
        thd->t.next = susp->q.wq;
        susp->q.wq  = thd;
#undef susp
        DROP_LOCAL_ROOTS();
    \}
    return activate_thread();
\}

Label
delay_thread(Label l, Node *var)
\{
    ThreadQueue thd;

    ASSERT(is_boxed(var) && is_variable_node(var));
    if ( !is_local_space(var->v.spc) )
        return suspend_search(l, var, Delay);

    \{
        ADD_LOCAL_ROOTS1(var);
#define var LOCAL_ROOT[0]
        thd = interrupt_thread(l, Delay);
        SAVE(var, v.wq);
        thd->t.next = var->v.wq;
        var->v.wq   = thd;
#undef var
        DROP_LOCAL_ROOTS();
    \}
    return activate_thread();
\}

\nwendcode{}\nwbegindocs{24}\nwdocspar
The functions {\Tt{}yield{\_}thread\nwendquote} and {\Tt{}yield{\_}delay{\_}thread\nwendquote} interrupt
the current thread and move it to the end of the ready queue. The
function {\Tt{}yield{\_}delay{\_}thread\nwendquote} also adds the thread to the wait queue
of the specified variable so that it is woken when the variable is
bound.

\nwenddocs{}\nwbegincode{25}\sublabel{NW2D2Ose-3yVYBR-8}\nwmargintag{{\nwtagstyle{}\subpageref{NW2D2Ose-3yVYBR-8}}}\moddef{threads.c~{\nwtagstyle{}\subpageref{NW2D2Ose-3yVYBR-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW2D2Ose-3yVYBR-7}{NW2D2Ose-3yVYBR-9}\nwenddeflinemarkup
Label
yield_thread(Label l)
\{
    ThreadQueue thd;

    if ( rq == (ThreadQueue)0 )
        return l;

    thd = interrupt_thread(l, Yield);
    rq  = join_queues(rq, thd);
    return activate_thread();
\}

Label
yield_delay_thread(Label l, Node *var)
\{
    ThreadQueue thd;

    ASSERT(is_boxed(var) && is_variable_node(var));
    if ( !is_local_space(var->v.spc) )
        return suspend_search(l, var, Delay);

    if ( rq == (ThreadQueue)0 )
        return l;

    \{
        ADD_LOCAL_ROOTS2(var, (Node *)0);
#define var LOCAL_ROOT[0]
#define thd1 (ThreadQueue)LOCAL_ROOT[1]

        ASSERT(is_boxed(var) && is_variable_node(var));
        thd1 = interrupt_thread(l, Yield);

        CHECK_HEAP(2*thread_surrogate_size);
        SAVE(var, v.wq);
        thd         = (ThreadQueue)hp;
        thd->s.info = &surrogate_info;
        thd->s.id   = 0;
        thd->s.thd  = thd1;
        thd->s.next = var->v.wq;
        thd->s.link = (ThreadQueue)(hp + thread_surrogate_size);
        var->v.wq   = thd;

        thd         = (ThreadQueue)(hp + thread_surrogate_size);
        thd->s.info = &surrogate_info;
        thd->s.id   = 0;
        thd->s.thd  = thd1;
        thd->s.next = (ThreadQueue)0;
        thd->s.link = (ThreadQueue)hp;
        hp         += 2*thread_surrogate_size;
#undef thd1
#undef var
        DROP_LOCAL_ROOTS();
    \}

    rq  = join_queues(rq, thd);
    return activate_thread();
\}

\nwendcode{}\nwbegindocs{26}\nwdocspar
The functions {\Tt{}activate{\_}threads\nwendquote} and {\Tt{}wake{\_}threads\nwendquote} wake a list of
suspended threads and insert them at the head of the ready queue. If
the function {\Tt{}activate{\_}threads\nwendquote} is called, the current thread is
interrupted before this operation and the first of the woken threads
is activated. On the other hand, if the function {\Tt{}wake{\_}threads\nwendquote} is
called the current thread remains active.

\nwenddocs{}\nwbegincode{27}\sublabel{NW2D2Ose-3yVYBR-9}\nwmargintag{{\nwtagstyle{}\subpageref{NW2D2Ose-3yVYBR-9}}}\moddef{threads.c~{\nwtagstyle{}\subpageref{NW2D2Ose-3yVYBR-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW2D2Ose-3yVYBR-8}{NW2D2Ose-3yVYBR-A}\nwenddeflinemarkup
Label
activate_threads(ThreadQueue wq, Label l)
\{
    ThreadQueue thd;

    while ( wq != (ThreadQueue)0 && wq->t.id == 0
            && wq->s.thd == (ThreadQueue)0 )
        wq = wq->t.next;
    if ( wq == (ThreadQueue)0 )
        return l;

    \{
        ADD_LOCAL_ROOTS1((Node *)wq);
#define wq (ThreadQueue)LOCAL_ROOT[0]
        thd             = interrupt_thread(l, None);
        thd->t.next = rq;
        rq              = join_queues(wq, thd);
#undef wq
        DROP_LOCAL_ROOTS();
    \}
    return activate_thread();
\}

void
wake_threads(ThreadQueue wq)
\{
    while ( wq != (ThreadQueue)0 && wq->t.id == 0
            && wq->s.thd == (ThreadQueue)0 )
        wq = wq->t.next;
    rq = join_queues(wq, rq);
\}

\nwendcode{}\nwbegindocs{28}\nwdocspar
The function {\Tt{}join{\_}queues\nwendquote} combines the two thread-queues {\Tt{}tq1\nwendquote}
and {\Tt{}tq2\nwendquote} such that the resulting queue starts with the threads
from {\Tt{}tq1\nwendquote} followed by those from {\Tt{}tq2\nwendquote}.

\nwenddocs{}\nwbegincode{29}\sublabel{NW2D2Ose-3yVYBR-A}\nwmargintag{{\nwtagstyle{}\subpageref{NW2D2Ose-3yVYBR-A}}}\moddef{threads.c~{\nwtagstyle{}\subpageref{NW2D2Ose-3yVYBR-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW2D2Ose-3yVYBR-9}{NW2D2Ose-3yVYBR-B}\nwenddeflinemarkup
ThreadQueue
join_queues(ThreadQueue tq1, ThreadQueue tq2)
\{
    ThreadQueue tq;

    /* return the other queue if one queue is empty */
    if ( tq1 == (ThreadQueue)0 )
        tq = tq2;
    else if ( tq2 == (ThreadQueue)0 )
        tq = tq1;

    /* otherwise append tq2 to tq1 (destructively) */
    else
    \{
        tq = tq1;
        while ( tq1->t.next != (ThreadQueue)0 )
            tq1 = tq1->t.next;
        SAVE(tq1, t.next);
        tq1->t.next = tq2;
    \}

    return tq;
\}

\nwendcode{}\nwbegindocs{30}\nwdocspar
The function {\Tt{}new{\_}thread\nwendquote} allocates a new thread frame and makes it
the running thread.

\nwenddocs{}\nwbegincode{31}\sublabel{NW2D2Ose-3yVYBR-B}\nwmargintag{{\nwtagstyle{}\subpageref{NW2D2Ose-3yVYBR-B}}}\moddef{threads.c~{\nwtagstyle{}\subpageref{NW2D2Ose-3yVYBR-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW2D2Ose-3yVYBR-A}{NW2D2Ose-3yVYBR-C}\nwenddeflinemarkup
static void
new_thread()
\{
    /* initialize the thread state */
    if ( tid == 0 )
        tid++;
    cid     = tid++;
    ds_base = sp;
    efp     = (ExceptionFrame *)0;
\}

\nwendcode{}\nwbegindocs{32}\nwdocspar
The function {\Tt{}activate{\_}thread\nwendquote} activates the first thread of the
ready queue. If the ready queue is empty the function jumps to the
deadlock handler of the current context.

\nwenddocs{}\nwbegincode{33}\sublabel{NW2D2Ose-3yVYBR-C}\nwmargintag{{\nwtagstyle{}\subpageref{NW2D2Ose-3yVYBR-C}}}\moddef{threads.c~{\nwtagstyle{}\subpageref{NW2D2Ose-3yVYBR-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW2D2Ose-3yVYBR-B}{NW2D2Ose-3yVYBR-D}\nwenddeflinemarkup
static Label
activate_thread()
\{
    Label               ip;
    ThreadQueue         thd, sur;
    enum suspend_reason reason;

    /* check for a deadlock */
    if ( rq == (ThreadQueue)0 )
        return nondet_handlers.deadlock;

    /* activate the head of the ready queue */
    thd = rq;
    rq  = thd->t.next;
    while ( rq != (ThreadQueue)0 && rq->t.id == 0
            && rq->s.thd == (ThreadQueue)0 )
        rq = rq->t.next;
    if ( thd->t.id == 0 )
    \{
        sur = thd;
        thd = (ThreadQueue)sur->s.thd;
        ASSERT(thd->t.id != 0);
        while ( sur->s.thd != (ThreadQueue)0 )
        \{
            ASSERT(sur->s.id == 0 && sur->s.link != (ThreadQueue)0);
            SAVE(sur, s.thd);
            sur->s.thd = (ThreadQueue)0;
            sur        = sur->s.link;
        \}
    \}
    cid    = thd->t.id;
    ip     = thd->t.ip;
    reason = (enum suspend_reason)thd->t.reason;

    /* eventually restore the stack */
    if ( thd->t.ds != (Node *)0 )
    \{
        CHECK_STACK(thd->t.ds_size);
        ASSERT(thd->t.ds_size == vector_argc(thd->t.ds));
        ds_base = sp;
        sp     -= thd->t.ds_size;
        memcpy(sp, thd->t.ds->a.args, thd->t.ds_size * word_size);
    \}
    else
        ds_base = sp + thd->t.ds_size;

    /* eventually relocate the exception handler chain */
    efp = thd->t.efp;
    if ( efp != (ExceptionFrame *)0 && ds_base != thd->t.ds_base )
        efp = relocate_thread(efp, ds_base - thd->t.ds_base);

    /* return the continuation address of the thread */
    if ( reason != None )
        TRACE(("%I resume (%s)\\n", reasons[reason]));
    return ip;
\}

\nwendcode{}\nwbegindocs{34}\nwdocspar
The function {\Tt{}terminate{\_}thread\nwendquote} terminates the current thread and frees
its stack.

\nwenddocs{}\nwbegincode{35}\sublabel{NW2D2Ose-3yVYBR-D}\nwmargintag{{\nwtagstyle{}\subpageref{NW2D2Ose-3yVYBR-D}}}\moddef{threads.c~{\nwtagstyle{}\subpageref{NW2D2Ose-3yVYBR-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW2D2Ose-3yVYBR-C}{NW2D2Ose-3yVYBR-E}\nwenddeflinemarkup
static void
terminate_thread()
\{
    /* deallocate the current thread */
    sp  = ds_base;
\}

\nwendcode{}\nwbegindocs{36}\nwdocspar
The function {\Tt{}interrupt{\_}thread\nwendquote} interrupts the current thread and
returns a thread node for it. The data stack is saved to the heap
except if the thread was interrupted with reason {\Tt{}None\nwendquote}.

\nwenddocs{}\nwbegincode{37}\sublabel{NW2D2Ose-3yVYBR-E}\nwmargintag{{\nwtagstyle{}\subpageref{NW2D2Ose-3yVYBR-E}}}\moddef{threads.c~{\nwtagstyle{}\subpageref{NW2D2Ose-3yVYBR-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW2D2Ose-3yVYBR-D}{NW2D2Ose-3yVYBR-F}\nwenddeflinemarkup
static ThreadQueue
interrupt_thread(Label l, enum suspend_reason reason)
\{
    Node         *ds;
    ThreadQueue  thd;
    boolean      save_ds = reason != None;
    unsigned int ds_size = ds_base - sp;

    CHECK_HEAP(thread_state_size + (save_ds ? vector_node_size(ds_size) : 0));

    if ( reason != None )
        TRACE(("%I suspend (%s)\\n", reasons[reason]));

    /* eventually save the stack */
    if ( save_ds )
    \{
        ds           = (Node *)hp;
        ds->a.info   = &saved_stack_info;
        ds->a.length = vector_node_size(ds_size);
        memcpy(ds->a.args, sp, ds_size * word_size);
        hp          += vector_node_size(ds_size);
        sp           = ds_base;
    \}
    else
        ds = (Node *)0;

    /* save the thread state */
    ASSERT(cid != 0);
    thd            = (ThreadQueue)hp;
    thd->t.info    = &thread_info;
    thd->t.id      = cid;
    thd->t.next    = (ThreadQueue)0;
    thd->t.reason  = reason;
    thd->t.ip      = l;
    thd->t.efp     = efp;
    thd->t.ds_base = ds_base;
    thd->t.ds_size = ds_size;
    thd->t.ds      = ds;
    hp            += thread_state_size;

    /* return the thread */
    return thd;
\}

\nwendcode{}\nwbegindocs{38}\nwdocspar
The function {\Tt{}relocate{\_}thread\nwendquote} relocates the exception handler chain
when a thread is restored to a different stack offset.

\nwenddocs{}\nwbegincode{39}\sublabel{NW2D2Ose-3yVYBR-F}\nwmargintag{{\nwtagstyle{}\subpageref{NW2D2Ose-3yVYBR-F}}}\moddef{threads.c~{\nwtagstyle{}\subpageref{NW2D2Ose-3yVYBR-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW2D2Ose-3yVYBR-E}{NW2D2Ose-3yVYBR-G}\nwenddeflinemarkup
static ExceptionFrame *
relocate_thread(ExceptionFrame *efp, int dist)
\{
    ExceptionFrame *fp;

    if ( efp != (ExceptionFrame *)0 )
    \{
        efp = (ExceptionFrame *)((Node **)efp + dist);
        for ( fp = efp; fp->frame != (ExceptionFrame *)0; fp = fp->frame )
            fp->frame = (ExceptionFrame *)((Node **)fp->frame + dist);
    \}

    return efp;
\}

\nwendcode{}\nwbegindocs{40}\nwdocspar
When the abstract machine returns from an encapsulated search it
saves the current state of the computation in a search
continuation. The information saved includes the data stack --
relative to the current search context -- the current ready queue, and
the instruction address where execution continues. The saved state,
except for the continuation address, can be shared among the different
alternative continuations in a non-deterministic branch point of the
program.

\nwenddocs{}\nwbegincode{41}\sublabel{NW2D2Ose-3yVYBR-G}\nwmargintag{{\nwtagstyle{}\subpageref{NW2D2Ose-3yVYBR-G}}}\moddef{threads.c~{\nwtagstyle{}\subpageref{NW2D2Ose-3yVYBR-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW2D2Ose-3yVYBR-F}{\relax}\nwenddeflinemarkup
Node *
save_continuation(Label l, Node **ds_base)
\{
    unsigned int ds_size = ds_base - sp;
    Node         *cont, *savedDs;
    ThreadQueue  thd;

    ASSERT(ds_size >= 0);

    /* interrupt the current thread */
    thd         = interrupt_thread((Label)0, None);
    thd->t.next = rq;
    rq          = thd;

    /* save the current machine state */
    CHECK_HEAP(search_cont_node_size + vector_node_size(ds_size));

    savedDs           = (Node *)hp;
    savedDs->a.info   = &saved_stack_info;
    savedDs->a.length = vector_node_size(ds_size);
    memcpy(savedDs->a.args, sp, ds_size * word_size);
    hp               += vector_node_size(ds_size);

    /* save the state into a new search continuation */
    cont          = (Node *)hp;
    cont->sc.info = &search_cont_info;
    cont->sc.code = l;
    cont->sc.susp = (Node *)0;
    cont->sc.var  = (Node *)0;
    cont->sc.ds   = savedDs;
    cont->sc.rq   = rq;
    cont->sc.spc  = ss;
    hp           += search_cont_node_size;

    /* return the search continuation */
    return cont;
\}

void
restore_continuation(Node *cont)
\{
    unsigned int ds_size;
    ThreadQueue  tq;

    ASSERT(is_search_cont_node(cont));

    /* check for enough space on the stack */
    ds_size = vector_argc(cont->sc.ds);
    CHECK_STACK(ds_size);

    /* move the data stack of the current thread */
    memcpy(sp - ds_size, sp, (ds_base - sp)*word_size);
    sp      -= ds_size;
    ds_base -= ds_size;
    if ( efp != (ExceptionFrame *)0 )
        efp = relocate_thread(efp, -ds_size);

    /* restore the continuation's data stack below the current stack */
    memcpy(ds_base, cont->sc.ds->a.args, ds_size*word_size);

    /* update the continuation address of the first restored thread */
    tq = cont->sc.rq;
    ASSERT(tq != (ThreadQueue)0 && tq->t.id != 0);
    tq->t.ip = cont->sc.code;

    /* wake all threads of the search space and add them to the ready queue */
    wake_threads(tq);
\}

Label
resume_continuation(Node *cont)
\{
    unsigned int ds_size;

    ASSERT(is_search_cont_node(cont));

    /* check for enough space on the stacks */
    ds_size = vector_argc(cont->sc.ds);
    CHECK_STACK(ds_size);

    /* restore the continuation's ready queue */
    ASSERT(cont->sc.rq != (ThreadQueue)0 && cont->sc.rq->t.id != 0);
    rq = cont->sc.rq;

    /* restore the continuation's data stack */
    sp -= ds_size;
    memcpy(sp, cont->sc.ds->a.args, ds_size*word_size);

    /* update the continuation address of the first restored thread */
    rq->t.ip = cont->sc.code;

    /* activate the first thread */
    return activate_thread();
\}
\nwendcode{}

\nwixlogsorted{c}{{threads.c}{NW2D2Ose-3yVYBR-1}{\nwixd{NW2D2Ose-3yVYBR-1}\nwixd{NW2D2Ose-3yVYBR-2}\nwixd{NW2D2Ose-3yVYBR-3}\nwixd{NW2D2Ose-3yVYBR-4}\nwixd{NW2D2Ose-3yVYBR-5}\nwixd{NW2D2Ose-3yVYBR-6}\nwixd{NW2D2Ose-3yVYBR-7}\nwixd{NW2D2Ose-3yVYBR-8}\nwixd{NW2D2Ose-3yVYBR-9}\nwixd{NW2D2Ose-3yVYBR-A}\nwixd{NW2D2Ose-3yVYBR-B}\nwixd{NW2D2Ose-3yVYBR-C}\nwixd{NW2D2Ose-3yVYBR-D}\nwixd{NW2D2Ose-3yVYBR-E}\nwixd{NW2D2Ose-3yVYBR-F}\nwixd{NW2D2Ose-3yVYBR-G}}}%
\nwixlogsorted{c}{{threads.h}{NW2D2Ose-1K10J3-1}{\nwixd{NW2D2Ose-1K10J3-1}\nwixd{NW2D2Ose-1K10J3-2}\nwixd{NW2D2Ose-1K10J3-3}\nwixd{NW2D2Ose-1K10J3-4}\nwixd{NW2D2Ose-1K10J3-5}}}%

