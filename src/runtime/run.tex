\nwfilename{run.nw}\nwbegindocs{0}% -*- noweb-code-mode: c-mode -*-% ===> this file was generated automatically by noweave --- better not edit it
% $Id: run.nw,v 2.5 2003/06/10 20:12:14 wlux Exp $
%
% Copyright (c) 2001-2003, Wolfgang Lux
% See ../LICENSE for the full license.
%
\subsection{Execution}\label{sec:execution}
While C can be used conveniently as a ``high-level'' assembly
language, there is one gap which complicates the efficient
implementation of declarative languages, viz. the lack of a general
tail-call in the language.\footnote{The Gnu C compiler optimizes
tail-calls into jumps to the beginning of the function. However,
this works only for calls to the same function.}

There are various possible strategies known to handle this
problem. The most simple solution is to provide a trampoline loop. If
a function wants to perform a tail call, it simply returns the address
of the callee to the trampoline, which then in turn calls this
function. This strategy is portable but inefficient because of its
additional overhead.

A more efficient solution is possible for the Gnu C compiler. With the
help of assembler labels inserted into the code and using computed
\texttt{goto}s, a tail call is performed by jumping directly to these
labels. Implemented this way, the standard function prologue, which
sets up the local stack frame of the callee, is skipped over and no
additional stack space is allocated. The stack space is allocated in
the driver function, which now only has to jump the first code
address. This strategy will fail if the function prologue has to do
more work than just setting up a stack frame, it can therefore be
turned off by defining the pre-processor macro {\Tt{}USE{\_}TRAMPOLINE\nwendquote}.

The type of a code label, which can be used in a tail call, is either
a function which returns a {\Tt{}void\nwendquote} pointer\footnote{In fact, the
function returns another function with the same type. However, such a
recursive type cannot be declared in C.} or is itself a {\Tt{}void\nwendquote}
pointer in order to be used in (computed) \texttt{goto} statements.

\nwenddocs{}\nwbegincode{1}\sublabel{NWRhlo7-3ZVVIl-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWRhlo7-3ZVVIl-1}}}\moddef{run.h~{\nwtagstyle{}\subpageref{NWRhlo7-3ZVVIl-1}}}\endmoddef\nwstartdeflinemarkup\nwprevnextdefs{\relax}{NWRhlo7-3ZVVIl-2}\nwenddeflinemarkup
#if !USE_TRAMPOLINE
# ifndef __GNUC__
#  error "direct jumps require Gnu C; reconfigure with --enable-trampoline"
# endif
#endif

#if USE_TRAMPOLINE
typedef void *(*Label)(void);
#else
typedef void *Label;
#endif

\nwalsodefined{\\{NWRhlo7-3ZVVIl-2}\\{NWRhlo7-3ZVVIl-3}}\nwnotused{run.h}\nwendcode{}\nwbegindocs{2}\nwdocspar
Every code block of the abstract machine code will be translated into
a separate function. In case of the trampoline execution model, these
functions simply return to their caller (the trampoline) when they
want to perform a jump to another code block via the {\Tt{}GOTO\nwendquote} macro.

In case of the direct-jump model, which was derived from the
implementation of the Mercury runtime
system~\cite{HendersonConwaySomogyi95:Portable}, we use Gnu C's
ability to handle labels as values. With the extended assembler
feature of Gnu C we insert a label immediately after the function's
prologue. The macro {\Tt{}GOTO\nwendquote} then jumps directly to that label. By
renaming the function itself and adding a function declaration which
associates the function with its entry-point, we can simply use the
function name in both models to refer to the entry-point of a function.

There is a bug in some Gnu C implementations for the Intel x86
architecture, where arguments on the stack are not popped from the
stack before a {\Tt{}goto\nwendquote} to a label value, even if the
\texttt{-fno-defer-pop} option is used. For that reason we use the
{\Tt{}SP{\_}HACK\nwendquote} macro to insert code which resets the stack to pointer to
a fixed offset with respect to the frame pointer immediately after the
label. The inserted code carefully tries to maintain a 16-byte
alignment for the stack pointer taking into account the fixed 8 bytes
for the return address and the saved frame pointer.

\nwenddocs{}\nwbegincode{3}\sublabel{NWRhlo7-3ZVVIl-2}\nwmargintag{{\nwtagstyle{}\subpageref{NWRhlo7-3ZVVIl-2}}}\moddef{run.h~{\nwtagstyle{}\subpageref{NWRhlo7-3ZVVIl-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NWRhlo7-3ZVVIl-1}{NWRhlo7-3ZVVIl-3}\nwenddeflinemarkup
#if USE_TRAMPOLINE

# define FUNCTION(f)            void *f(void)
# define DECLARE_ENTRYPOINT(l)  extern void *l(void)
# define DECLARE_LABEL(l)       static void *l(void)
# define EXPORT_LABEL(l)
# define ENTRY_LABEL(l)

# define GOTO(l)                return (void *)(l)

#else /* !USE_TRAMPOLINE */

# define C_STACK_SIZE 8192

# if __GNUC__ > 2 || __GNUC__ == 2 && __GNUC_MINOR__ > 7
#  define stringify_value(x) stringify(x)
#  define stringify(x)       #x
#  if defined(__i386)
#   define SP_OFFSET (-C_STACK_SIZE+(C_STACK_SIZE+8)%%16)
#   define SP_HACK "leal " stringify_value(SP_OFFSET) "(%%ebp),%%esp\\n"
#  endif
# endif
# ifndef SP_HACK
#  define SP_HACK
# endif

# define FUNCTION(f)            void _FUNC(f)(void)
# define DECLARE_ENTRYPOINT(l) \\
    void _FUNC(l)(void); \\
    void l(void) __asm__(_ENTRY_LABEL(l))
# define DECLARE_LABEL(l) \\
    static void _FUNC(l)(void); \\
    void l(void) __asm__(_ENTRY_LABEL(l))
# define _FUNC(f) f##_func
# define EXPORT_LABEL(l)        __asm__(" .globl " _ENTRY_LABEL(l) "\\n");
# define ENTRY_LABEL(l) \\
        __asm__(_ENTRY_LABEL(l) ":" SP_HACK : : "g" (_FUNC(l)));
# define _ENTRY_LABEL(l)        #l "_entry"

# if __GNUC__ == 2 && __GNUC_MINOR__ == 91 && defined(__sparc)
/* work around an instruction scheduler bug in gcc 2.91 for sparc */
extern Label ip;
#  define GOTO(l) do \{ ip = (Label)(l); goto *ip; \} while ( 0 )
# else
#  define GOTO(l) goto *(Label)(l)
# endif

#endif /* !USE_TRAMPOLINE */

\nwendcode{}\nwbegindocs{4}\nwdocspar
The {\Tt{}run\nwendquote} function executes the compiled code starting at label
{\Tt{}ip\nwendquote}. The execution of the compiled code should be terminated by a
call to the {\Tt{}halt\nwendquote} function.

\nwenddocs{}\nwbegincode{5}\sublabel{NWRhlo7-3ZVVIl-3}\nwmargintag{{\nwtagstyle{}\subpageref{NWRhlo7-3ZVVIl-3}}}\moddef{run.h~{\nwtagstyle{}\subpageref{NWRhlo7-3ZVVIl-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NWRhlo7-3ZVVIl-2}{\relax}\nwenddeflinemarkup
extern void run(Label ip);
extern void halt(void) __attribute__ ((noreturn));

\nwendcode{}\nwbegindocs{6}\nwdocspar
If the runtime system is compiled with {\Tt{}USE{\_}TRAMPOLINE\nwendquote}, the {\Tt{}run\nwendquote}
function is a trampoline loop that repeatedly calls the function
returned from the previous call. In order to improve the efficiency,
the loop has been unrolled 8 times and does not perform a null-pointer
test. In order to stop the execution, a {\Tt{}longjmp\nwendquote} to the context
stored in {\Tt{}halt{\_}buf\nwendquote} has to be performed. This jump buffer is
initialized at the beginning of the {\Tt{}run\nwendquote} function.

\nwenddocs{}\nwbegincode{7}\sublabel{NWRhlo7-1VLc4d-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWRhlo7-1VLc4d-1}}}\moddef{run.c~{\nwtagstyle{}\subpageref{NWRhlo7-1VLc4d-1}}}\endmoddef\nwstartdeflinemarkup\nwprevnextdefs{\relax}{NWRhlo7-1VLc4d-2}\nwenddeflinemarkup
#include "config.h"
#include <setjmp.h>
#include "run.h"

static jmp_buf halt_buf;

#if USE_TRAMPOLINE
void
run(Label ip)
\{
    if ( setjmp(halt_buf) == 0 )
    \{
        while ( 1 )
        \{
            ip = (Label)(*ip)();
            ip = (Label)(*ip)();
            ip = (Label)(*ip)();
            ip = (Label)(*ip)();
            ip = (Label)(*ip)();
            ip = (Label)(*ip)();
            ip = (Label)(*ip)();
            ip = (Label)(*ip)();
        \}
    \}
\}
#endif /* USE_TRAMPOLINE */

\nwalsodefined{\\{NWRhlo7-1VLc4d-2}\\{NWRhlo7-1VLc4d-3}}\nwnotused{run.c}\nwendcode{}\nwbegindocs{8}\nwdocspar
If the runtime system uses direct jumps via the Gnu C extensions, the
{\Tt{}run\nwendquote} function initialize the {\Tt{}halt{\_}buf\nwendquote} structure and then calls
the auxiliary function {\Tt{}do{\_}run\nwendquote}. This function allocates a stack
which is large enough to handle the allocation requirements of all
functions in the program and then jumps to the entry-point of the
program. The compiled functions should never return but use a
{\Tt{}longjmp\nwendquote} in order to terminate the execution.

We must not allocate the stack in the {\Tt{}run\nwendquote} function because the
compiler may save some registers in the stack frame and their contents
would get overwritten by the tail called functions, otherwise.

\nwenddocs{}\nwbegincode{9}\sublabel{NWRhlo7-1VLc4d-2}\nwmargintag{{\nwtagstyle{}\subpageref{NWRhlo7-1VLc4d-2}}}\moddef{run.c~{\nwtagstyle{}\subpageref{NWRhlo7-1VLc4d-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NWRhlo7-1VLc4d-1}{NWRhlo7-1VLc4d-3}\nwenddeflinemarkup
#if !USE_TRAMPOLINE
# if __GNUC__ == 2 && __GNUC_MINOR__ == 91 && defined(__sparc)
/* needed to work around an instruction scheduler bug in gcc 2.91 for sparc */
Label ip;
# endif

static void do_run(Label ip);

void
run(Label ip)
\{
    if ( setjmp(halt_buf) == 0 )
        do_run(ip);
\}

static void
do_run(Label ip)
\{
    char dummy[C_STACK_SIZE];

    /* hack to avoid unused variable warning */
    __asm__("" : : "g"(dummy));

    goto *ip;
\}
#endif /* !USE_TRAMPOLINE */

\nwendcode{}\nwbegindocs{10}\nwdocspar
The {\Tt{}halt\nwendquote} function stops the execution of the abstract machine code
by performing a non-local jump to the context saved in the
{\Tt{}halt{\_}buf\nwendquote}.

\nwenddocs{}\nwbegincode{11}\sublabel{NWRhlo7-1VLc4d-3}\nwmargintag{{\nwtagstyle{}\subpageref{NWRhlo7-1VLc4d-3}}}\moddef{run.c~{\nwtagstyle{}\subpageref{NWRhlo7-1VLc4d-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NWRhlo7-1VLc4d-2}{\relax}\nwenddeflinemarkup
void
halt()
\{
    longjmp(halt_buf, 1);
\}
\nwendcode{}

\nwixlogsorted{c}{{run.c}{NWRhlo7-1VLc4d-1}{\nwixd{NWRhlo7-1VLc4d-1}\nwixd{NWRhlo7-1VLc4d-2}\nwixd{NWRhlo7-1VLc4d-3}}}%
\nwixlogsorted{c}{{run.h}{NWRhlo7-3ZVVIl-1}{\nwixd{NWRhlo7-3ZVVIl-1}\nwixd{NWRhlo7-3ZVVIl-2}\nwixd{NWRhlo7-3ZVVIl-3}}}%

