\nwfilename{trace.nw}\nwbegindocs{0}% -*- noweb-code-mode: c-mode -*-% ===> this file was generated automatically by noweave --- better not edit it
% $Id: trace.nw,v 2.7 2003/10/28 12:02:05 wlux Exp $
%
% Copyright (c) 2001-2003, Wolfgang Lux
% See ../LICENSE for the full license.
%
\subsection{Tracing}
The abstract machine provides a simple tracing facility. This is
implemented by the {\Tt{}trace\nwendquote} function which will print its arguments
to the standard error output. Like the {\Tt{}printf\nwendquote} function, the
{\Tt{}trace\nwendquote} function uses a format string to specify its output. The
following formatting directives are supported:
\begin{itemize}
\item {\Tt{}{\%}c\nwendquote} displays the next argument a single character
\item {\Tt{}{\%}d\nwendquote} displays the next argument as a signed decimal number
\item {\Tt{}{\%}g\nwendquote} displays the next argument as a floating point number
\item {\Tt{}{\%}u\nwendquote} displays the next argument as an unsigned decimal number
\item {\Tt{}{\%}s\nwendquote} displays the next argument as a string
\item {\Tt{}{\%}x\nwendquote} displays the next argument as an unsigned hexadecimal number
\item {\Tt{}{\%}A\nwendquote} displays the address of the node found as next argument
\item {\Tt{}{\%}I\nwendquote} displays the current thread id and indents the rest of
  the line according to the nesting depth of the current thread
\item {\Tt{}{\%}N\nwendquote} displays the node found as next argument
\item {\Tt{}{\%}V\nwendquote} the next argument is a counter and the second argument a
  pointer to an array of nodes. Each node is displayed preceded by a
  single blank
\end{itemize}

By using the {\Tt{}TRACE\nwendquote} macro, tracing can be enabled or disabled under
control of the global variable {\Tt{}do{\_}trace\nwendquote}.

\ToDo{The code for the \texttt{\%I} is not bulletproof. It assumes
that every address on the stack which is smaller than that of
{\Tt{}environ\nwendquote} is a return address. In addition, it assumes that all
return addresses on the stack are even.}

\nwenddocs{}\nwbegincode{1}\sublabel{NW43ObGg-48WaAE-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW43ObGg-48WaAE-1}}}\moddef{trace.h~{\nwtagstyle{}\subpageref{NW43ObGg-48WaAE-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
#define TRACE(x) do \{ if ( do_trace ) trace x; \} while ( 0 )

extern int do_trace;
void trace(const char *fmt, ...);

\nwnotused{trace.h}\nwendcode{}\nwbegindocs{2}\nwdocspar
\nwenddocs{}\nwbegincode{3}\sublabel{NW43ObGg-2455o2-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW43ObGg-2455o2-1}}}\moddef{trace.c~{\nwtagstyle{}\subpageref{NW43ObGg-2455o2-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
#include "config.h"
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include "run.h"
#include "heap.h"
#include "stack.h"
#include "threads.h"
#include "eval.h"
#include "char.h"
#include "trace.h"

#if 0
/* This variable must be defined by the main program */
int do_trace;
#endif

static void trace_showaddr(Node *node);
static void trace_shownode(int depth, Node *node);
static void trace_showapp(int depth, Node *node, unsigned argc, Node **argv);

void
trace(const char *fmt, ...)
\{
    va_list      ap;
    const char   *cp;
    Node         **fp, **argv;
    int          depth = do_trace - 1;
    unsigned int i, argc;
    extern char  **environ;

    va_start(ap, fmt);
    for ( cp = fmt; *cp != '\\0'; cp++ )
    \{
        if ( *cp == '%' )
            switch ( *++cp )
            \{
            case 'c':
                fprintf(stderr, "%c", va_arg(ap, int));
                break;
            case 'd':
                fprintf(stderr, "%d", va_arg(ap, int));
                break;
            case 'g':
                fprintf(stderr, "%g", va_arg(ap, double));
                break;
            case 's':
                fprintf(stderr, "%s", va_arg(ap, const char *));
                break;
            case 'u':
                fprintf(stderr, "%u", va_arg(ap, unsigned int));
                break;
            case 'x':
                fprintf(stderr, "%x", va_arg(ap, unsigned int));
                break;
            case 'A':
                trace_showaddr(va_arg(ap, Node *));
                break;
            case 'I':
                fprintf(stderr, "[%u]", cid);
                for ( fp = sp; fp < ds_base; fp++ )
                    if ( *fp != (Node *)0 && is_boxed(*fp)
                         && (char *)*fp < (char *)&environ
                         && (Label)*fp != update )
                        fputc(' ', stderr);
                break;
            case 'N':
                trace_shownode(depth, va_arg(ap, Node *));
                break;
            case 'V':
                argc = va_arg(ap, unsigned int);
                argv = va_arg(ap, Node **);
                for ( i = 0; i < argc; i++ )
                \{
                    fputc(' ', stderr);
                    trace_shownode(depth, argv[i]);
                \}
                break;
            default:
                fputc(*cp, stderr);
                break;
            \}
        else
            fputc(*cp, stderr);
    \}
    va_end(ap);
\}

static void
trace_showaddr(Node *node)
\{
    if ( node == (Node *)0 )
        fprintf(stderr, "-null-");
#if !ONLY_BOXED_OBJECTS
    else if ( is_unboxed(node) )
        fprintf(stderr, "-unboxed%ld-", unboxed_val(node));
#endif
    else if ( heap_base <= (word *)node && (word *)node <= heap_end )
        fprintf(stderr, "-node%u-", node - (Node *)heap_base);
    else
        fprintf(stderr, "%p", node);
\}

static void
trace_shownode(int depth, Node *node)
\{
    double d;

    if ( node == (Node *)0 )
        fprintf(stderr, "-null-");
#if !ONLY_BOXED_OBJECTS
    else if ( is_unboxed(node) )
        fprintf(stderr, "%ld", unboxed_val(node));
#endif
    else
        switch ( node_tag(node) )
        \{
        case CHAR_TAG:
            fprintf(stderr, "'%s'", lit_char(node->ch.ch, '\\''));
            break;
#if ONLY_BOXED_OBJECTS
        case INT_TAG:
            fprintf(stderr, "%ld", node->i.i);
            break;
#endif
        case FLOAT_TAG:
            get_float_val(d, node->f);
            fprintf(stderr, "%g", d);
            break;
        case VARIABLE_TAG:
            fprintf(stderr, "var@%p", node);
            break;
        case QUEUEME_TAG:
            fprintf(stderr, "que@%p", node);
            break;
        case SUSPEND_TAG:
            fprintf(stderr, "susp@%p=", node);
            trace_shownode(depth, node->s.fn);
            break;
        case PAPP_TAG:
        case CLOSURE_TAG:
            trace_showapp(depth, node, closure_argc(node), node->cl.args);
            break;
        case SEARCH_CONT_TAG:
            fprintf(stderr, "cont@%p", node);
            break;
        case INDIR_TAG:
            trace_shownode(depth, node->n.node);
            break;
        default:
            if ( is_abstract_node(node) )
            \{
                const char *name = node->c.info->cname;
                if ( name == (const char *)0 )
                    name = "<abstract>";
                fprintf(stderr, "%s@%p", name, node);
            \}
            else if ( is_vector(node) )
                trace_showapp(depth, node, vector_argc(node), node->a.args);
            else
                trace_showapp(depth, node, constr_argc(node), node->c.args);
            break;
        \}
\}

static void
trace_showapp(int depth, Node *node, unsigned argc, Node **argv)
\{
    unsigned i;

    if ( argc > 0 )
        fputc('(', stderr);

    fprintf(stderr, "%s", node->c.info->cname);
    if ( depth > 0 )
        for ( i = 0; i < argc; i++ )
        \{
            fputc(' ', stderr);
            trace_shownode(depth - 1, argv[i]);
        \}
    else if ( argc > 0 )
        fprintf(stderr, " ...");

    if ( argc > 0 )
        fputc(')', stderr);
\}
\nwnotused{trace.c}\nwendcode{}

\nwixlogsorted{c}{{trace.c}{NW43ObGg-2455o2-1}{\nwixd{NW43ObGg-2455o2-1}}}%
\nwixlogsorted{c}{{trace.h}{NW43ObGg-48WaAE-1}{\nwixd{NW43ObGg-48WaAE-1}}}%

