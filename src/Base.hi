__interface "Main" Base 1 500 where
__export  Base Data{Data} EvalEnv Expr{fv} Linear{Linear NonLinear} ModuleEnv OpPrec{OpPrec} PEnv PIdent{PIdent} PrecInfo{PrecInfo} QualExpr{qfv} QuantExpr{bv} TCEnv TypeInfo{AliasType DataType RenamingType} ValueEnv ValueInfo{DataConstructor NewtypeConstructor Value} bindEval bindFun bindGlobalInfo bindModule bindP bindTypeInfo defaultP errorAt filterBv fromQualType fromType infixOp initDCEnv initPEnv initTCEnv internalError isEvalAnnot isExtraVariables isIImportDecl isImportDecl isInfixDecl isTypeDecl isTypeSig isValueDecl linear lookupEval lookupModule lookupP lookupTC lookupTuple lookupTupleTC lookupValue nameSupply ppType ppTypeScheme predefTypes qfvStmt qualLookupP qualLookupTC qualLookupValue qualifyType rebindFun tcArity toQualType toQualTypes toType toTypes toTypezq tupleDCs tupleData tupleTCs unqualifyType;
__export  CurrySyntax Alt{Alt} CallConv{CallConvCCall CallConvPrimitive} CondExpr{CondExpr} ConstrDecl{ConOpDecl ConstrDecl} ConstrTerm{AsPattern ConstructorPattern InfixPattern LazzyPattern ListPattern LiteralPattern NegativePattern ParenPattern TuplePattern VariablePattern} Decl{DataDecl EvalAnnot ExternalDecl ExtraVariables FlatExternalDecl FunctionDecl ImportDecl InfixDecl NewtypeDecl PatternDecl TypeDecl TypeSig} Equation{Equation} EvalAnnotation{EvalChoice EvalRigid} Export{Export ExportModule ExportTypeAll ExportTypeWith} ExportSpec{Exporting} Expression{Apply Case Constructor Do EnumFrom EnumFromThen EnumFromThenTo EnumFromTo IfThenElse InfixApply Lambda LeftSection Let List ListCompr Literal Paren RightSection Tuple Typed UnaryMinus Variable} Goal{Goal} IDecl{HidingDataDecl IDataDecl IFunctionDecl IImportDecl IInfixDecl INewtypeDecl ITypeDecl} Import{Import ImportTypeAll ImportTypeWith} ImportSpec{Hiding Importing} Infix{Infix InfixL InfixR} InfixOp{InfixConstr InfixOp} Interface{Interface} Lhs{ApLhs FunLhs OpLhs} Literal{Char Float Int String} Module{Module} NewConstrDecl{NewConstrDecl} Qualified Rhs{GuardedRhs SimpleRhs} Statement{StmtBind StmtDecl StmtExpr} TypeExpr{ArrowType ConstructorType ListType TupleType VariableType} flatLhs opName;
__export  Ident Ident ModuleIdent QualIdent anonId boolId charId consId emptyMIdent falseId floatId fminusId intId ioId isInfixOp isQInfixOp isQSelectorId isQTupleId isQualified isSelectorId isTupleId listId localIdent mainId mainMIdent minusId mkIdent mkMIdent moduleName moduleQualifiers name nilId preludeMIdent qConsId qFalseId qIOId qNilId qSuccessId qTrueId qTupleArity qTupleId qUnitId qualName qualQualify qualUnqualify qualify qualifyWith renameIdent selectorId splitQualIdent successId trueId tupleArity tupleId unRenameIdent uniqueId unitId unqualify;
__export  Position Position{Position column file line} first incr next nl tab tabWidth;
__export  Types ExistTypeScheme{ForAllExist} Type{TypeArrow TypeConstrained TypeConstructor TypeSkolem TypeVariable} TypeScheme{ForAll} arrowArgs arrowArity arrowBase boolType charType floatType intType ioType isArrowType listType monoType polyType primType stringType successType tupleType typeConstrs typeSkolems typeVar typeVars unitType;
import Maybe;
import PrelReal;
import Char;
import PrelConc;
import Ratio;
import Ident :: 1 1 1 Ident 1 ModuleIdent 1 QualIdent 1 anonId 1 boolId 1 charId 1 consId 1 emptyMIdent 1 falseId 1 floatId 1 fminusId 1 intId 1 ioId 1 isInfixOp 1 isQInfixOp 1 isQSelectorId 1 isQTupleId 1 isQualified 1 isSelectorId 1 isTupleId 1 listId 1 localIdent 1 mainId 1 mainMIdent 1 minusId 1 mkIdent 1 mkMIdent 1 moduleName 1 moduleQualifiers 1 name 1 nilId 1 preludeMIdent 1 qConsId 1 qFalseId 1 qIOId 1 qNilId 1 qSuccessId 1 qTrueId 1 qTupleArity 1 qTupleId 1 qUnitId 1 qualName 1 qualQualify 1 qualUnqualify 1 qualify 1 qualifyWith 1 renameIdent 1 selectorId 1 splitQualIdent 1 successId 1 trueId 1 tupleArity 1 tupleId 1 unRenameIdent 1 uniqueId 1 unitId 1 unqualify 1 zdfEqIdent 1 zdfEqModuleIdent 1 zdfEqQualIdent 1 zdfOrdIdent 1 zdfOrdModuleIdent 1 zdfOrdQualIdent 1 zdfShowIdent 1 zdfShowModuleIdent 1 zdfShowQualIdent 1;
import Position :: 1 1 1 Position 1 first 1 incr 1 next 1 nl 1 tab 1 tabWidth 1 zdfEqPosition 1 zdfOrdPosition 1 zdfShowPosition 1;
import Env :: 1 1 1 Env 1 bindEnv 1 lookupEnv 1 zdfShowEnv 1;
import TopEnv :: 1 1 1 Entity 1 Source 1 TopEnv 1 bindTopEnv 1 emptyTopEnv 1 lookupTopEnv 1 moduleImports 1 predefTopEnv 1 qualBindTopEnv 1 qualLookupTopEnv 1 qualRebindTopEnv 1 rebindTopEnv 1 zddmmerge 1 zdfShowTopEnv 1;
import PrelBase ! :: 1;
import PrelFloat :: 1;
import PrelNum :: 1;
import PrelTup :: 1;
import PrelIOBase :: 1;
import PrelEnum :: 1;
import PrelShow :: 1;
import PrelList :: 1;
import CurrySyntax :: 1 1 1 Alt 1 CallConv 1 CondExpr 1 ConstrDecl 1 ConstrTerm 1 Decl 1 Equation 1 EvalAnnotation 1 Export 1 ExportSpec 1 Expression 1 Goal 1 IDecl 1 Import 1 ImportSpec 1 Infix 1 InfixOp 1 Interface 1 Lhs 1 Literal 1 Module 1 NewConstrDecl 1 Qualified 1 Rhs 1 Statement 1 TypeExpr 1 flatLhs 1 opName 1 zdfEqAlt 1 zdfEqCallConv 1 zdfEqCondExpr 1 zdfEqConstrDecl 1 zdfEqConstrTerm 1 zdfEqDecl 1 zdfEqEquation 1 zdfEqEvalAnnotation 1 zdfEqExport 1 zdfEqExportSpec 1 zdfEqExpression 1 zdfEqGoal 1 zdfEqIDecl 1 zdfEqImport 1 zdfEqImportSpec 1 zdfEqInfix 1 zdfEqInfixOp 1 zdfEqInterface 1 zdfEqLhs 1 zdfEqLiteral 1 zdfEqModule 1 zdfEqNewConstrDecl 1 zdfEqRhs 1 zdfEqStatement 1 zdfEqTypeExpr 1 zdfShowAlt 1 zdfShowCallConv 1 zdfShowCondExpr 1 zdfShowConstrDecl 1 zdfShowConstrTerm 1 zdfShowDecl 1 zdfShowEquation 1 zdfShowEvalAnnotation 1 zdfShowExport 1 zdfShowExportSpec 1 zdfShowExpression 1 zdfShowGoal 1 zdfShowIDecl 1 zdfShowImport 1 zdfShowImportSpec 1 zdfShowInfix 1 zdfShowInfixOp 1 zdfShowInterface 1 zdfShowLhs 1 zdfShowLiteral 1 zdfShowModule 1 zdfShowNewConstrDecl 1 zdfShowRhs 1 zdfShowStatement 1 zdfShowTypeExpr 1;
import Types :: 1 1 1 ExistTypeScheme 1 Type 1 TypeScheme 1 arrowArgs 1 arrowArity 1 arrowBase 1 boolType 1 charType 1 floatType 1 intType 1 ioType 1 isArrowType 1 listType 1 monoType 1 polyType 1 primType 1 stringType 1 successType 1 tupleType 1 typeConstrs 1 typeSkolems 1 typeVar 1 typeVars 1 unitType 1 zdfEqExistTypeScheme 1 zdfEqType 1 zdfEqTypeScheme 1 zdfShowExistTypeScheme 1 zdfShowType 1 zdfShowTypeScheme 1;
import PrelMaybe :: 1;
import Pretty :: 1 1 1 Doc 1 TextDetails 1 zdfShowDoc 1;
import Map :: 1 1 1 FM 1 fromListFM 1 lookupFM 1 zdfEqFM 1 zdfShowFM 1;
import CurryPP :: 1 1 1 ppTypeExpr 1;
import Set :: 1 1 1 Set 1 fromListSet 1 notElemSet 1 zdfEqSet 1 zdfShowSet 1;
import Utils :: 1 1 1 zpzpzn 1;
import List :: 1;
import Monad :: 1;
;
instance {PrelBase.Eq PrecInfo} = zdfEqPrecInfo ;
instance {PrelShow.Show PrecInfo} = zdfShowPrecInfo ;
instance {PrelBase.Eq OpPrec} = zdfEqOpPrec ;
instance {PrelShow.Show ValueInfo} = zdfShowValueInfo ;
instance __forall a (PrelShow.Show a) => {PrelShow.Show (Data a)} = zdfShowData ;
instance {PrelShow.Show TypeInfo} = zdfShowTypeInfo ;
instance {PrelBase.Eq PIdent} = zdfEqPIdent ;
instance {Expr CurrySyntax.TypeExpr} = zdfExprTypeExpr ;
instance {QuantExpr CurrySyntax.ConstrTerm} = zdfQuantExprConstrTerm ;
instance {QualExpr CurrySyntax.InfixOp} = zdfQualExprInfixOp ;
instance {QuantExpr CurrySyntax.Statement} = zdfQuantExprStatement ;
instance {QualExpr CurrySyntax.Alt} = zdfQualExprAlt ;
instance {QualExpr CurrySyntax.Statement} = zdfQualExprStatement ;
instance {QualExpr CurrySyntax.Expression} = zdfQualExprExpression ;
instance {QualExpr CurrySyntax.CondExpr} = zdfQualExprCondExpr ;
instance {QualExpr CurrySyntax.Rhs} = zdfQualExprRhs ;
instance {QuantExpr CurrySyntax.Lhs} = zdfQuantExprLhs ;
instance {QualExpr CurrySyntax.Equation} = zdfQualExprEquation ;
instance {QuantExpr CurrySyntax.Decl} = zdfQuantExprDecl ;
instance {QualExpr CurrySyntax.Decl} = zdfQualExprDecl ;
instance __forall e (QuantExpr e) => {QuantExpr [e]} = zdfQuantExprZMZN ;
instance __forall e (QualExpr e) => {QualExpr [e]} = zdfQualExprZMZN ;
instance __forall e (Expr e) => {Expr [e]} = zdfExprZMZN ;
instance {TopEnv.Entity PrecInfo} = zdfEntityPrecInfo ;
instance {PrelShow.Show OpPrec} = zdfShowOpPrec ;
instance {TopEnv.Entity ValueInfo} = zdfEntityValueInfo ;
instance {TopEnv.Entity TypeInfo} = zdfEntityTypeInfo ;
class QuantExpr e where { bv :: e -> [Ident.Ident]; };
class QualExpr e where { qfv :: Ident.ModuleIdent -> e -> [Ident.Ident]; };
class Expr e where { fv :: e -> [Ident.Ident]; };
infixOp :: CurrySyntax.InfixOp -> CurrySyntax.Expression;
linear :: __forall a (PrelBase.Eq a) => [a] -> Linear a;
isIImportDecl :: CurrySyntax.IDecl -> PrelBase.Bool;
isValueDecl :: CurrySyntax.Decl -> PrelBase.Bool;
isExtraVariables :: CurrySyntax.Decl -> PrelBase.Bool;
isEvalAnnot :: CurrySyntax.Decl -> PrelBase.Bool;
isTypeSig :: CurrySyntax.Decl -> PrelBase.Bool;
isTypeDecl :: CurrySyntax.Decl -> PrelBase.Bool;
isInfixDecl :: CurrySyntax.Decl -> PrelBase.Bool;
isImportDecl :: CurrySyntax.Decl -> PrelBase.Bool;
nameSupply :: [Ident.Ident];
internalError :: __forall a => PrelBase.String -> a;
errorAt :: __forall a => Position.Position -> PrelBase.String -> a;
filterBv :: __forall e (QuantExpr e) => e -> [Ident.Ident] -> [Ident.Ident];
qfvStmt :: Ident.ModuleIdent -> CurrySyntax.Statement -> [Ident.Ident] -> [Ident.Ident];
predefTypes :: [(Types.Type, [Data [Types.Type]])];
initDCEnv :: ValueEnv;
initTCEnv :: TCEnv;
initPEnv :: PEnv;
lookupEval :: Ident.Ident -> EvalEnv -> PrelMaybe.Maybe CurrySyntax.EvalAnnotation;
bindEval :: Ident.Ident -> CurrySyntax.EvalAnnotation -> EvalEnv -> EvalEnv;
qualLookupP :: Ident.QualIdent -> PEnv -> [PrecInfo];
lookupP :: Ident.Ident -> PEnv -> [PrecInfo];
bindP :: Ident.ModuleIdent -> Ident.Ident -> OpPrec -> PEnv -> PEnv;
defaultP :: OpPrec;
tupleDCs :: [ValueInfo];
lookupTuple :: Ident.Ident -> [ValueInfo];
qualLookupValue :: Ident.QualIdent -> ValueEnv -> [ValueInfo];
lookupValue :: Ident.Ident -> ValueEnv -> [ValueInfo];
rebindFun :: Ident.ModuleIdent -> Ident.Ident -> Types.TypeScheme -> ValueEnv -> ValueEnv;
bindFun :: Ident.ModuleIdent -> Ident.Ident -> Types.TypeScheme -> ValueEnv -> ValueEnv;
bindGlobalInfo :: __forall a => (Ident.QualIdent -> a -> ValueInfo) -> Ident.ModuleIdent -> Ident.Ident -> a -> ValueEnv -> ValueEnv;
tupleData :: [Data [Types.Type]];
tupleTCs :: [TypeInfo];
lookupTupleTC :: Ident.Ident -> [TypeInfo];
qualLookupTC :: Ident.QualIdent -> TCEnv -> [TypeInfo];
lookupTC :: Ident.Ident -> TCEnv -> [TypeInfo];
bindTypeInfo :: __forall a => (Ident.QualIdent -> PrelBase.Int -> a -> TypeInfo) -> Ident.ModuleIdent -> Ident.Ident -> [Ident.Ident] -> a -> TCEnv -> TCEnv;
tcArity :: TypeInfo -> PrelBase.Int;
lookupModule :: Ident.ModuleIdent -> ModuleEnv -> PrelMaybe.Maybe [CurrySyntax.IDecl];
bindModule :: CurrySyntax.Interface -> ModuleEnv -> ModuleEnv;
ppTypeScheme :: Ident.ModuleIdent -> Types.TypeScheme -> Pretty.Doc;
ppType :: Ident.ModuleIdent -> Types.Type -> Pretty.Doc;
unqualifyType :: Ident.ModuleIdent -> Types.Type -> Types.Type;
fromType :: Types.Type -> CurrySyntax.TypeExpr;
fromQualType :: Ident.ModuleIdent -> Types.Type -> CurrySyntax.TypeExpr;
qualifyType :: Ident.ModuleIdent -> Types.Type -> Types.Type;
toTypezq :: Map.FM Ident.Ident PrelBase.Int -> CurrySyntax.TypeExpr -> Types.Type;
toTypes :: [Ident.Ident] -> [CurrySyntax.TypeExpr] -> [Types.Type];
toType :: [Ident.Ident] -> CurrySyntax.TypeExpr -> Types.Type;
toQualTypes :: Ident.ModuleIdent -> [Ident.Ident] -> [CurrySyntax.TypeExpr] -> [Types.Type];
toQualType :: Ident.ModuleIdent -> [Ident.Ident] -> CurrySyntax.TypeExpr -> Types.Type;
type ModuleEnv = Env.Env Ident.ModuleIdent [CurrySyntax.IDecl];
data TypeInfo = DataType Ident.QualIdent PrelBase.Int [PrelMaybe.Maybe (Data [Types.Type])] | RenamingType Ident.QualIdent PrelBase.Int (Data Types.Type) | AliasType Ident.QualIdent PrelBase.Int Types.Type;
data Data a = Data Ident.Ident PrelBase.Int a;
type TCEnv = TopEnv.TopEnv TypeInfo;
data ValueInfo = DataConstructor Ident.QualIdent Types.ExistTypeScheme | NewtypeConstructor Ident.QualIdent Types.ExistTypeScheme | Value Ident.QualIdent Types.TypeScheme;
type ValueEnv = TopEnv.TopEnv ValueInfo;
data OpPrec = OpPrec CurrySyntax.Infix PrelBase.Int;
data PrecInfo = PrecInfo Ident.QualIdent OpPrec;
type PEnv = TopEnv.TopEnv PrecInfo;
type EvalEnv = Env.Env Ident.Ident CurrySyntax.EvalAnnotation;
data Linear a = Linear | NonLinear a;
data PIdent = PIdent Position.Position Ident.Ident;
zdfShowData :: __forall a (PrelShow.Show a) => {PrelShow.Show (Data a)};
zdfShowTypeInfo :: {PrelShow.Show TypeInfo};
zdfShowValueInfo :: {PrelShow.Show ValueInfo};
zdfEqOpPrec :: {PrelBase.Eq OpPrec};
zdfEqPrecInfo :: {PrelBase.Eq PrecInfo};
zdfEqPIdent :: {PrelBase.Eq PIdent};
zdfQuantExprZMZN :: __forall e (QuantExpr e) => {QuantExpr [e]};
zdfQuantExprConstrTerm :: {QuantExpr CurrySyntax.ConstrTerm};
zdfQuantExprDecl :: {QuantExpr CurrySyntax.Decl};
zdfQuantExprLhs :: {QuantExpr CurrySyntax.Lhs};
zdfQuantExprStatement :: {QuantExpr CurrySyntax.Statement};
zdfQualExprZMZN :: __forall e (QualExpr e) => {QualExpr [e]};
zdfQualExprInfixOp :: {QualExpr CurrySyntax.InfixOp};
zdfQualExprAlt :: {QualExpr CurrySyntax.Alt};
zdfQualExprStatement :: {QualExpr CurrySyntax.Statement};
zdfQualExprExpression :: {QualExpr CurrySyntax.Expression};
zdfQualExprCondExpr :: {QualExpr CurrySyntax.CondExpr};
zdfQualExprRhs :: {QualExpr CurrySyntax.Rhs};
zdfQualExprEquation :: {QualExpr CurrySyntax.Equation};
zdfQualExprDecl :: {QualExpr CurrySyntax.Decl};
zdfExprZMZN :: __forall e (Expr e) => {Expr [e]};
zdfExprTypeExpr :: {Expr CurrySyntax.TypeExpr};
zdfEntityPrecInfo :: {TopEnv.Entity PrecInfo};
zdfShowOpPrec :: {PrelShow.Show OpPrec};
zdfShowPrecInfo :: {PrelShow.Show PrecInfo};
zdfEntityValueInfo :: {TopEnv.Entity ValueInfo};
zdfEntityTypeInfo :: {TopEnv.Entity TypeInfo};
