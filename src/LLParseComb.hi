__interface "Main" LLParseComb 1 500 where
__export  LLParseComb Parser Symbol{isEOF} applyParser bracket chainl chainl1 chainr chainr1 layoutEnd layoutOff layoutOn many many1 ops opt position prefixParser sepBy sepBy1 succeed symbol zlz63Uz63Uzg zlz63Uzg zlzbz63Uzg zlzbzg zlzdzg zlzdzmzg zlzizg zlzmztzg zlzrzg zlzrzrzg zlztzg zlztzmzg zlztztzg;
import PrelFloat;
import PrelReal;
import PrelEnum;
import PrelList;
import Char;
import List;
import Position :: 1 1 1 Position 1 zdfEqPosition 1 zdfOrdPosition 1 zdfShowPosition 1;
import Error :: 1 1 1 Error 1 zdfEqError 1 zdfFunctorError 1 zdfMonadError 1 zdfOrdError 1 zdfShowError 1;
import Maybe :: 1;
import PrelBase ! :: 1;
import PrelNum :: 1;
import PrelTup :: 1;
import PrelIOBase :: 1;
import PrelShow :: 1;
import LexComb :: 1 1 1 Context 1 Indent 1 P 1 closeP0 1 closeP1 1 failP 1 parse 1 popContext 1 pushContext 1 returnP 1 thenP 1;
import PrelMaybe :: 1;
import Map :: 1 1 1 FM 1 addToFM 1 deleteFromFM 1 fromListFM 1 lookupFM 1 toListFM 1 zdfEqFM 1 zdfFunctorFM 1 zdfShowFM 1 zzeroFM 1;
import Set :: 1 1 1 Set 1 domainFM 1 intersectionSet 1 nullSet 1 zdfEqSet 1 zdfShowSet 1;
import Prelude :: 1;
import Monad :: 1;
infixl 4 zlzizg infixl 4 zlz63Uz63Uzg infixl 4 zlztztzg infixl 4 zlzmztzg infixl 4 zlztzmzg infixl 4 zlzdzmzg infixl 4 zlzdzg infixl 2 opt infixl 5 zlzrzrzg infixl 5 zlzrzg infixl 4 zlztzg infixl 3 zlzbz63Uzg infixl 3 zlzbzg infixl 2 zlz63Uzg;
instance __forall s a b (Symbol s) => {PrelShow.Show (Parser s a b)} = zdfShowParser ;
class (PrelBase.Ord s, PrelShow.Show s) => Symbol s where { isEOF :: s -> PrelBase.Bool; };
layoutOff :: __forall s a b (Symbol s) => Parser s a b;
layoutEnd :: __forall s a b (Symbol s) => Parser s a b;
layoutOn :: __forall s a b (Symbol s) => Parser s a b;
ops :: __forall s a b (Symbol s) => [(s, a)] -> Parser s a b;
bracket :: __forall s a c b (Symbol s) => Parser s a c -> Parser s b c -> Parser s a c -> Parser s b c;
chainl1 :: __forall s a b (Symbol s) => Parser s a b -> Parser s (a -> a -> a) b -> Parser s a b;
chainl :: __forall s a b (Symbol s) => Parser s a b -> Parser s (a -> a -> a) b -> a -> Parser s a b;
chainr1 :: __forall s a b (Symbol s) => Parser s a b -> Parser s (a -> a -> a) b -> Parser s a b;
chainr :: __forall s a b (Symbol s) => Parser s a b -> Parser s (a -> a -> a) b -> a -> Parser s a b;
sepBy1 :: __forall s a c b (Symbol s) => Parser s a c -> Parser s b c -> Parser s [a] c;
sepBy :: __forall s a c b (Symbol s) => Parser s a c -> Parser s b c -> Parser s [a] c;
many1 :: __forall s a b (Symbol s) => Parser s a b -> Parser s [a] b;
many :: __forall s a b (Symbol s) => Parser s a b -> Parser s [a] b;
zlzizg :: __forall s a b d c (Symbol s) => Parser s (a -> b) d -> Parser s (b -> c) d -> Parser s (a -> c) d;
zlz63Uz63Uzg :: __forall s a b (Symbol s) => Parser s a b -> Parser s (a -> a) b -> Parser s a b;
zlztztzg :: __forall s a c b (Symbol s) => Parser s a c -> Parser s (a -> b) c -> Parser s b c;
zlzmztzg :: __forall s a c b (Symbol s) => Parser s a c -> Parser s b c -> Parser s b c;
zlztzmzg :: __forall s a c b (Symbol s) => Parser s a c -> Parser s b c -> Parser s a c;
zlzdzmzg :: __forall a s b c (Symbol s) => a -> Parser s b c -> Parser s a c;
zlzdzg :: __forall a b s c (Symbol s) => (a -> b) -> Parser s a c -> Parser s b c;
opt :: __forall s a b (Symbol s) => Parser s a b -> a -> Parser s a b;
zlzrzrzg :: __forall s a b (Symbol s) => Parser s a b -> [s] -> Parser s a b;
zlzrzg :: __forall s a c b (Symbol s) => Parser s a c -> Parser s b c -> Parser s a c;
zlztzg :: __forall s a b c (Symbol s) => Parser s (a -> b) c -> Parser s a c -> Parser s b c;
zlzbz63Uzg :: __forall s a b (Symbol s) => Parser s a b -> Parser s a b -> Parser s a b;
zlzbzg :: __forall s a b (Symbol s) => Parser s a b -> Parser s a b -> Parser s a b;
zlz63Uzg :: __forall s a b (Symbol s) => Parser s a b -> PrelBase.String -> Parser s a b;
symbol :: __forall s a (Symbol s) => s -> Parser s s a;
succeed :: __forall a s b (Symbol s) => a -> Parser s a b;
position :: __forall s b (Symbol s) => Parser s Position.Position b;
prefixParser :: __forall s a (Symbol s) => Parser s a a -> Lexer s a -> PrelIOBase.FilePath -> PrelBase.String -> Error.Error a;
applyParser :: __forall s a (Symbol s) => Parser s a a -> Lexer s a -> PrelIOBase.FilePath -> PrelBase.String -> Error.Error a;
type Empty = PrelBase.Bool;
type SuccessCont s a = Position.Position -> s -> LexComb.P a;
type FailureCont a = Position.Position -> PrelBase.String -> LexComb.P a;
type Lexer s a = SuccessCont s a -> FailureCont a -> LexComb.P a;
type ParseFun s a b = (a -> SuccessCont s b) -> FailureCont b -> SuccessCont s b;
data Parser s a b = Parser (PrelMaybe.Maybe (ParseFun s a b)) (Map.FM s (Lexer s b -> ParseFun s a b));
zdfShowParser :: __forall s a b (Symbol s) => {PrelShow.Show (Parser s a b)};
